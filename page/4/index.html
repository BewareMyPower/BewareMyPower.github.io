<!DOCTYPE html>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BewareMyPower的博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="BewareMyPower的博客">
<meta property="og:locale">
<meta property="article:author" content="XYZ, aka BewareMyPower">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BewareMyPower的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BewareMyPower的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/06/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/06/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/" class="post-title-link" itemprop="url">我的vim开发环境搭建(1): 准备工作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-06 03:43:39" itemprop="dateCreated datePublished" datetime="2019-06-06T03:43:39+08:00">2019-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>即将毕业入职，之前实习时的开发机是CentOS 6.10，因此这里vim开发环境的搭建是基于CentOS 6.10的。</p>
<p>相比更流行的Ubuntu系统，CentOS的毛病实在太多了，折腾起来累死人。另一方面，由于公司开发机并不能像个人电脑一样随心所欲，所以像高版本的vim、gcc等，都是安装到自己的HOME目录，因此绝大多数软件需要手动下载源码、编译、安装到HOME目录。</p>
<p>问题来了，为什么要升级高版本？</p>
<ol>
<li>CentOS 6.10的源默认软件太老了，比如gcc版本才4.4.7，连C++11都不支持；</li>
<li>像YouCompleteMe(YCM)这种优秀的插件，需要各种高版本软件。</li>
</ol>
<p>为了节约篇幅，后文的下载、解压的命令都省略了，比如下载基本就是找到官网下载链接，然后<code>wget</code>命令下载下来，对于github上的项目，直接<code>git clone</code>。有时候比较慢，我会在租的VPS上下载好，然后打包传回来。</p>
<p>使用<code>tar</code>解压，对<code>.tar.gz</code>后缀的用<code>zxvf</code>选项来解压，对<code>.tar.bz</code>后缀的用<code>jxvf</code>选项解压，对<code>.tar</code>或<code>.tar.xz</code>后缀的用<code>xvf</code>选项解压。其中<code>v</code>选项不是必要的，只是查看解压了什么内容。</p>
<p>本人在折腾的过程中踩了很多坑，遇到很多错误，借助Google解决了大量问题，后文中不会对这些问题进行描述，而是直接讲述最终尝试后可行的方案。所有尝试均在VMware中新安装的CentOS 6.10系统上进行，系统来源于<a target="_blank" rel="noopener" href="http://mirrors.zju.edu.cn/centos/6.10/isos/x86_64/">CentOS镜像站</a>的bin-DVD1版本。</p>
<p>所有的软件均安装在<code>$HOME/local</code>下，我将其设为了环境变量<code>LOCAL</code>，通过在<code>~/.bashrc</code>中加上如下内容：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">LOCAL</span>=<span class="variable">$HOME</span>/local</span><br></pre></td></tr></table></figure>

<h2 id="1-升级gcc"><a href="#1-升级gcc" class="headerlink" title="1. 升级gcc"></a>1. 升级gcc</h2><p>这里选用了我一直用的gcc版本，也是Ubuntu 16.04默认安装的最新版本：5.4。其实只需要4.8就够了，即完整支持C++11的功能。</p>
<p>在CentOS下需要安装交叉编译IDE依赖，参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24325754/gcc-installation-error">gcc installation error</a>，我新安装的系统没有g++，因此还需要安装<code>gcc-c++</code>。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y glibc-devel.<span class="type">i686</span> libgcc.<span class="type">i686</span> gcc-<span class="keyword">c</span>++</span><br></pre></td></tr></table></figure>

<p>去官网给出的<a target="_blank" rel="noopener" href="https://www.gnu.org/prep/ftp.html">镜像列表</a>中找到中国的地址，比如<a target="_blank" rel="noopener" href="https://mirrors.ustc.edu.cn/gnu/">ustc镜像</a>，下载gcc源码并解压，然后进入gcc源码目录，执行以下命令编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./contrib/download_prerequisites</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">../configure --prefix=<span class="variable">$LOCAL</span>/gcc-5.4.0 --enable-languages=c,c++</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>这里说明下，<code>make</code>选项是<code>-j4</code>是采用4个进程编译，因为我的个人电脑是4核。上述命令的逻辑就是新建<code>build</code>目录，然后<code>configure</code>、<code>make</code>、<code>make install</code>三步走的套路，通过<code>--prefix</code>选项指定<code>install</code>的目录。</p>
<p>修改<code>~/.bashrc</code>文件，设置环境变量来使本地的文件优先于全局的同名文件被选择：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">GCC_DIR</span>=<span class="variable">$LOCAL</span>/gcc-5.4.0</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$GCC_DIR</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$GCC_DIR</span>/lib:$GCC_DIR/lib64:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>比如在我的电脑上这么配置后，<code>gcc</code>命令默认就是<code>~/local/gcc-5.4.0/bin/gcc</code>而非<code>/usr/bin/gcc</code>了。</p>
<h2 id="2-升级某些软件"><a href="#2-升级某些软件" class="headerlink" title="2. 升级某些软件"></a>2. 升级某些软件</h2><p>有了高版本的gcc后便可从源码中直接编译安装高版本的软件了。本节升级的软件版本均已够用，如果需要更高版本的，可以选择下载更高版本的源码进行编译。</p>
<h3 id="2-1-安装Python-2-7-16"><a href="#2-1-安装Python-2-7-16" class="headerlink" title="2.1 安装Python 2.7.16"></a>2.1 安装Python 2.7.16</h3><p>去官网下载源码解压，进入目录。首先安装依赖项，然后编译、安装（其中<code>test_weakref</code>耗时比较久）：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y zlib zlib-devel openssl* bzip2*</span><br><span class="line">./configure --prefix=$<span class="keyword">LOCAL</span>/python2<span class="number">.7</span><span class="number">.16</span>/ --<span class="keyword">enable</span>-shared --with-zlib --<span class="keyword">enable</span>-optimizations</span><br><span class="line"><span class="built_in">make</span> -j4</span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>

<p>在<code>~/.bashrc</code>文件中添加环境变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">PY2_DIR</span>=<span class="variable">$LOCAL</span>/python2.7.16</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$PY2_DIR</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$PY2_DIR</span>/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h3 id="2-2-安装cmake-3-14-5"><a href="#2-2-安装cmake-3-14-5" class="headerlink" title="2.2 安装cmake 3.14.5"></a>2.2 安装cmake 3.14.5</h3><p>去官网下载源码解压，进入目录。直接编译、安装：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=<span class="variable">$LOCAL</span>/cmake-3.14.5</span><br><span class="line">gmake -j4</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>这里的是<code>gmake</code>而非<code>make</code>，但在Linux上<code>gmake</code>只是指向<code>make</code>的符号链接，代表GNU Make。</p>
<p>在<code>~/.bashrc</code>文件中添加环境变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">CMAKE_DIR</span>=<span class="variable">$LOCAL</span>/cmake-3.14.5</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CMAKE_DIR</span>/bin:$PATH</span><br></pre></td></tr></table></figure>

<h3 id="2-3-安装vim-8-1"><a href="#2-3-安装vim-8-1" class="headerlink" title="2.3 安装vim 8.1"></a>2.3 安装vim 8.1</h3><p>去github上克隆vim源码，进入目录，首先安装依赖项，然后编译安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash">sudo yum -y groupinstall <span class="string">&#x27;Development Tools&#x27;</span></span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">sudo yum -y install ruby perl-devel python-devel ruby-devel perl-ExtUtils-Embed ncurses-devel</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">./configure --prefix=<span class="variable">$LOCAL</span>/vim \</span></span><br><span class="line"><span class="language-bash"> --with-features=huge \</span></span><br><span class="line"><span class="language-bash"> --enable-multibyte \</span></span><br><span class="line"><span class="language-bash"> --enable-pythoninterp=<span class="built_in">yes</span> \</span></span><br><span class="line"><span class="language-bash"> --with-python-config-dir=<span class="variable">$PY2_DIR</span>/lib \</span></span><br><span class="line"><span class="language-bash"> --enable-luainterp=<span class="built_in">yes</span> \</span></span><br><span class="line"><span class="language-bash"> --enable-cscope</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">make VIMRUNTIMEDIR=<span class="variable">$LOCAL</span>/vim/share/vim/vim81</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> src</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">make</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<p>在<code>~/.bashrc</code>文件中添加环境变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">VIMPATH</span>=<span class="variable">$HOME</span>/local/vim</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$VIMPATH</span>/bin:$PATH</span><br></pre></td></tr></table></figure>

<h3 id="2-4-安装clang-8-0"><a href="#2-4-安装clang-8-0" class="headerlink" title="2.4 安装clang 8.0"></a>2.4 安装clang 8.0</h3><p>去<a target="_blank" rel="noopener" href="http://releases.llvm.org/download.html">LLVM下载页</a>分别下载llvm、clang、clang-tools-extra、compiler-rt源码按照以下命令解压、重命名：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wget</span> http://releases.llvm.org/<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>/llvm-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">tar</span> xvf llvm-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">mv</span> llvm-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src llvm</span><br><span class="line"><span class="attribute">cd</span> llvm/tools</span><br><span class="line"><span class="attribute">wget</span> http://releases.llvm.org/<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>/cfe-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">tar</span> xvf cfe-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">mv</span> cfe-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src clang</span><br><span class="line"><span class="attribute">cd</span> clang/tools</span><br><span class="line"><span class="attribute">wget</span> http://releases.llvm.org/<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>/clang-tools-extra-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">tar</span> xvf clang-tools-extra-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">mv</span> clang-tools-extra-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src extra</span><br><span class="line"><span class="attribute">cd</span> ../../../projects/</span><br><span class="line"><span class="attribute">wget</span> http://releases.llvm.org/<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>/compiler-rt-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">tar</span> xvf compiler-rt-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src.tar.xz</span><br><span class="line"><span class="attribute">mv</span> compiler-rt-<span class="number">8</span>.<span class="number">0</span>.<span class="number">0</span>.src compiler-rt</span><br></pre></td></tr></table></figure>

<p>最终层次结构为：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">llvm</span><br><span class="line">  \<span class="comment">-- tools</span></span><br><span class="line">     \<span class="comment">-- clang</span></span><br><span class="line">        \<span class="comment">-- tools</span></span><br><span class="line">           \<span class="comment">-- extra</span></span><br><span class="line">  \<span class="comment">-- projects</span></span><br><span class="line">     \<span class="comment">-- compiler-rt</span></span><br></pre></td></tr></table></figure>

<p>其中clang目录为重命名后的cfe目录，extra目录为重命名后的clang-tools-extra目录，并且都去掉了后缀版本号。</p>
<p>然后进入llvm目录，执行下列编译操作，注意cmake识别的gcc路径仍然是系统路径，因此需要手动指定CC和CXX路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">mkdir</span> build</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash"><span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">CC=<span class="variable">$LOCAL</span>/gcc-5.4.0/bin/gcc CXX=<span class="variable">$LOCAL</span>/gcc-5.4.0/bin/c++ \</span></span><br><span class="line"><span class="language-bash">cmake -G <span class="string">&quot;Unix Makefiles&quot;</span> -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/local/clang8.0 \</span></span><br><span class="line"><span class="language-bash">-DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=<span class="string">&quot;X86&quot;</span> ..</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">make -j4</span></span><br><span class="line"><span class="meta">$ </span><span class="language-bash">make install</span></span><br></pre></td></tr></table></figure>

<p>这里多线程编译可能会有问题，我用<code>-j4</code>编译到68%的<code>ASTImporter</code>时<code>cc1plus</code>直接崩了，报错如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">68</span>%] Building CXX object tools<span class="regexp">/clang/</span>lib<span class="regexp">/AST/</span>CMakeFiles<span class="regexp">/clangAST.dir/</span>ASTImporter.cpp.o</span><br><span class="line">c++: internal compiler error: Killed (program cc1plus)</span><br></pre></td></tr></table></figure>

<p>在.bashrc文件中添加环境变量</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">CLANG_DIR</span>=<span class="variable">$LOCAL</span>/clang8.0</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$CLANG_DIR</span>/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$CLANG_DIR</span>/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h2 id="3-安装vim-plug管理插件"><a href="#3-安装vim-plug管理插件" class="headerlink" title="3. 安装vim-plug管理插件"></a>3. 安装vim-plug管理插件</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~<span class="regexp">/.vim/</span>autoload/plug.vim --create-dirs \</span><br><span class="line">    https:<span class="regexp">//</span>raw.githubusercontent.com<span class="regexp">/junegunn/</span>vim-plug<span class="regexp">/master/</span>plug.vim</span><br></pre></td></tr></table></figure>

<p>之后编辑<code>~/.vimrc</code>便可添加管理的插件，其格式如下：</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&quot; vim插件下载目录</span><br><span class="line">call plug<span class="function"><span class="keyword">#</span><span class="title">begin</span><span class="params">(&#x27;~/.<span class="variable">vim</span>/<span class="variable">plugged</span>&#x27;)</span></span></span><br><span class="line"></span><br><span class="line">&quot; vim插件列表，对应github项目地址</span><br><span class="line">Plug &#x27;tpope/vim-sensible&#x27;</span><br><span class="line">Plug &#x27;junegunn/seoul256.vim&#x27;</span><br><span class="line"></span><br><span class="line">&quot; 结束列表</span><br><span class="line">call plug<span class="function"><span class="keyword">#</span><span class="title">end</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>vim命令模式下<code>:PlugInstall</code>从github网址中克隆安装所有插件，<code>:PlugClean</code>卸载注释掉的插件列表。安装的插件会位于目录<code>~/.vim/plugged</code>下，如果要使用代理，可以手动克隆到该路径。</p>
<h2 id="4-插件无关的vimrc配置"><a href="#4-插件无关的vimrc配置" class="headerlink" title="4. 插件无关的vimrc配置"></a>4. 插件无关的vimrc配置</h2><p>将下列代码添加在<code>~/.vimrc</code>中：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; 定义&lt;leader&gt;为分号，此行代码必须在插件配置代码之前</span></span><br><span class="line"><span class="string">let mapleader=&quot;</span>;<span class="string">&quot;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 在处理未保存或只读文件的时候，弹出确认</span><br><span class="line"><span class="built_in">set</span> confirm</span><br><span class="line"><span class="string">&quot; 自适应不同语言的智能缩进</span></span><br><span class="line"><span class="string">filetype indent on</span></span><br><span class="line"><span class="string">&quot;</span> 设置编辑时制表符占用空格数</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">tabstop</span>=4</span><br><span class="line"><span class="string">&quot; 设置格式化时制表符占用空格数</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">&quot;</span> 将制表符扩展为空格</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="string">&quot; 让 vim 把连续数量的空格视为一个制表符</span></span><br><span class="line"><span class="string">&quot;</span><span class="built_in">set</span> <span class="attribute">softtabstop</span>=4</span><br><span class="line"><span class="string">&quot; 显示行号</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">&quot;</span>搜索忽略大小写</span><br><span class="line"><span class="string">&quot;set ignorecase</span></span><br><span class="line"><span class="string">&quot;</span>搜索逐字符高亮</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="string">&quot; 使回格键（backspace）正常处理indent, eol, start等</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br><span class="line"><span class="string">&quot;</span> 允许backspace和光标键跨越行边界</span><br><span class="line"><span class="built_in">set</span> whichwrap+=&lt;,&gt;,h,l</span><br><span class="line"><span class="string">&quot; 在被分割的窗口间显示空白，便于阅读</span></span><br><span class="line"><span class="string">set fillchars=vert:\ ,stl:\ ,stlnc:\</span></span><br><span class="line"><span class="string">&quot;</span> 高亮显示匹配的括号</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="string">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span></span><br><span class="line"><span class="string">set matchtime=1</span></span><br><span class="line"><span class="string">&quot;</span> 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line"><span class="built_in">set</span> <span class="attribute">scrolloff</span>=3</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 括号补全</span></span><br><span class="line"><span class="string">inoremap ( ()&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap [ []&lt;LEFT&gt;</span></span><br><span class="line"><span class="string">inoremap &quot;</span> <span class="string">&quot;&quot;</span>&lt;ESC&gt;i</span><br><span class="line">inoremap <span class="string">&#x27; &#x27;</span><span class="string">&#x27;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &#123; &#123;&#125;&lt;ESC&gt;i</span></span><br><span class="line"><span class="string">inoremap &#123;&lt;CR&gt; &#123;&lt;CR&gt;&#125;&lt;ESC&gt;O</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function! ClosePair(char)</span></span><br><span class="line"><span class="string">    if getline(&#x27;</span>.<span class="string">&#x27;)[col(&#x27;</span>.<span class="string">&#x27;) - 1] == a:char</span></span><br><span class="line"><span class="string">        return &quot;\&lt;Right&gt;&quot;</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        return a:char</span></span><br><span class="line"><span class="string">    endif</span></span><br><span class="line"><span class="string">endfunction</span></span><br><span class="line"><span class="string">                            </span></span><br><span class="line"><span class="string">inoremap ) &lt;c-r&gt;=ClosePair(&#x27;</span>)<span class="string">&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">inoremap &#125; &lt;c-r&gt;=ClosePair(&#x27;</span>&#125;<span class="string">&#x27;)&lt;CR&gt;</span></span><br><span class="line"><span class="string">inoremap ] &lt;c-r&gt;=ClosePair(&#x27;</span>]<span class="string">&#x27;)&lt;CR&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本篇博客主要完成了gcc、python、cmake、vim、clang的升级&#x2F;安装，均采取了直接编译源码的方式，而像gcc和clang的源码编译非常耗时，python的源码编译虽然较快，但是test_weakref脚本的执行非常慢。</p>
<p>编译源码的方式较为简单，但有些依赖项必须安装，否则找解决方法非常麻烦。</p>
<p>最后安装了vim-plug作为插件管理器，并给出了插件无关的部分vimrc脚本。下一章节将着重介绍我个人常用的插件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/14/make-shared%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/make-shared%E8%B0%83%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">make_shared调用私有构造函数的解决方法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-14 01:08:07" itemprop="dateCreated datePublished" datetime="2019-04-14T01:08:07+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-enable-from-shared"><a href="#1-enable-from-shared" class="headerlink" title="1. enable_from_shared"></a>1. enable_from_shared</h2><p>在 <em>Effective Modern C++</em> 的条款19中提到了 shared_ptr 的问题，对于某个共享所有权的类(记为 Widget )的示例，可能会将引用对象分享给其他类，比如如下所示的观测者模式示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;Widget&gt;&gt; observed_widgets;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Widget::addToObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  observed_widgets.<span class="built_in">emplace_back</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Widget 类的成员函数 addToObserver 将自身指针添加到全局的 Widget 列表 observed_widgets 中。</p>
<p>上述代码的问题在于， this 的类型是裸指针 <code>Widget*</code> ，在添加进 vector 中时，会用裸指针构造 shared_ptr 对象，创建一个新的引用计数。如果调用 addToObserver 的对象本身也是 shared_ptr ，会导致对同一对象有2个引用计数，因此该对象会被析构2次，产生未定义的行为。</p>
<p>解决方式是继承<code>enable_shared_from_this&lt;Widget&gt;</code>类（使用了C++的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F">奇妙递归模板模式</a>），像这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span>;  <span class="comment">// 前置声明</span></span><br><span class="line">vector&lt;shared_ptr&lt;Widget&gt;&gt; observed_widgets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">addToObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    observed_widgets.<span class="built_in">emplace_back</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Widget 类从基类继承了 shared_from_this 方法，该方法会查询当前对象是否已经被 shared_ptr 引用了，如果有，则返回该 shared_ptr 对象而非裸指针 this 。</p>
<p>需要注意的是如果没有，会出现未定义行为，比如在我的系统上是抛出 <code>std::back_weak_ptr</code> 异常。因此良好的设计需要把 Widget 的构造函数私有化，并使用工厂方法来创建 <code>shared_ptr&lt;Widget&gt;</code> 对象，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Widget&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// C++14语法，自动推导返回类型，参考Effective Modern C++条款2和3</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget); &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-make-shared代替new与私有构造函数的冲突"><a href="#2-make-shared代替new与私有构造函数的冲突" class="headerlink" title="2. make_shared代替new与私有构造函数的冲突"></a>2. make_shared代替new与私有构造函数的冲突</h2><p><em>Effective Modern C++</em> 的条款21阐述了 make_shared 的优点，这里不详述，简单总结就是：</p>
<ol>
<li>更高的异常安全级别，防止构造 shared_ptr 之前就调用 new ，抛出异常;</li>
<li>仅分配1次内存来保存引用对象和控制块(两者内存分布是连续的);</li>
</ol>
<p>缺点则是无法指定自定义析构器，再就是大括号初始化的歧义，但在这两种情况之外， make_shared 存在尺寸和速度上的优势，原则上是能使用 make_shared 则使用之。</p>
<p><em>Effective Modern C++</em> 给出了例外场景：</p>
<ol>
<li>自定义内存管理的类: 需要传递自定义析构器， make_shared 无法使用;</li>
<li>内存紧张的系统或非常大的对象：由于内存碎片的问题，分配1次内存比分配2次内存更容易失败。</li>
</ol>
<p>修改工厂方法如下所示（这里和后文均忽略基类和其他成员）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">create</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;Widget&gt;(); &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译失败，错误提示如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: ‘constexpr Widget::Widget()’ is private</span><br><span class="line">   Widget() = default;</span><br><span class="line">   ^</span><br><span class="line">/usr/include/c++/5/ext/new_allocator.h:120:4: error: within this context</span><br><span class="line">  &#123; ::new((void *)__p) _Up(std::forward&lt;_Args&gt;(__args)...); &#125;</span><br></pre></td></tr></table></figure>

<p>原因是 make_shared 函数模板并非 Widget 类的友元函数，其访问了私有构造函数。而静态成员函数可以访问类的私有成员(比如这里的私有构造函数)，因此可以在 create 内部调用 new (两步：分配内存、调用构造函数)。</p>
<p>不知道是不是 C++ 在制定 make_shared 的标准时疏忽的一点，但是在保持可移植性的情况下，最简单的方法就是用 new 替代 make_shared ，而且仔细来看， make_shared 的性能优势可能并没那么重要，至于异常安全，大多数时候程序处理 new 抛出的异常就是任其终止。</p>
<p>说句题外话，这也是 C++er 经常背负的心智负担，由于 C++ 自身的一些缺陷，导致使用者经常纠结是否过早优化。但既然本篇讨论这个问题了，那就给出一些解决方式。</p>
<h2 id="3-解决方式"><a href="#3-解决方式" class="headerlink" title="3. 解决方式"></a>3. 解决方式</h2><p>stackoverflow 上有<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const">相关讨论</a> ，本文对其进行一些整合，给出2种典型的方法。</p>
<h3 id="3-1-使用公有构造的派生类"><a href="#3-1-使用公有构造的派生类" class="headerlink" title="3.1 使用公有构造的派生类"></a>3.1 使用公有构造的派生类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">create</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">EnableMakeShared</span> : <span class="keyword">public</span> Widget &#123;</span><br><span class="line">      <span class="built_in">EnableMakeShared</span>(Args&amp;&amp;... args) : <span class="built_in">Widget</span>(std::forward&lt;Args&gt;(args)...) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_pointer_cast</span>&lt;Widget&gt;(</span><br><span class="line">        <span class="built_in">make_shared</span>&lt;EnableMakeShared&gt;(std::forward&lt;Args&gt;(args)...));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">// other constructors...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该方法通过原封不动地继承 Widget 类，并利用可变参数模板覆盖 Widget 类的构造函数。然后通过派生类的 shared_ptr 向上转型为基类的 shared_ptr 。</p>
<p>这个方法的巧妙之处在于局部类（local class）的使用，如果是在类的外部定义其派生类，则必须将基类构造函数权限改成 protected 才能访问。</p>
<p>局部类只能访问外层作用域定义的类型名、静态变量以及枚举成员，而不能访问普通局部变量。但是类成员函数的局部类对类的私有成员的访问权限在书中并未提及我，网上搜到的一些资料也没找到，只有查看接近1400多页的C++标准文档，在 <em>9.8 Local class declaration</em> 中找到了如下定义：</p>
<blockquote>
<p>The local class is in the scope of the enclosing scope, and has the same access to names outside the function as does the enclosing function.</p>
</blockquote>
<p>局部类和所在的函数对函数外的名称具有相同的访问权限，因此类成员函数的局部类可以访问该类的所有成员，包括私有构造函数。</p>
<p>最后一个问题是使用 Widget 的派生类构造派生类，是否需要将 Widget 的析构函数声明为虚函数？这里是不需要的，因为派生类并未额外申请任何资源，因此不执行派生类的析构函数也是没有问题的。</p>
<h2 id="3-2-使用PassKey惯用法"><a href="#3-2-使用PassKey惯用法" class="headerlink" title="3.2 使用PassKey惯用法"></a>3.2 使用<a target="_blank" rel="noopener" href="https://arne-mertz.de/2016/10/passkey-idiom/">PassKey惯用法</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">PassKey</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">PassKey</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Widget</span><span class="params">(PassKey, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function">      : Widget(std::forward&lt;Args&gt;(args)...) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="keyword">auto</span> <span class="title">create</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_shared</span>&lt;Widget&gt;(PassKey&#123;&#125;, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">Widget</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="comment">// other constructors...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>PassKey惯用法的原理是通过给公有构造函数增加一个无意义的嵌套类（在这里即 PassKey 类），将其定义在类的私有域，在构造函数中使用嵌套类作为第1个参数，这样就无法从类的外部使用嵌套类的名字，因此无法调用这些构造函数。而类的静态成员函数可以访问嵌套类的名字，因此可以调用构造函数。</p>
<p>但这里有个细节， PassKey 的构造函数是 explicit 的，否则便可以在类外部传入 <code>&#123;&#125;</code> 作为构造函数的第1个参数，隐式转换成 PassKey 类。</p>
<p>另外还有个细节，PassKey 的构造函数不可以写成<code>explicit PassKey() = default</code>，否则在间接调用带实际参数的私有构造函数时会出错。比如，假设 Widget 类有如下私有构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Widget</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Widget</span>(<span class="type">const</span> <span class="type">char</span>*) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>调用及其编译结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget w1;  <span class="comment">// 错误! Widget()是私有的!</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(&#123;&#125;, <span class="string">&quot;hello&quot;</span>)</span></span>;  <span class="comment">// 通过编译</span></span><br></pre></td></tr></table></figure>

<p>但如果把 PassKey 类的构造函数像之前那样显式定义，而不是通过 <code>=default</code> 使用编译器自动合成的构造函数，上述代码中 w2 的构造就无法通过编译。<br>至于原因暂时还没弄懂。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>前文提到的2种方法都是用了一些比较冷门的语法，但是用起来还是比较麻烦且不直观。优雅的解决方案可能需要等待新的C++标准，比如<a target="_blank" rel="noopener" href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/YXyGFUq7Wa4">Andrew Schepler的C++标准提案</a>。<br>虽然等到新标准估计要到猴年马月了，总之C++11的一些新东西虽然好用，但是也留了不少坑，这点还是挺让人不愉快的，研究这些东西其实实质上也没还什么意义，自娱自乐罢了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/27/socket%E8%BF%AD%E4%BB%A3%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%ADCtrl-C%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/01/27/socket%E8%BF%AD%E4%BB%A3%E5%9E%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%ADCtrl-C%E5%AE%89%E5%85%A8%E9%80%80%E5%87%BA/" class="post-title-link" itemprop="url">socket迭代型服务器中Ctrl+C安全退出</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-01-27 20:31:24" itemprop="dateCreated datePublished" datetime="2019-01-27T20:31:24+08:00">2019-01-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近抽空在重新造网络库轮子，之前的<a target="_blank" rel="noopener" href="https://github.com/BewareMyPower/socket_util">socket_util</a>太过简陋，就是把socket地址、socket API、epoll和<code>sendall</code>、<code>recvn</code>之类的函数给封装下，发现自己的基础知识还是欠缺，于是边重做轮子边补充知识。<br>于是在做最基本的迭代型服务器时遇到了问题，就是<code>Ctrl+C</code>退出循环失败，这里记录下解决方案。</p>
<h2 id="1-信号中断后自动重启的系统调用"><a href="#1-信号中断后自动重启的系统调用" class="headerlink" title="1. 信号中断后自动重启的系统调用"></a>1. 信号中断后自动重启的系统调用</h2><p>最初的解决思路如下</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">::<span class="keyword">signal</span><span class="string"></span>(SIGINT, [](<span class="built_in">int</span>) &#123;&#125;);</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">int</span> ret = some_system_call();  <span class="comment">// 代替某些自动重启的系统调用</span></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// else ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路就是对于某些被信号中断后会自动重启的系统调用，检查返回值，为-1代表返回错误，然后检查<code>errno</code>，为<code>EINTR</code>就相当于被信号中断，此时跳出循环。<br>Linux上某些系统调用会导致阻塞，比如某些慢速I&#x2F;O操作(<code>read</code>、<code>write</code>、<code>recv</code>、<code>send</code>)，当然也包括socket的<code>accept</code>这种可以触发<code>epoll</code>监听事件的(在我看来算广义的I&#x2F;O操作)。如果对某个信号使用<code>sigaction</code>设置过信号处理器，并且时<code>sa_flags</code>字段包含<code>SA_RESTART</code>，那么这些系统调用在被该信号中断时会自动重启，避免了对<code>errno</code>的检查(像下面这样的代码)</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ret<span class="comment">;</span></span><br><span class="line">while ((<span class="name">ret</span> = some_system_call()) == <span class="number">-1</span> <span class="symbol">&amp;&amp;</span> errno == EINTR) continue<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>sigaction</code>使用示例如下</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sigaction</span> act;</span><br><span class="line">act.sa_handler = [](<span class="type">int</span>) &#123;&#125;;  <span class="comment">// 信号处理器</span></span><br><span class="line">act.sa_flags = SA_RESTART;    <span class="comment">// 设置重启标志</span></span><br><span class="line"><span class="built_in">sigemptyset</span>(&amp;act.sa_mask);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sigaction</span>(SIGINT, &amp;act, <span class="literal">nullptr</span>);  <span class="comment">// 使信号处理器生效</span></span><br></pre></td></tr></table></figure>
<p>当然，这种自动重启的功能仅对特定的系统调用有效，可以参考<em>The Linux Programming Interface</em>的21.5节，个人简单总结如下：</p>
<ul>
<li>socket的阻塞操作(<code>accept</code>、<code>connect</code>、<code>recv</code>、<code>send</code>等)；</li>
<li>进程间IPC的阻塞操作(管道、FIFO、POSIX消息队列、信号量、文件锁)；</li>
<li>线程同步的阻塞操作(条件变量的等待)</li>
<li>终端的阻塞操作(比如向<code>STDOUT_FILENO</code>写或从<code>STDIN_FILENO</code>读)；</li>
<li><code>wait</code>系列，等待子进程终止；</li>
<li>可能会阻塞的<code>open</code>；</li>
<li><code>futex</code>(Linux独有)；</li>
</ul>
<p>而像<code>epoll</code>这种I&#x2F;O多路复用的，即使指定<code>SA_RESTART</code>也不会自动重启。其实从设计的出发点看很好理解。</p>
<h2 id="2-细节上的修改"><a href="#2-细节上的修改" class="headerlink" title="2. 细节上的修改"></a>2. 细节上的修改</h2><p>最初的解决方案在我实际应用中遇到了一些问题，比如这个循环是封装在我的库函数中的，而我需要传递一个回调函数给这个库函数来处理表示连接的socket用于读写。<br>这样问题来了，我在回调函数中如果是<code>while</code>循环来<code>recv</code>，那么在回调函数中是无法直接跳出所在函数的循环的，比如我的函数可能是这样</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void runIterativeServer(std::<span class="keyword">function</span>&lt;void(int)&gt; callback, ...) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="number">1</span>. 初始化socket相关操作...</span><br><span class="line">  <span class="regexp">//</span> <span class="number">2</span>. 为SIGINT设置信号处理器</span><br><span class="line">  <span class="keyword">while</span> (true) &#123;</span><br><span class="line">     <span class="regexp">//</span> <span class="number">3</span>. accept得到connfd，处理errno为EINTR的情况</span><br><span class="line">     callback(connfd);  <span class="regexp">//</span> <span class="number">4</span>. 执行回调函数</span><br><span class="line">     <span class="regexp">//</span> <span class="number">5</span>. 关闭connfd</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="regexp">//</span> <span class="number">6</span>. 清理操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法很简单，处理<code>EINTR</code>时<code>continue</code>即可，用信号处理器来退出<code>while</code>循环</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">bool</span> run = <span class="literal">false</span>;</span><br><span class="line">::<span class="built_in">signal</span>(SIGINT, [](<span class="type">int</span>) &#123; run = <span class="literal">false</span>; &#125;);</span><br><span class="line">run = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (run) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">some_system_call</span>();  <span class="comment">// 代替某些自动重启的系统调用</span></span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// else ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意细节，<code>static</code>和<code>volatile</code>。<br>使用<code>static</code>是因为信号处理器只能接受<code>void (*)(int)</code>这样的函数指针，不带捕获的<code>lambda</code>表达式可以与之兼容，但是带捕获的<code>lambda</code>表达式不行。本质上就是信号处理器只能处理全局变量。静态变量和全局变量本质是一样的，只是方便命名信息隔离，所以这里用函数内的静态变量。<br>使用<code>volatile</code>则是因为，开优化选项时编译器可能做某些优化来把<code>run</code>放到寄存器中读取而不是直接从内存读取，这样就会导致信号处理器的修改并不会被看到，从而<code>while</code>循环仍然判定为<code>true</code>，之前写过相关博客<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/0388f6f21fe0">C&#x2F;C++的volatile关键字应用示例</a>。</p>
<p>这样一来在回调函数中就可以写出这样的代码了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="type">ssize_t</span> num_recv = <span class="built_in">recv</span>(connfd, buf, <span class="built_in">sizeof</span>(buf), MSG_NOSIGNAL);</span><br><span class="line">  <span class="keyword">if</span> (num_recv == <span class="number">-1</span> &amp;&amp; errno == EINTR) <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里其实还有个很关键的问题，也是很容易被忽视的。其实无论是这个版本还是之前的版本，都是无效的，因为系统调用还是会自动重启，语句根本执行不到检查<code>errno</code>那一步。<br>原因是<code>Linux</code>的<code>signal</code>函数，默认是调用<code>sigaction</code>，并且将<code>sa_flags</code>设置为<code>SA_RESTART</code>，从而支持某些系统调用自动重启。在其他系统上，<code>signal</code>也可能具有不同的语义，因此必须手动调用<code>sigaction</code>来代替<code>signal</code>。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction act;</span><br><span class="line">act.sa_flags = <span class="number">0</span>;    <span class="regexp">//</span> 禁止系统调用自动重启</span><br><span class="line"><span class="regexp">//</span> ...</span><br></pre></td></tr></table></figure>
<p>参考<em>Unix环境高级编程</em>的10.14节。<br>最后，可以用<code>sigaction</code>取得之前的信号处理器，然后在函数结束时恢复<code>SIGINT</code>的默认处置。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction act, oldact;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 设置act的字段</span></span><br><span class="line"><span class="built_in">sigaction</span>(SIGINT, &amp;act, &amp;oldact);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">sigaction</span>(SIGINT, &amp;oldact, nullptr);</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/31/C-11%E4%B8%ADstd-thread%E5%92%8Cpthread%E6%B7%B7%E7%94%A8%E7%9A%84%E5%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/31/C-11%E4%B8%ADstd-thread%E5%92%8Cpthread%E6%B7%B7%E7%94%A8%E7%9A%84%E5%9D%91/" class="post-title-link" itemprop="url">C++11中std::thread和pthread混用的坑</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-31 16:30:14" itemprop="dateCreated datePublished" datetime="2018-12-31T16:30:14+08:00">2018-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早在之前我就因为混用<code>std::thread</code>和<code>pthread</code>出现bug时纠结过，当时还去查看过<code>std::thread</code>的实现源码，但后来还是没得出结果。现在看来主要原因是我没有找对位置，被C++又臭又长的模板元编程手法给转移了注意力。直到最近我把这个实现弄清楚后，自己造轮子时遇到了另一个bug，才回过头想起之前遇到的问题。</p>
<h2 id="1-在线程函数中调用pthread-exit和pthread-join"><a href="#1-在线程函数中调用pthread-exit和pthread-join" class="headerlink" title="1. 在线程函数中调用pthread_exit和pthread_join"></a>1. 在线程函数中调用<code>pthread_exit</code>和<code>pthread_join</code></h2><p>在C++11中，单靠<code>thread</code>是无法取得线程函数的返回值的，必须得借助<code>async</code>等异步设施，*Effective Modern C++*也推崇使用基于任务的并发编程而非基于线程。当然这个是后话了，<br>现在，我就是想直接取得线程函数的返回值，又不继续写<code>pthread</code>那套麻烦的线程函数，那么直接在<code>std::thread</code>的线程函数中调用<code>pthread</code> API？于是有了下面这段代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> make sure cast between long and void* is safe.</span></span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">([] &#123; pthread_exit(<span class="keyword">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="number">1</span>)); &#125;)</span></span>;</span><br><span class="line">  <span class="type">void</span>* ret;</span><br><span class="line">  <span class="built_in">pthread_join</span>(t.<span class="built_in">native_handle</span>(), &amp;ret);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread exit with %ld\n&quot;</span>, <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(ret));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行，结果如下</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># g++ -std=c++11 test.cc -pthread &amp;&amp; ./a.out                                                                                                              </span></span><br><span class="line">thread <span class="keyword">exit</span> with <span class="number">1</span></span><br><span class="line">terminate called without an active exception </span><br><span class="line">Aborted                                </span><br></pre></td></tr></table></figure>
<p>嗯？是不是还要调用<code>t.join()</code>？于是我加上了<code>t.join()</code>。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">thread <span class="keyword">exit</span> with <span class="number">1</span></span><br><span class="line">terminate called after throwing an instance of <span class="string">&#x27;std::system_error&#x27;</span></span><br><span class="line">  what():  No such process</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>
<p>这次是直接抛出异常了。好像都不行啊，那有没有解决方法呢？<br>在此之前，首先得明确一个问题，这里究竟该不该调用<code>t.join()</code>？</p>
<h2 id="2-std-terminate"><a href="#2-std-terminate" class="headerlink" title="2. std::terminate()"></a>2. <code>std::terminate()</code></h2><p><code>std::terminate()</code>在头文件<code>&lt;exception&gt;</code>中声明，函数签名如下</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[noreturn]]</span> void terminate() noexcept;</span><br></pre></td></tr></table></figure>
<p>功能是调用当前的terminate handler，可以用<code>set_terminate()</code>来指定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*terminate_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">terminate_handler <span class="title">set_terminate</span><span class="params">(terminate_handler f)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于没有被catch的异常，会默认调用<code>terminate()</code>，而<code>terminate()</code>会默认调用<code>abort()</code>。当然这三者并非等价，因为前两者还会打印出各自的信息，比如我们给出这三种调用的输出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> std::<span class="built_in">exception</span>();  <span class="comment">// 1</span></span><br><span class="line">std::<span class="built_in">terminate</span>();        <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">abort</span>();                 <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>分别运行这三条语句，均会使进程异常终止(比如在我的系统上<code>echo $?</code>得到结果是134)<br>语句1的输出是</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">terminate called after throwing an<span class="built_in"> instance </span>of &#x27;std::exception&#x27;</span><br><span class="line">  what():  std::exception</span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>
<p>语句2的输出是</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">terminate <span class="keyword">called</span> <span class="keyword">without</span> an active <span class="keyword">exception</span></span><br><span class="line">Aborted</span><br></pre></td></tr></table></figure>
<p>语句3的输出是</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Aborted</span></span><br></pre></td></tr></table></figure>
<p>从上面3种输出的区分可以看出，异常默认处理器、<code>std::terminate()</code>都会打印出自己的信息，然后再递归调用下一步。<br><code>std::terminate()</code>的主要用途是在禁止使用异常的C++项目中进行调用。<br>再回过头看第1节的运行结果，不难得出结论，调用<code>t.join()</code>会抛出异常，而不调用则仅仅是触发<code>std::terminate()</code>，检查<code>t.joinable()</code>的返回值，是true，但是<code>t.join()</code>却抛出了异常，原因当然是<code>pthread_join()</code>改变了<code>std::thread</code>的底层线程句柄，但是并没有将<code>std::thread</code>对象内部的句柄置为初始状态，导致<code>std::thread</code>误认为该线程还没有被<code>join()</code>。</p>
<h1 id="3-一窥std-thread实现"><a href="#3-一窥std-thread实现" class="headerlink" title="3. 一窥std::thread实现"></a>3. 一窥<code>std::thread</code>实现</h1><p>很遗憾，<code>&lt;thread.h&gt;</code>头文件中没有包含一些关键的函数的实现，所以得自己去下载<code>libstdc++</code>源码，该源码是<code>gcc</code>的一部分。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/gcc-mirror/g</span>cc.git</span><br></pre></td></tr></table></figure>
<p>就我当前的版本(commit 0b47d0)，<code>std::thread</code>的实现在这两个文件中</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">libstdc++-v3<span class="regexp">/include/</span>std/thread</span><br><span class="line">libstdc++-v3<span class="regexp">/src/</span>c++<span class="number">11</span>/thread.cc</span><br></pre></td></tr></table></figure>
<p>查看<code>thread.cc</code>中<code>join()</code>方法的实现</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">thread::<span class="built_in">join</span>()</span><br><span class="line">&#123;</span><br><span class="line">  int <span class="variable">__e</span> = EINVAL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_M_id</span> != id())</span><br><span class="line">    <span class="variable">__e</span> = <span class="variable">__gthread_join</span>(<span class="variable">_M_id</span>.<span class="variable">_M_thread</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">__e</span>)</span><br><span class="line">    <span class="variable">__throw_system_error</span>(<span class="variable">__e</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">_M_id</span> = id();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及<code>thread</code>中<code>joinable()</code>方法的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span></span></span><br><span class="line"><span class="function"><span class="title">joinable</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> !(_M_id == <span class="built_in">id</span>()); &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>_M_id</code>定义如下(<code>// ...</code>是我自己添加的注释，代表省略了其他代码)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/// thread</span></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">thread</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">typedef</span> <span class="type">__gthread_t</span>			native_handle_type;</span><br><span class="line"></span><br><span class="line">   ~<span class="built_in">thread</span>()</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">joinable</span>())</span><br><span class="line">std::<span class="built_in">terminate</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/// thread::id</span></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">id</span></span><br><span class="line">   &#123;</span><br><span class="line">     native_handle_type	_M_thread;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">   &#125;; </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">   id				_M_id;</span><br><span class="line"> &#125;; </span><br></pre></td></tr></table></figure>
<p><code>std::thread</code>本身只有1个成员变量<code>_M_id</code>，类型是<code>std::thread::id</code>，而<code>id</code>内部也只有1个成员变量<code>_M_thread</code>，类型是<code>std::thread::native_handle_type</code>，而这个类型标准没有给出规定，由不同操作系统和编译器来决定，显然gcc的实现是<code>__gthread_t</code>，而且在<code>join()</code>方法中是将该类型的变量传入了<code>__gthread_join</code>中。<br>简化上面的代码，也就是说实际上<code>std::thread</code>的<code>join</code>是类似这样的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__gthread_t</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myjoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> e = EINVAL;</span><br><span class="line">  <span class="keyword">if</span> (t != <span class="type">__gthread_t</span>())</span><br><span class="line">    e = __gthread_join(t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (e)</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">system_error</span>(e);</span><br><span class="line">  t = <span class="type">__gthread_t</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这里的<code>__g</code>前缀替换成<code>p</code>的话，相当于就是调用<code>pthread_join()</code>后，重置线程句柄的值为<code>pthread_t</code>的默认值，然后用句柄是否等于<code>pthread_t</code>的默认值来判断是否以及调用了<code>join()</code>。<br>而对于同一个句柄，重复调用<code>pthread_join()</code>会导致返回非0的错误码<code>e</code>，并抛出<code>std::system_error</code>异常。<br>因此，像我在第1节中做的，手动取得<code>native_handle</code>，然后手动调用<code>pthread_join()</code>，就会导致<code>std::thread</code>内部的线程句柄没有重置，进而<code>joinable()</code>返回了不应该返回的true，进而在析构函数中调用了<code>join()</code>。注意，C++析构函数是禁止抛出异常的，在C++11中析构函数默认为<code>noexcept(true)</code>，也就是说直接调用<code>std::terminate()</code>终止程序。<br>这也解释了第1节中两种不同输出的原因，简单总结如下</p>
<ol>
<li>不调用<code>t.join()</code>: <code>t</code>内部的线程句柄没有重置，析构函数判断<code>joinable()</code>为true，从而调用<code>t.join()</code>，抛出异常不被捕获，直接调用<code>std::terminate()</code>终止进程；</li>
<li>调用<code>t.join()</code>: <code>t</code>内部的线程句柄没有重置，调用<code>t.join()</code>，抛出异常，执行默认异常处理流程。</li>
</ol>
<p>PS: 为何析构函数禁止抛出异常，以及<code>noexcept</code>的概念，分别参考*Effective C++<em>和</em>Effective Modern C++*的相关条款。<br>哦对了，刚才分析的前提是，<code>__g</code>前缀可以被替换成<code>p</code>，为何可以呢？原因是gcc实际上也是跨平台的，因此会定义一组别名来屏蔽系统API的差异。由于Linux是遵守POSIX接口的，所以这组定义在gcc项目的<code>libgcc/gthr-posix.h</code>中，在该头文件中可以看到下列定义</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef pthread_t __gthread_t;</span><br><span class="line"><span class="comment">/* Typically, __gthrw_foo is a weak reference to symbol foo.  */</span></span><br><span class="line">#define <span class="constructor">__gthrw(<span class="params">name</span>)</span> <span class="constructor">__gthrw2(<span class="params">__gthrw_</span> ## <span class="params">name</span>,<span class="params">name</span>,<span class="params">name</span>)</span></span><br><span class="line"><span class="constructor">__gthrw(<span class="params">pthread_join</span>)</span></span><br></pre></td></tr></table></figure>
<p>类型别名可以直接typedef，函数名称就得改变符号表了，这里我就不给出内部的<code>__attribute__</code>、<code>__weakref__</code>等具体实现手段了。</p>
<h2 id="4-不可移植的混合调用方法"><a href="#4-不可移植的混合调用方法" class="headerlink" title="4. 不可移植的混合调用方法"></a>4. 不可移植的混合调用方法</h2><p>有了上述的源码分析后，实际上在<code>pthread_join()</code>之后要做的，仅仅是将<code>std::thread</code>的内部线程句柄重置就完了。不过源码直接将其用<code>private</code>保护，所以得强行做指针转换来修改。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*reinterpret_cast&lt;pthread_t*&gt;(<span class="name">&amp;t</span>) = pthread_t()<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>将这一句代码添加到<code>pthread_join()</code>之后即可。不过本身不可移植指的是这种做法是无法在不同编译器之间移植的，如果指定了编译器使用gcc版本，像这样hack下也未尝不可。<br>给个示例，线程函数中<code>new</code>一个int，然后<code>pthread_join</code>捕获该指针来处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">taskNewInt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">pthread_exit</span>(<span class="keyword">new</span> <span class="built_in">int</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(taskNewInt, <span class="number">47</span>)</span></span>;</span><br><span class="line">  <span class="type">void</span>* ret;</span><br><span class="line">  <span class="type">int</span> error = <span class="built_in">pthread_join</span>(t.<span class="built_in">native_handle</span>(), &amp;ret);</span><br><span class="line">  <span class="built_in">assert</span>(error == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread joinable? %s\n&quot;</span>, t.<span class="built_in">joinable</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">  *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">pthread_t</span>*&gt;(&amp;t) = <span class="built_in">pthread_t</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread joinable? %s\n&quot;</span>, t.<span class="built_in">joinable</span>() ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">int</span>*&gt;(ret))</span></span>;  <span class="comment">// RAII</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;thread exit with %d (%p)\n&quot;</span>, *p, p.<span class="built_in">get</span>());</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行结果</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">11</span> native_thread_exit.cc -pthread</span><br><span class="line">$ ./a.out</span><br><span class="line">thread joinable? Yes</span><br><span class="line">thread joinable? No</span><br><span class="line">thread <span class="keyword">exit</span> with <span class="number">47</span> (<span class="number">0</span>x7fd8640008c0)</span><br></pre></td></tr></table></figure>

<h2 id="5-pthread-exit和pthread-cancel会抛出异常"><a href="#5-pthread-exit和pthread-cancel会抛出异常" class="headerlink" title="5. pthread_exit和pthread_cancel会抛出异常"></a>5. <code>pthread_exit</code>和<code>pthread_cancel</code>会抛出异常</h2><p>对，你没看错，这两个C接口，会抛出异常。我之前在造线程轮子的时候，在某个调用<code>pthread_exit()</code>的包装函数声明为<code>noexcept</code>，结果被强制调用<code>std::terminate()</code>了。后来发现，原因是<code>pthread_exit</code>抛出了异常，而<code>noexcept</code>函数中抛出异常不会被捕获，只是简单调用<code>std::terminate()</code>了事。<br>嗯？问题来了，那这个异常又是怎么处理的呢？<br>异常的实现我没有仔细研究过，但大体上和<code>setjmp</code>、<code>longjmp</code>类似，让函数调用栈回绕(unwind)。只不过异常支持多层回绕，因此可以层层传播异常，把底层异常一步步抛到最上层一并处理，从而将错误处理和功能实现相分离。<br>C++和C虽然都是用同一套头文件，但是编译C++时链接到的动态库是libstdc++.so而非libc.so，其中用抛出<code>abi::__forced_unwind</code>异常的方式来简化这个回绕的实现，该异常的默认处理方式就是进行线程栈回绕。包含<code>&lt;cxxabi.h&gt;</code>头文件即可捕获该异常，当然，注意catch处理之后要重新throw抛出异常。<br>这个问题在stackoverflow上有所讨论，参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11452546/why-does-pthread-exit-throw-something-caught-by-ellipsis">why does pthread_exit throw something caught by ellipsis</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/23/lambda%E6%8D%95%E8%8E%B7this%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/23/lambda%E6%8D%95%E8%8E%B7this%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">lambda捕获this指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-12-23 23:37:12" itemprop="dateCreated datePublished" datetime="2018-12-23T23:37:12+08:00">2018-12-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近看某qt项目，看到<code>connect</code>使用了lambda表达式，比如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::<span class="title function_ invoke__">initOutput</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_ invoke__">connect</span>(ui<span class="punctuation">-&gt;</span>tableViewOutput, &amp;QWidget::customContextMenuRequested, this, [=](<span class="keyword">const</span> QPoint &amp;pos) &#123;</span><br><span class="line">        m_outputContextMenu.<span class="title function_ invoke__">exec</span>(ui<span class="punctuation">-&gt;</span>tableViewOutput<span class="punctuation">-&gt;</span><span class="title function_ invoke__">mapToGlobal</span>(pos));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名规范是<code>m_</code>开头的是成员变量，可以发现类成员函数中用lambda表达式中直接使用了成员变量。<br>于是我突然有了疑问:</p>
<ol>
<li>成员变量不是局部变量，那是怎么捕获的呢？</li>
<li>如果含有不可拷贝的成员变量，那么<code>=</code>岂不是失效了？</li>
</ol>
<p>为了解决这些疑问，一步步用代码验证，首先测试不可拷贝的成员变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; p.<span class="built_in">get</span>() &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  foo.<span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码运行正确，打印<code>0</code>。而<code>unique_ptr</code>是典型的不可拷贝的类，用<code>=</code>却捕获成功了。<br>怀着疑问，我尝试了下局部变量，把类的定义改成下面这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; cout &lt;&lt; p.<span class="built_in">get</span>() &lt;&lt; endl; &#125;;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>编译出错(嗯，其实在编译前，我的vim插件<code>ale</code>已经提示了错误)</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use <span class="keyword">of</span> deleted <span class="keyword">function</span> &#x27;std::unique_ptr&lt;_Tp, _Dp&gt;::unique<span class="constructor">_ptr(<span class="params">const</span> <span class="params">std</span>::<span class="params">unique_ptr</span>&lt;<span class="params">_Tp</span>, <span class="params">_Dp</span>&gt;&amp;)</span> <span class="literal">[<span class="identifier">with</span> <span class="identifier">_Tp</span> = <span class="identifier">int</span>; <span class="identifier">_Dp</span> = <span class="identifier">std</span>::<span class="identifier">default_delete</span>&lt;<span class="identifier">int</span>&gt;]</span></span><br></pre></td></tr></table></figure>
<p>那么，也就是说，类成员函数中的lambda表达式并不是像捕获局部变量一样”捕获”类成员变量，而是通过某些其他途径得以访问类成员变量。<br>参阅*Effective Modern C++*后面的部分(嗯，我从前往后抽空看的，目前还没看完)，恍然大悟。<br>在<strong>条款31：避免默认捕获模式</strong>中，书上举出了一个类似例子，并给出了说明</p>
<blockquote>
<p>捕获只能针对于在创建lambda式的作用域内可见的非静态局部变量(包括形参)。</p>
</blockquote>
<p>也就是说，在函数体外的类成员变量(这里的<code>p</code>)是无法被捕获的，那么为何可以直接访问<code>p</code>呢？<br>其实是捕获了<code>this</code>指针。</p>
<blockquote>
<p>每一个非静态成员函数都持有一个<code>this</code>指针，然后每当提及该类的成员变量时都会用到这个指针。</p>
</blockquote>
<p>那么这里也解释通了，其实<code>[=]</code>捕获了<code>this</code>指针，然后编译器看到<code>p.get()</code>时，把它翻译成了<code>this-&gt;p.get()</code>。把代码中的<code>[=]</code>改成<code>[this]</code>，仍然成功编译。<br>也就是说，如果<code>this</code>指向的对象已经被析构，捕获<code>this</code>指针的lambda式就可能出现问题，比如下面代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">  <span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> [=] &#123; cout &lt;&lt; *p &lt;&lt; endl; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> foo = <span class="keyword">new</span> <span class="built_in">Foo</span>();</span><br><span class="line">  <span class="keyword">auto</span> f = foo-&gt;<span class="built_in">f</span>();</span><br><span class="line">  <span class="keyword">delete</span> foo;</span><br><span class="line">  <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为0而非1，而且这里输出0是未定义行为，因为访问的实际上是被回收的空间，只是因为编译器的<code>delete</code>并没有对回收的空间做额外的操作，所以<code>p</code>指向的仍然是原来那块，只不过那块已经被<code>unique_ptr</code>的析构函数自动清除了，只不过将清除的部分全部置为0而已。</p>
<p>由于<code>[=]</code>很容易让人忽略掉<code>this</code>也被捕获了，所以很容易让人忽视这个问题，所以不如<code>[this]</code>直观。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/21/%E5%AE%9E%E7%8E%B0thread%E5%BA%93%E7%BB%86%E8%8A%82%EF%BC%9A%E4%BD%BF%E7%94%A8std-decay%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/21/%E5%AE%9E%E7%8E%B0thread%E5%BA%93%E7%BB%86%E8%8A%82%EF%BC%9A%E4%BD%BF%E7%94%A8std-decay%E4%BF%9D%E5%AD%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">实现thread库细节：使用std::decay保存函数指针</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-21 16:45:21" itemprop="dateCreated datePublished" datetime="2018-11-21T16:45:21+08:00">2018-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>最近想包装<code>pthread</code>，像C++11线程库一样，毕竟标准库对于很多东西都没有包装，比如线程属性的设置。虽然可以用<code>thread::native_handle_type()</code>取得底层的<code>pthread_t</code>句柄，当然，本身就没想去麻烦地跨平台。<br>主要目的还是出于学习，以及写个顺手的线程库。<br>参考了知乎上的一篇回答：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/30553807">C++11是如何封装thread库的</a><br>花了不少精力终于理解了整套流程，期间通过《C++ Primer》第16章复习了完美转发、可变模板参数(解包、包扩展)的知识，通过qicosmos前辈的博客<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qicosmos/p/4325949.html">泛化之美–C++11可变模板参数的妙用</a>补充了一些知识。<br>在做了一些简单的测试后，便开始建立一个仓库实现我的想法。<br>但是自己实现过程中也遇到一些细节问题，毕竟回答也不可能太详细，比如这篇提到的<code>decay</code>。</p>
<h2 id="1-decay类型退化"><a href="#1-decay类型退化" class="headerlink" title="1. decay类型退化"></a>1. <code>decay</code>类型退化</h2><p>C++ Primer中提到，在模板类型推导中，一般的类型转换是禁止的，否则无法准确推断是哪种类型。但是两种类型转换是允许的：</p>
<ol>
<li>将非<code>const</code>的引用或指针传递给<code>const</code>的引用或指针形参，比如<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>;  <span class="comment">// 函数模板声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span>&amp; ri = i;</span><br><span class="line"><span class="built_in">f</span>(ri);  <span class="comment">// ri被转换成const int&amp;类型，因此T被推断为int</span></span><br></pre></td></tr></table></figure></li>
<li>若形参不是引用类型，数组实参会被转换成指针形参，函数实参会被转换成函数指针形参，比如<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; void <span class="built_in">f</span>(T param);</span><br><span class="line"></span><br><span class="line">void <span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">f</span>(func);  <span class="comment">// T被推断为void(*)()</span></span><br><span class="line"></span><br><span class="line">int <span class="selector-tag">a</span><span class="selector-attr">[10]</span>;</span><br><span class="line"><span class="built_in">f</span>(a);     <span class="comment">// T被推断为int*</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><code>decay</code>完成的功能即将数组和函数转换成退化后的类型，对于其他类型，则是移除引用以及<code>const</code>和<code>volatile</code>描述符，分别对应上述的2和1。<br>注意，在模板类型推断中，实参的引用类型都会被忽略，就像上述1中的<code>const</code>被忽略一样。<br>比如传入<code>int&amp;</code>到形参<code>T t</code>中，推断方式是：先忽略<code>&amp;</code>，然后匹配<code>int</code>和<code>T</code>，因此T永远不会被推断为引用类型，除非形参是右值引用<code>T&amp;&amp; t</code>，根据引用折叠规则(<code>&amp;&amp; &amp;&amp;</code>折叠为<code>&amp;&amp;</code>，<code>&amp;&amp; &amp;</code>、<code>&amp; &amp;&amp;</code>、<code>&amp; &amp;</code>被折叠为<code>&amp;</code>)，才有可能推断<code>T</code>为引用，这也是C++11实现完美转发的基础。<br>从类型<code>T</code>到退化类型<code>typename std::decay&lt;T&gt;::type</code>的映射示例如下</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> () =&gt; <span class="built_in">int</span> (*)()</span><br><span class="line"><span class="built_in">int</span> (&amp;)() =&gt; <span class="built_in">int</span> (*)()</span><br><span class="line"><span class="built_in">int</span> [<span class="number">10</span>] =&gt; <span class="built_in">int</span>*</span><br><span class="line"><span class="built_in">int</span> (&amp;) [<span class="number">10</span>] =&gt; <span class="built_in">int</span>*</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span> =&gt; <span class="built_in">int</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span>&amp; =&gt; <span class="built_in">int</span></span><br><span class="line"><span class="built_in">int</span> <span class="keyword">const</span>* =&gt; <span class="built_in">int</span> <span class="keyword">const</span>*</span><br><span class="line"><span class="built_in">int</span>* <span class="keyword">const</span> =&gt; <span class="built_in">int</span>*</span><br></pre></td></tr></table></figure>

<h2 id="2-使用可变模板参数构造线程函数的简单原理"><a href="#2-使用可变模板参数构造线程函数的简单原理" class="headerlink" title="2. 使用可变模板参数构造线程函数的简单原理"></a>2. 使用可变模板参数构造线程函数的简单原理</h2><p>C++11线程的构造函数是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span><span class="params">(F&amp;&amp;, Args&amp;&amp;...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而底层线程接口是C风格的，一般需要将参数类型和<code>void*</code>进行转换，比如对于<code>pthread</code>线程函数，一般像这样使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> input = <span class="built_in">static_cast</span>&lt;input_type*&gt;(arg);</span><br><span class="line">  <span class="comment">// do sth... and generate an exit_code</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(exit_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，返回值也可以是动态分配的对象的指针，但这就需要显式<code>pthread_join</code>，处理完返回类型后将该指针指向的资源回收。<br>实现C++11风格的线程函数的思路是：用<code>std::tuple&lt;Args...&gt;</code>(记为<code>TupleType</code>)将整个打包，然后动态申请一个<code>TupleType*</code>指针传入C风格线程函数。<br>由于线程函数是编译时期就决定的，无法像lambda表达式一样捕获外部参数，所以需要用虚函数实现：<br>C风格线程函数中将<code>void*</code>转换成<code>Base*</code>，而继承自<code>Base</code>类的<code>Derived</code>则实现可变模板参数的构造函数，将函数和输入参数打包，然后override基类的虚函数<code>void invoke()</code>，调用打包的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BaseData</span> &#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">BaseData</span>();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">invoke</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DerivedData</span>;  <span class="comment">// 省略具体实现，内部包含一个tuple打包数据，实现了invoke函数调用函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">void</span>* args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> p = <span class="built_in">static_cast</span>&lt;BaseData*&gt;(args);</span><br><span class="line">  p-&gt;<span class="built_in">invoke</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程函数的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createThread</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> data = <span class="keyword">new</span> <span class="built_in">DerivedData</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="type">pthread_t</span> tid;</span><br><span class="line">  <span class="type">int</span> error = <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">nullptr</span>, threadFunc, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(data));</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中有一些细节，比如如何在编译期确定<code>get&lt;i&gt;()</code>的<code>i</code>的范围，需要一点模板元的技巧，在C++17中<code>index_sequence</code>和<code>invoke</code>均已实现，C++11中也可以照着libstdc++源码自行实现。<br>另外为了线程安全，可以使用<code>std::unique_ptr</code>代替<code>new</code>，构造对象时使用<code>unique_ptr</code>，然后调用<code>release()</code>方法传递内部指针，再在线程函数中构造<code>unique_ptr</code>。<br>不过本文重点说的就是怎么打包。</p>
<h2 id="3-打包退化类型的数据"><a href="#3-打包退化类型的数据" class="headerlink" title="3. 打包退化类型的数据"></a>3. 打包退化类型的数据</h2><p>看似打包数据应该使用完美转发，保留参数的<code>cv</code>修饰符以及引用类型，其实并不然，这点在本文链接的知乎回答中没有提及，毕竟是个细节，但是贴出的代码中都会发现，使用了<code>decay</code>。</p>
<h3 id="3-1-result-of的使用"><a href="#3-1-result-of的使用" class="headerlink" title="3.1 result_of的使用"></a>3.1 <code>result_of</code>的使用</h3><p>对于底层C风格接口，返回的<code>void*</code>并不一定是实际你想返回的数据，因为线程函数往往只是完成一个任务，对主线程报告一个状态码。<br>但有时候也需要取得线程的计算结果，比如对一堆数据，分块并行求和，需要取得每个线程计算的结果，然后主线程将其相加。<br>C++11线程设施中，<code>thread</code>本身无法取得线程函数的返回值，需要结合<code>future</code>来完成，当然，在底层需要知道函数的返回类型，这里可以用<code>&lt;type_traits&gt;</code>中的<code>result_of</code>来实现。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="type">int</span>&amp; (*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 函数指针</span></span><br><span class="line"><span class="keyword">using</span> R = std::<span class="built_in">result_of</span>(<span class="built_in">F</span>(<span class="type">int</span>, <span class="type">int</span>))::type;  <span class="comment">// int&amp;</span></span><br></pre></td></tr></table></figure>
<p>但是<code>result_of</code>有个陷阱，比如把上述代码在实际中可能是这个样子</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> F = <span class="keyword">decltype</span>(f);</span><br><span class="line"><span class="keyword">using</span> R = std::result_of&lt;<span class="built_in">F</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;::type;</span><br></pre></td></tr></table></figure>
<p>然后编译就会出错</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error:  </span>type name’ declared as function returning a function</span><br></pre></td></tr></table></figure>
<p>欲分析其原因，首先得对比函数和函数指针的类型表示：</p>
<table>
<thead>
<tr>
<th align="left">表示</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>F (Args...)</code></td>
<td align="left">返回类型为<code>F</code>，输入参数为<code>Args...</code>的函数</td>
</tr>
<tr>
<td align="left"><code>F (*)(Args...)</code></td>
<td align="left">返回类型为<code>F</code>，输入参数为<code>Args...</code>的函数指针</td>
</tr>
<tr>
<td align="left"><code>F (&amp;)(Args...)</code></td>
<td align="left">返回类型为<code>F</code>，输入参数为<code>Args...</code>的函数引用</td>
</tr>
</tbody></table>
<p>注意函数的表示类型不是<code>F()(Args...)</code>，中间的括号不需要，在指针和引用中加上这个括号只是为了区分是返回类型为<code>F</code>的函数指针&#x2F;引用还是返回类型为<code>F*</code>&#x2F;<code>F&amp;</code>的函数。<br>分析前面的代码，<code>F</code>即<code>decltype(f)</code>的类型是<code>int&amp; (int, int)</code>，那么<code>F(int, int)</code>即<code>int&amp; (int, int)(int, int)</code>，返回类型为<code>int&amp; (int, int)</code>，参数为<code>int, int</code>。<br>这里的返回类型是一个返回类型为<code>int&amp;</code>、参数为<code>int, int</code>的函数，而函数本身只有退化为指针才能作为返回值，导致编译出错。</p>
<p>因此如果要将函数<code>f</code>和参数<code>args...</code>打包，如果完美转发<code>f</code>，那么可能保存的类型是函数而非函数指针、引用，导致调用<code>result_of</code>时编译出错。</p>
<h2 id="3-2-能够被退化的类型本身无法进行拷贝"><a href="#3-2-能够被退化的类型本身无法进行拷贝" class="headerlink" title="3.2 能够被退化的类型本身无法进行拷贝"></a>3.2 能够被退化的类型本身无法进行拷贝</h2><p>其实使用<code>decay</code>来打包的根本原因并不是<code>result_of</code>，毕竟，完全可以在<code>invoke()</code>方法的实现中再去把函数类型转换成函数指针。<br>初学C语言时，无论是书籍还是老师都会讲到，数组不能拷贝</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a[<span class="number">2</span>], b[<span class="number">2</span>];</span><br><span class="line">a = b;  <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure>
<p>正因为如此，传入形参时才将其退化成指向数组首地址的指针。而C语言中不存在这么复杂的类型推导以及引用类型，根本无需区分函数和函数指针，所以没有强调函数退化成函数指针这个例子。但是，函数和数组一样，都是无法拷贝的。<br>而引用类型，看似可以拷贝</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i, j;</span><br><span class="line"><span class="built_in">int</span> &amp;ri = i, &amp;rj = j;</span><br><span class="line">ri = rj;  <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<p>实际拷贝的并不是引用本身，而是引用的对象之间进行拷贝。<br>那么，考虑数组进行打包，<code>tuple</code>的模板参数是无法设为不可拷贝的类型的，因此只能存为数组指针。<br>但是问题在于到底存放退化后的<code>int*</code>还是指向数组的指针<code>int (*)[N]</code>呢？参考如下代码</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int</span> a[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="attribute">std</span>::tuple&lt;int*&gt; t1(a);</span><br><span class="line"><span class="attribute">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t1)[<span class="number">2</span>] &lt;&lt; endl;  // <span class="number">2</span></span><br><span class="line"><span class="attribute">std</span>::tuple&lt;int(*)[<span class="number">3</span>]&gt; t2(&amp;a);</span><br><span class="line"><span class="attribute">cout</span> &lt;&lt; get&lt;<span class="number">0</span>&gt;(t2)[<span class="number">2</span>] &lt;&lt; endl;  // 某个地址，比如<span class="number">0</span>x7ffc462e1a98</span><br></pre></td></tr></table></figure>
<p>只有退化类型才能表达出和原来传入实参一样的结果，就像完美转发一样。而另一种所谓的类型退化，即<code>int(*)[N]</code>，实际上已经改变了实参的意义。<br>引用类型<code>int(&amp;)[N]</code>能够和实参一样，但是问题是引用本身无法拷贝。<br>至于丢失的信息，比如数组丢失的长度信息，在函数调用中如果不是传入数组引用，本身就会丢失。既然参数转发前后都丢失了同样的信息，某种程度上也可以称为 <em>完美转发</em> 了。</p>
<h2 id="3-3-打包数据的实现"><a href="#3-3-打包数据的实现" class="headerlink" title="3.3 打包数据的实现"></a>3.3 打包数据的实现</h2><p>类型退化可以看做是直接匹配，是很自然而然的操作，因此仅需把<code>tuple</code>模板参数声明为退化类型即可，传参时还是完美转发，实现如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">decay_t</span> = <span class="keyword">typename</span> std::decay&lt;T&gt;::type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataTuple</span> &#123;</span><br><span class="line">  std::tuple&lt;<span class="type">decay_t</span>&lt;F&gt;, <span class="type">decay_t</span>&lt;Args&gt;...&gt; t_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DataTuple</span>(F&amp;&amp; f, Args&amp;&amp;... args)</span><br><span class="line">      : <span class="built_in">t_</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">DataTuple&lt;F, Args...&gt;* <span class="title">makeDataTuple</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">DataTuple</span>&lt;F, Args...&gt;(std::forward&lt;F&gt;(f),</span><br><span class="line">                                   std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，其实还有个关键问题，那就是，既然引用类型会丢失，那么传入引用类型的话，不就无法转发了吗？C++11线程库也考虑到了这点，因此使用了<code>ref</code>来对引用类型进行包装，这里给出一个机遇我们的<code>DataTuple</code>的示例</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void f(int&amp; x) &#123; x++; &#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int i = <span class="number">0</span>;</span><br><span class="line">  int&amp; ri = i;</span><br><span class="line">  auto p = makeDataTuple(f, std::ref(ri));</span><br><span class="line">  get&lt;<span class="number">0</span>&gt;(p-&gt;t_)(get&lt;<span class="number">1</span>&gt;(p-&gt;t_));</span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;  <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">delete</span> p and <span class="keyword">exit</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果和注释一样，是1，说明引用成功传递了，其实内部实现是一个<code>reference_wrapper&lt;T&gt;</code>，其内部保存一个<code>T*</code>，从而使得<code>ref(ri)</code>具有值语义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/06/gdb%E8%B0%83%E8%AF%95%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/06/gdb%E8%B0%83%E8%AF%95%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">gdb调试类模板成员函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-11-06 15:29:44" itemprop="dateCreated datePublished" datetime="2018-11-06T15:29:44+08:00">2018-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="gdb常用命令简单回顾"><a href="#gdb常用命令简单回顾" class="headerlink" title="gdb常用命令简单回顾"></a>gdb常用命令简单回顾</h2><p>首先列出一些常用的gdb命令<br><code>l</code>即<code>list</code>，从第1行开始查看当前文件，后面可接数字，比如<code>l 10</code>就是查看以第10行为中间行的若干行(比如第5-14行)。<br><code>b</code>即<code>break</code>，后接数字n，则代表在第n行设置断点。另外后接<code>if &lt;condition&gt;</code>可以设条件断点。<br><code>i</code>即<code>info</code>，后接<code>b</code>可以查看所有的断点信息(包括断点编号)。<br><code>d</code>即<code>delete</code>，后接断点编号，可以删除特定断点。<br><code>r</code>即<code>run</code>，运行程序。如果需要添加命令行参数，则后接命令行参数即可，也可以后接<code>&lt; file</code>这种将文件file的内容重定向到标准输入。<br><code>n</code>即<code>next</code>，运行1步。<br><code>s</code>即<code>step</code>，进入这一行的函数中。</p>
<h2 id="step的局限性"><a href="#step的局限性" class="headerlink" title="step的局限性"></a>step的局限性</h2><p>上面几个命令算是调试的通用命令，比较值得注意的是最后一个<code>step</code>操作，因为有可能一行会调用多个函数，比如下一行代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在这一行设断点，运行至此处，然后输入<code>s</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">1</span>, <span class="built_in">main</span> () at gdb.cc:<span class="number">8</span></span><br><span class="line"><span class="number">8</span>     vector&lt;string&gt; v = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">(gdb) s</span><br><span class="line">std::allocator&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt; &gt;::<span class="built_in">allocator</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe22f</span>) at /usr/include/c++/<span class="number">5</span>/bits/allocator.h:<span class="number">113</span></span><br><span class="line"><span class="number">113</span>       <span class="built_in">allocator</span>() <span class="keyword">throw</span>() &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>简单看，这一句涉及到下面几个操作：</p>
<ol>
<li>构造<code>std::initialize_list&lt;string&gt;</code>对象，包含2个字符串<code>&quot;hello&quot;</code>和<code>&quot;world&quot;</code>；</li>
<li>调用<code>vector&lt;string&gt;</code>的构造函数，接收初始化列表；</li>
</ol>
<p>但实际并不然，<code>string</code>对象会调用接收字符串字面值的构造函数，range for语法会调用到底层的<code>begin()</code>、<code>size()</code>、<code>end()</code>等方法，以及<code>distance()</code>函数之类，如果继续<code>s</code>下去，会看到大量无用信息。<br>因此需要在合适的时机用<code>n</code>跳到下一句，此时可以用<code>l</code>查看当前跳转到哪个文件了。比如我继续<code>step</code>两次跳转到了<code>vector</code>的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">std::vector&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;, std::allocator&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt; &gt; &gt;::<span class="built_in">vector</span> (<span class="keyword">this</span>=<span class="number">0x7fffffffe230</span>, __l=..., __a=...) at /usr/include/c++/<span class="number">5</span>/bits/stl_vector.h:<span class="number">373</span></span><br><span class="line"><span class="number">373</span>       <span class="built_in">vector</span>(initializer_list&lt;value_type&gt; __l,</span><br></pre></td></tr></table></figure>
<p>但这是盲目的，因为我不清楚要跳转几次，如果提前<code>next</code>进入下一步了，可能就把后面整个过程就跳出去了。<br>因此如果想调试<code>vector</code>的构造函数而不去管其他的杂七杂八的函数，需要精确跳转到特定函数中。</p>
<h2 id="gdb函数或文件设断点"><a href="#gdb函数或文件设断点" class="headerlink" title="gdb函数或文件设断点"></a>gdb函数或文件设断点</h2><p>gdb可以给文件设断点，比如我的程序是<code>Blob.cc</code>编译的，包含了自定义的头文件<code>Blob.h</code>。<br>用<code>b &lt;file&gt;:&lt;number&gt;</code>即可设断点，如下所示</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">b </span><span class="keyword">Blob.h:25</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Breakpoint </span><span class="number">1</span> <span class="built_in">at</span> <span class="number">0x401da0</span>: file <span class="keyword">Blob.h, </span>line <span class="number">25</span>.</span><br></pre></td></tr></table></figure>
<p>但问题是，怎么在gdb中查看<code>Blob.h</code>的内容以知道该在哪设断点？gdb不提供查看文件的命令，但是可以查看函数和类。<br>但对于类模板和函数模板而言，由于它们都是在编译时进行实例化的，所以需要提供模板参数。<br>且对于类成员函数而言，需要用<code>::</code>来指定对应成员函数。调试流程如下所示</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l BlobPtr&lt;<span class="type">int</span>&gt;</span><br><span class="line"><span class="number">35</span>    <span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="type">const</span> std::string&amp; msg)</span></span>;</span><br><span class="line"><span class="number">36</span>  &#125;;</span><br><span class="line"><span class="number">37</span></span><br><span class="line"><span class="number">38</span>  <span class="comment">// 若试图访问一个不存在的元素，BlobPtr抛出一个异常</span></span><br><span class="line"><span class="number">39</span>  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="number">40</span>  <span class="keyword">class</span> <span class="title class_">BlobPtr</span> &#123;</span><br><span class="line">    <span class="number">41</span>   <span class="keyword">public</span>:</span><br><span class="line"><span class="number">42</span>    <span class="built_in">BlobPtr</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="number">43</span>    <span class="built_in">BlobPtr</span>(Blob&lt;T&gt;&amp; a, <span class="type">size_t</span> sz = <span class="number">0</span>) : <span class="built_in">wptr</span>(a.data), <span class="built_in">curr</span>(sz) &#123;&#125;</span><br><span class="line"><span class="number">44</span></span><br><span class="line">(gdb) l BlobPtr&lt;<span class="type">int</span>&gt;::<span class="keyword">operator</span>++</span><br><span class="line">file: <span class="string">&quot;Blob.h&quot;</span>, line number: <span class="number">137</span></span><br><span class="line">file: <span class="string">&quot;Blob.h&quot;</span>, line number: <span class="number">151</span></span><br><span class="line">(gdb) l BlobPtr&lt;<span class="type">int</span>&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line"><span class="number">146</span>   <span class="built_in">check</span>(curr, <span class="string">&quot;operator-- past begin of BlobPtr&quot;</span>);</span><br><span class="line"><span class="number">147</span>   <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="number">148</span> &#125;</span><br><span class="line"><span class="number">149</span></span><br><span class="line"><span class="number">150</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="number">151</span> BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="number">152</span>   <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line"><span class="number">153</span>   ++*<span class="keyword">this</span>;</span><br><span class="line"><span class="number">154</span>   <span class="keyword">return</span> ret;</span><br><span class="line"><span class="number">155</span> &#125;</span><br></pre></td></tr></table></figure>
<p>C++支持重载，因此查看自增运算符时会提示两个地方，如果这两个地方在一起，则会一起显示。可以通过指定函数参数列表来查看特定的函数。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="keyword">b </span><span class="keyword">BlobPtr&lt;int&gt;::operator++</span></span><br><span class="line"><span class="keyword"></span><span class="keyword">Breakpoint </span><span class="number">1</span> <span class="built_in">at</span> <span class="number">0x402099</span>: <span class="keyword">BlobPtr&lt;int&gt;::operator++. </span>(<span class="number">2</span> locations)</span><br><span class="line">(gdb) i <span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>Num     Type           <span class="keyword">Disp </span>Enb <span class="keyword">Address </span>           What</span><br><span class="line"><span class="number">1</span>       <span class="keyword">breakpoint </span>    keep y   &lt;<span class="keyword">MULTIPLE&gt;</span></span><br><span class="line"><span class="keyword"></span><span class="number">1</span>.<span class="number">1</span>                         y     <span class="number">0x0000000000402099</span> in <span class="keyword">BlobPtr&lt;int&gt;::operator++() </span><span class="built_in">at</span> <span class="keyword">Blob.h:137</span></span><br><span class="line"><span class="keyword"></span><span class="number">1</span>.<span class="number">2</span>                         y     <span class="number">0x000000000040217e</span> in <span class="keyword">BlobPtr&lt;int&gt;::operator++(int) </span><span class="built_in">at</span> <span class="keyword">Blob.h:151</span></span><br><span class="line"><span class="keyword"></span>(gdb) <span class="keyword">b </span><span class="keyword">BlobPtr&lt;int&gt;::operator++(int)</span></span><br><span class="line"><span class="keyword"></span><span class="symbol">Note:</span> <span class="keyword">breakpoint </span><span class="number">1</span> also set <span class="built_in">at</span> pc <span class="number">0x40217e</span>.</span><br><span class="line"><span class="keyword">Breakpoint </span><span class="number">2</span> <span class="built_in">at</span> <span class="number">0x40217e</span>: file <span class="keyword">Blob.h, </span>line <span class="number">151</span>.</span><br><span class="line">(gdb) i <span class="keyword">b</span></span><br><span class="line"><span class="keyword"></span>Num     Type           <span class="keyword">Disp </span>Enb <span class="keyword">Address </span>           What</span><br><span class="line"><span class="number">1</span>       <span class="keyword">breakpoint </span>    keep y   &lt;<span class="keyword">MULTIPLE&gt;</span></span><br><span class="line"><span class="keyword"></span><span class="number">1</span>.<span class="number">1</span>                         y     <span class="number">0x0000000000402099</span> in <span class="keyword">BlobPtr&lt;int&gt;::operator++() </span><span class="built_in">at</span> <span class="keyword">Blob.h:137</span></span><br><span class="line"><span class="keyword"></span><span class="number">1</span>.<span class="number">2</span>                         y     <span class="number">0x000000000040217e</span> in <span class="keyword">BlobPtr&lt;int&gt;::operator++(int) </span><span class="built_in">at</span> <span class="keyword">Blob.h:151</span></span><br><span class="line"><span class="keyword"></span><span class="number">2</span>       <span class="keyword">breakpoint </span>    keep y   <span class="number">0x000000000040217e</span> in <span class="keyword">BlobPtr&lt;int&gt;::operator++(int) </span><span class="built_in">at</span> <span class="keyword">Blob.h:151</span></span><br></pre></td></tr></table></figure>
<p>可以在函数设断点，可以看到，断点编号是1.1和1.2，因为有2处重载，因此也可以通过明确参数列表来为特定的重载设置断点。</p>
<p>总结：通过<code>list</code>查看特定函数或类后，就可以针对特定函数设置断点，也可以针对该函数所在文件的某一行设置断点，这样就不用盲目地step了，而是精确地跳转到指定函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/C%E6%A0%87%E5%87%86I-O%E5%BA%93%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%86%B2%E5%8C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/25/C%E6%A0%87%E5%87%86I-O%E5%BA%93%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%86%B2%E5%8C%BA/" class="post-title-link" itemprop="url">C标准I/O库自定义缓冲区</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-25 04:39:00" itemprop="dateCreated datePublished" datetime="2018-10-25T04:39:00+08:00">2018-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-标准I-x2F-O库的缓冲机制"><a href="#1-标准I-x2F-O库的缓冲机制" class="headerlink" title="1. 标准I&#x2F;O库的缓冲机制"></a>1. 标准I&#x2F;O库的缓冲机制</h1><p>Linux上C标准I&#x2F;O库封装了底层的<code>write()</code>、<code>read()</code>等系统调用，以减少系统调用次数。<br>比如现在需要打印10000次”hello world”，如果直接用系统调用</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    <span class="attribute">write</span>(STDOUT_FILENO, <span class="string">&quot;hello world&quot;</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>
<p>那么系统调用<code>write()</code>会执行10000次。<br>如果用C标准库的<code>printf()</code>或<code>fputs()</code>之类，比如</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">    <span class="attribute">fputs</span>(<span class="string">&quot;hello world&quot;</span>, stdout);</span><br></pre></td></tr></table></figure>
<p>在我的系统(Ubuntu 16.04)上<code>write()</code>只会执行108次，查看<code>write()</code>调用次数可以借助<code>strace</code>工具，比如我是用</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">strace ./a.<span class="keyword">out</span> 2&gt;<span class="keyword">err</span></span><br><span class="line">grep <span class="string">&quot;write(&quot;</span> <span class="keyword">err</span> | wc -<span class="keyword">l</span></span><br></pre></td></tr></table></figure>
<p>查看的，如果想实际看看缓冲区大小，可以直接打开err文件，可以看到下列输出</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;hello worldhello worldhello worl&quot;</span>..., <span class="number">1024</span>)</span></span> = <span class="number">1024</span></span><br><span class="line">...(省略若干行)</span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;orldhello worldhello worldhello &quot;</span>..., <span class="number">1024</span>)</span></span> = <span class="number">1024</span></span><br><span class="line"><span class="function"><span class="title">write</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;rldhello worldhello worldhello w&quot;</span>..., <span class="number">432</span>)</span></span> = <span class="number">432</span></span><br></pre></td></tr></table></figure>
<p>每次执行C标准库的打印函数时，并未立刻调用<code>write()</code>将字符串打印到屏幕上(严谨点说，<code>write()</code>也只不过是将内容递交给内核缓冲区)，而是等到填满缓冲区后再调用<code>write()</code>。<br>通过这样的缓冲机制，可以减少系统调用的次数，普通函数调用不涉及到用户态和内核态的切换，因此开销远低于系统调用。<br>缓冲区大小没有严格定义，即使在同一系统上，打印到不同文件中的缓冲区大小也不一样。比如将输出重定向到普通文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># </span><span class="language-bash">strace ./a.out &gt;out 2&gt;err</span></span><br><span class="line"><span class="meta"># </span><span class="language-bash">grep <span class="string">&quot;write(&quot;</span> err | <span class="built_in">wc</span> -l</span></span><br><span class="line">27</span><br></pre></td></tr></table></figure>
<p>查看err文件可以看到缓冲区大小变成了4096。<br>再就是最后一次<code>write()</code>，可以发现即使未等到填满缓冲区，仍然打印出来了，原因是程序正常终止（调用<code>exit()</code>）时会关闭所有文件流，从而导致缓冲区被刷新，效果等价于调用<code>fflush()</code>。<br>比如在每次<code>fputs()</code>之后加上<code>fflush(stdout);</code>，可以发现<code>write()</code>调用执行了10000次。<br>或者在for循环之后，加上<code>write(STDOUT_FILEFNO, &quot;exit(0)&quot;, 7)</code>，可以发现err文件中最后两次<code>write()</code>为</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;exit(0)&quot;</span>, <span class="number">7</span>)                  = <span class="number">7</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;rldhello worldhello worldhello w&quot;</span>..., <span class="number">432</span>) = <span class="number">432</span></span><br></pre></td></tr></table></figure>
<p>上述缓冲方式为全缓冲，即等缓冲区填满才调用底层I&#x2F;O函数。而常见的标准输入流和标准输出流都是采用行缓冲，即遇到换行符才调用底层I&#x2F;O函数。<br>比如调用<code>fgets()</code>函数时，等键盘敲入回车键时函数才会返回，如果是直接用<code>read()</code>系统调用，则是等待固定字符数量被键盘敲入才返回。<br>又比如调用<code>printf(&quot;hello\n&quot;);</code>时，由于末尾有换行符，因此会调用<code>write()</code>将其打印到屏幕上而不是等输出缓冲区填满。<br>另外，标准错误流是全缓冲的。</p>
<h1 id="2-使用自定义缓冲区"><a href="#2-使用自定义缓冲区" class="headerlink" title="2. 使用自定义缓冲区"></a>2. 使用自定义缓冲区</h1><p>正是因为标准库没有严格定义缓冲区的设计，因此才催生了用户自定义缓冲区的需求。<br>通过<code>man setbuf</code>可以看到手册对下列函数的说明</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setlinebuf</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中<code>setbuffer()</code>和<code>setlinebuf()</code>需要定义<code>_BSD_SOURCE</code>宏。</p>
<ul>
<li><code>stream</code>: 缓冲区对应的文件流</li>
<li><code>buf</code>: 自定义缓冲区，若为<code>NULL</code>则使用系统自带缓冲区；</li>
<li><code>mode</code>: 缓冲方式，下列三个宏之一</li>
</ul>
<table>
<thead>
<tr>
<th align="left">mode宏</th>
<th align="left">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>_IONBF</code></td>
<td align="left">无缓冲，此时buf和size失去了意义</td>
</tr>
<tr>
<td align="left"><code>_IOLBF</code></td>
<td align="left">行缓冲</td>
</tr>
<tr>
<td align="left"><code>_IOFBF</code></td>
<td align="left">全缓冲</td>
</tr>
</tbody></table>
<ul>
<li><code>size</code>: 缓冲区大小至少有size字节</li>
</ul>
<p>本质上前3个库函数都是调用<code>setvbuf()</code>函数，对应关系如下</p>
<table>
<thead>
<tr>
<th align="left">原始调用</th>
<th align="left">等价调用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>setbuf(stream, buf)</code></td>
<td align="left"><code>setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ)</code></td>
</tr>
<tr>
<td align="left"><code>setbuffer(stream, buf, size)</code></td>
<td align="left"><code>setvbuf(stream, buf, buf ? _IOFBF : _IONBF, size)</code></td>
</tr>
<tr>
<td align="left"><code>setlinebuf(stream)</code></td>
<td align="left"><code>setvbuf(stream, NULL, _IOLBF, 0)</code></td>
</tr>
</tbody></table>
<p>可见<code>setbuf</code>和<code>setbuffer</code>是用的自定义缓冲区，区别只是前者使用标准库的宏<code>BUFSIZ</code>作为缓冲区大小，后者使用<code>size</code>参数。<br><code>setlinebuf</code>则仍然使用标准库的缓冲区，只不过缓冲机制改成行缓冲。</p>
<h1 id="3-自定义缓冲区的陷阱"><a href="#3-自定义缓冲区的陷阱" class="headerlink" title="3. 自定义缓冲区的陷阱"></a>3. 自定义缓冲区的陷阱</h1><p>一般情况下没必要自定义缓冲区，除非能证明在当前场景下你的自定义缓冲区有性能优势，以及这个性能提升能解决系统的效率瓶颈。毕竟自定义缓冲区会遇到一些问题，这也是这章要讲的。</p>
<h2 id="3-1-缓冲区的生存周期"><a href="#3-1-缓冲区的生存周期" class="headerlink" title="3.1 缓冲区的生存周期"></a>3.1 缓冲区的生存周期</h2><p>首先是手册上给出的示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="built_in">setbuf</span>(stdin, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>stream</code>关闭之前，<code>buf</code>必须存在，否则在关闭时会出问题。在第1章也提过，进程终止时会导致缓冲区被刷新。而<code>main()</code>结束在这些额外操作之前，此时栈上的<code>buf</code>空间会被回收。<br>正确的方式是将缓冲区定义为全局或静态变量，或者采用<code>malloc()</code>动态申请内存作为缓冲区，并保证在<code>stream</code>被关闭之后才<code>free()</code>释放缓冲区占用内存。<br>PS: 虽然在我的系统上实际执行这段代码运行正常，设置在非main函数中定义局部缓冲区仍然运行正常，但这实质上是不合法的。</p>
<h2 id="3-2-缓冲区溢出"><a href="#3-2-缓冲区溢出" class="headerlink" title="3.2 缓冲区溢出"></a>3.2 缓冲区溢出</h2><p>它指定的是缓冲区的最小大小，然而即使你设定的<code>size</code>比你的<code>buf</code>数组大小要大，该函数调用也不会出错，这样就造成了缓冲区溢出的问题。<br>给出下列代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_buf[<span class="number">4</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模拟缓冲区溢出，全缓冲模式</span></span><br><span class="line">    <span class="built_in">setvbuf</span>(stdout, g_buf, _IOFBF, <span class="built_in">sizeof</span>(g_buf) + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (; g_i &lt; <span class="number">5</span>; g_i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_i + <span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>./a.<span class="keyword">out</span></span><br><span class="line"><span class="number">10000</span></span><br><span class="line"><span class="number">10011</span></span><br></pre></td></tr></table></figure>
<p>来解释下原因，这里我设置的<code>size</code>为8，也就是说，标准库把<code>g_buf</code>开始的8个字节都当做缓冲区，由于<code>g_buf</code>本身只有4个字节，因此会把后面4个字节，也就是<code>g_i</code>所占的内存作为缓冲区。<br>使用gdb调试</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint <span class="number">1</span>, main () at stdout.c:<span class="number">12</span></span><br><span class="line"><span class="number">12</span>          <span class="keyword">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_i + <span class="number">10000</span>);</span><br><span class="line">(gdb) p g_buf</span><br><span class="line">$1 = <span class="string">&quot;\000\000\000&quot;</span></span><br><span class="line">(gdb) <span class="keyword">x</span>/<span class="number">8</span>bx &amp;g_buf[<span class="number">0</span>]</span><br><span class="line"><span class="number">0x60104c</span> &lt;g_buf&gt;:   <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"><span class="number">10000</span></span><br><span class="line">Breakpoint <span class="number">1</span>, main () at stdout.c:<span class="number">12</span></span><br><span class="line"><span class="number">12</span>          <span class="keyword">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_i + <span class="number">10000</span>);</span><br><span class="line">(gdb) p g_buf</span><br><span class="line">$2 = <span class="string">&quot;\n\000\000&quot;</span></span><br><span class="line">(gdb) <span class="keyword">x</span>/<span class="number">8</span>xb &amp;g_buf[<span class="number">0</span>]</span><br><span class="line"><span class="number">0x60104c</span> &lt;g_buf&gt;:   <span class="number">0x0a</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x01</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line">(gdb) n</span><br><span class="line"><span class="number">11</span>      <span class="keyword">for</span> (; g_i &lt; <span class="number">5</span>; g_i++)</span><br><span class="line">(gdb) <span class="keyword">x</span>/<span class="number">8</span>cb &amp;g_buf[<span class="number">0</span>]</span><br><span class="line"><span class="number">0x60104c</span> &lt;g_buf&gt;:   <span class="number">10</span> <span class="string">&#x27;\n&#x27;</span> <span class="number">49</span> <span class="string">&#x27;1&#x27;</span>  <span class="number">48</span> <span class="string">&#x27;0&#x27;</span>  <span class="number">48</span> <span class="string">&#x27;0&#x27;</span>  <span class="number">48</span> <span class="string">&#x27;0&#x27;</span>  <span class="number">49</span> <span class="string">&#x27;1&#x27;</span>  <span class="number">10</span> <span class="string">&#x27;\n&#x27;</span> <span class="number">0</span> <span class="string">&#x27;\000&#x27;</span></span><br><span class="line">(gdb) <span class="keyword">x</span>/<span class="number">8</span>xb &amp;g_buf[<span class="number">0</span>]</span><br><span class="line"><span class="number">0x60104c</span> &lt;g_buf&gt;:   <span class="number">0x0a</span>    <span class="number">0x31</span>    <span class="number">0x30</span>    <span class="number">0x30</span>    <span class="number">0x30</span>    <span class="number">0x31</span>    <span class="number">0x0a</span>    <span class="number">0x00</span></span><br><span class="line">(gdb) p/<span class="keyword">x</span> g_i</span><br><span class="line">$1<span class="number">0</span> = <span class="number">0xa3130</span></span><br></pre></td></tr></table></figure>
<p>执行完第1次循环后，<code>g_i</code>的值为1，由于系统是小端的，所以低位的0x01放在低地址，也就是<code>g_buf[4]</code>的位置上。<br>执行完第2次循环后，缓冲区后4个字节变成了<code>0x30 0x31 0x0a 0x00</code>，因此<code>g_i</code>的值变成了0x000a3130，<code>g_i &lt; 5</code>不再成立，跳出了循环。</p>
<h1 id="4-再谈全缓冲方式"><a href="#4-再谈全缓冲方式" class="headerlink" title="4. 再谈全缓冲方式"></a>4. 再谈全缓冲方式</h1><p>本来在写博客的时候到上一节就戛然而止了，但是突然发现一个问题。<br>注意到3.2中第2次跳出循环时，缓冲区中的内容：”\n10001\n”，第1次<code>write()</code>的只有5个字节”10000”，而缓冲区大小是8。<br>也就是说，全缓冲并未按照我在第1节中我说明的那样去运作，即等到缓冲区满了才刷新。<br>用<code>strace</code>查看<code>write()</code>的调用情况验证了我的观点</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10000&quot;</span>, <span class="number">5</span>)                    = <span class="number">5</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n10011\n&quot;</span>, <span class="number">7</span>)                = <span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>更改代码重新运行，看看打印10000到10005是怎样？</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">for</span> (g_i = <span class="number">10000</span>; g_i &lt; <span class="number">10005</span>; g_i++)</span><br><span class="line">    <span class="attribute">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_i);</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10000&quot;</span>, <span class="number">5</span>)                    = <span class="number">5</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n10001\n1&quot;</span>, <span class="number">8</span>)               = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;0002&quot;</span>, <span class="number">4</span>)                     = <span class="number">4</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n10003\n1&quot;</span>, <span class="number">8</span>)               = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;0004&quot;</span>, <span class="number">4</span>)                     = <span class="number">4</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)                       = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这次可以看到填满缓冲区再打印的情况，但只是中间2次。由于<code>printf</code>是格式化输出，在把int转换成字符串时会计算长度，会不会是这个原因呢？<br>修改代码如下</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;10001\n&quot;</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;10002\n&quot;</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;10003\n&quot;</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;10004\n&quot;</span>);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;10005\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10001&quot;</span>, <span class="number">5</span>)                    = <span class="number">5</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n10002\n1&quot;</span>, <span class="number">8</span>)               = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;0003&quot;</span>, <span class="number">4</span>)                     = <span class="number">4</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n10004\n1&quot;</span>, <span class="number">8</span>)               = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;0005&quot;</span>, <span class="number">4</span>)                     = <span class="number">4</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)                       = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>和预想的不一样，那么直接改成<code>fputs(&quot;10001\n&quot;, stdout)</code>呢？</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10001\n&quot;</span>, <span class="number">6</span>)                  = <span class="number">6</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10002\n10&quot;</span>, <span class="number">8</span>)                = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;003\n&quot;</span>, <span class="number">4</span>)                    = <span class="number">4</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;10004\n10&quot;</span>, <span class="number">8</span>)                = <span class="number">8</span></span><br><span class="line"><span class="attribute">write</span>(<span class="number">1</span>, <span class="string">&quot;005\n&quot;</span>, <span class="number">4</span>)                    = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>说明全缓冲模式下<code>printf(&quot;%s&quot;, s)</code>和<code>fputs(s, stdout)</code>并不是完全等价的。<br>看来只有去看源码了，查看glibc版本</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ldd a.out | grep libc</span></span><br><span class="line">    <span class="attribute">libc</span>.so.<span class="number">6</span> =&gt; /lib/x86_64-linux-gnu/libc.so.<span class="number">6</span> (<span class="number">0</span>x00007f49ed348000)</span><br><span class="line"><span class="comment"># /lib/x86_64-linux-gnu/libc.so.6</span></span><br><span class="line"><span class="attribute">GNU</span> C Library (Ubuntu GLIBC <span class="number">2</span>.<span class="number">23</span>-<span class="number">0</span>ubuntu9) stable release version <span class="number">2</span>.<span class="number">23</span>, by Roland McGrath et al.</span><br></pre></td></tr></table></figure>
<p>去<a target="_blank" rel="noopener" href="https://www.gnu.org/software/libc/">glibc官网</a>下载2.23版本的源码。<br>具体地源码阅读就不在本篇讲述，没有习惯glibc的一些宏，读起来还是很吃力的<br>这里简单讲一点，找到<code>libio/vsnprintf.c</code></p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_vsnprintf</span> (char *string, <span class="variable">_IO_size_t</span> maxlen, const char *<span class="built_in">format</span>,</span><br><span class="line">	       <span class="variable">_IO_va_list</span> args)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 该结构体包含2个字段</span></span><br><span class="line">  <span class="comment">// _IO_strfile f;  // 文件相关结构，暂不深入</span></span><br><span class="line">  <span class="comment">// /* This is used for the characters which do not fit in the buffer</span></span><br><span class="line">  <span class="comment">//    provided by the user.  */</span></span><br><span class="line">  <span class="comment">// 重点在这，定义了额外的缓冲区来保存用户缓冲区可能无法保存的字符</span></span><br><span class="line">  <span class="comment">// 比如snprintf(buf, 2, &quot;%d&quot;, 10000);</span></span><br><span class="line">  <span class="comment">// 用户缓冲区buf光2个字节无法保存&quot;10000&quot;这5个字符，多余的就存在overflow_buf中</span></span><br><span class="line">  <span class="comment">// char overflow_buf[64];</span></span><br><span class="line">  <span class="variable">_IO_strnfile</span> sf;</span><br><span class="line">  int ret;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  sf.f.<span class="variable">_sbf</span>.<span class="variable">_f</span>.<span class="variable">_lock</span> = NULL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We need to handle the special case where MAXLEN is 0.  Use the</span></span><br><span class="line"><span class="comment">     overflow buffer right from the start.  */</span></span><br><span class="line">  <span class="comment">// 通过snprintf(NULL, 0, format, ...)取得格式化后字符串实际大小就是在</span></span><br><span class="line">  <span class="comment">// 这里实现的。利用了overflow缓冲区，并重置maxlen为其大小(64)。</span></span><br><span class="line">  <span class="comment">// 因此string参数此时没有意义，可以随便设置，并不一定需要为NULL。</span></span><br><span class="line">  <span class="keyword">if</span> (maxlen == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      string = sf.overflow_buf;</span><br><span class="line">      maxlen = <span class="built_in">sizeof</span> (sf.overflow_buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_no_init</span> (&amp;sf.f.<span class="variable">_sbf</span>.<span class="variable">_f</span>, <span class="variable">_IO_USER_LOCK</span>, -<span class="number">1</span>, NULL, NULL);</span><br><span class="line">  <span class="variable">_IO_JUMPS</span> (&amp;sf.f.<span class="variable">_sbf</span>) = &amp;<span class="variable">_IO_strn_jumps</span>;</span><br><span class="line">  string[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  <span class="variable">_IO_str_init_static_internal</span> (&amp;sf.f, string, maxlen - <span class="number">1</span>, string);</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> _IO_vfprintf实质上是vfprintf，参考stdio-common/vfprintf.c</span></span><br><span class="line">  <span class="comment">// 具体实现有400多行，比较麻烦</span></span><br><span class="line">  ret = <span class="variable">_IO_vfprintf</span> (&amp;sf.f.<span class="variable">_sbf</span>.<span class="variable">_f</span>, <span class="built_in">format</span>, args);</span><br><span class="line">  <span class="keyword">if</span> (sf.f.<span class="variable">_sbf</span>.<span class="variable">_f</span>.<span class="variable">_IO_buf_base</span> != sf.overflow_buf)</span><br><span class="line">    *sf.f.<span class="variable">_sbf</span>.<span class="variable">_f</span>.<span class="variable">_IO_write_ptr</span> = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后有空再详细看下怎么实现的，留下的问题：<br>C格式化主要解析的就是字符串和整型，<code>overflow_buf</code>只有64个字节，对于整型是足够了，<br>但是对于较长的字符串是如何保存的呢？<br>或者说并不是用于保存多出字符的，而是为了计算理论长度的临时缓冲区？<br>比如对如下的格式化字符串和格式化参数</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const char* format <span class="operator">=</span> <span class="string">&quot;%s %d&quot;</span><span class="comment">;</span></span><br><span class="line">const char* s <span class="operator">=</span> <span class="string">&quot;hello&quot;</span><span class="comment">;</span></span><br><span class="line">int i <span class="operator">=</span> <span class="number">100</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>s就直接<code>strlen()</code>计算长度，i则<code>strtol()</code>到<code>overflow_buf</code>中再计算长度，最后求和？<br>再就是问题的关键，全缓冲模式下，假设已经判断出多出字符的数量，如何保存中断位置呢？<br>我也有个大概思路，如果是在字符串的位置中断，则尽可能用s填充缓冲区剩余部分，然后移动s指针。<br>如果是在整数中断，则<code>overflow_buf</code>记录整数转换成的字符串，然后用<code>&quot;%s&quot;</code>替换format的<code>&quot;%d&quot;</code>。<br>总之还没有非常明确的思路，以后有空自己写个<code>Buffer</code>类。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/15/hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/10/15/hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/" class="post-title-link" itemprop="url">hexo多终端同步</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-10-15 20:07:19" itemprop="dateCreated datePublished" datetime="2018-10-15T20:07:19+08:00">2018-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo的安装还是很简单的，操作也很傻瓜式。常用的基本就下面几个命令</p>
<ol>
<li><code>hexo s</code><br>s即server，默认在<code>localhost:4000</code>启动服务器，在浏览器中即可看到效果，可以通过<code>-p</code>选项指定端口。</li>
<li><code>hexo d</code><br>d即deploy(部署)，上传到服务器。一般会加上<code>-g</code>选项在本地生成静态文件。如果不上传服务器，可以直接<code>hexo g</code>生成静态文件。</li>
<li><code>hexo clean</code><br>删除本地md文件后如果不clean后重新生成，首页可能不会更新。</li>
<li><code>hexo new</code><br>新建博客，后接博客名，比如<code>hexo new &quot;test&quot;</code>，此时hexo框架就会自动生成md文件。自动新建的md文件会生成一些模板信息，因此最好使用命令新建博客。生成之后，用vim等本地编辑器修改即可。<br>另外在<code>_config.yml</code>设置<code>post_asset_folder</code>为true，则<code>hexo new</code>会新建md文件的同名目录用来存放图片，并且作为图片的默认路径，也就是说如果待插入图片放在该目录下，路径直接写文件名即可。</li>
</ol>
<p>至于其他命令可以参考<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/commands.html">hexo中文文档</a>，<code>_config.yml</code>的配置也有较为详细地注释。</p>
<h2 id="新建分支保存源码"><a href="#新建分支保存源码" class="headerlink" title="新建分支保存源码"></a>新建分支保存源码</h2><p>hexo是将Markdown文本和图片生成静态网页上传至github的。<br><img src="/2018/10/15/hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/master%E5%88%86%E6%94%AF%E7%9B%AE%E5%BD%95.jpg" alt="master分支目录"></p>
<p>上图所示目录即<code>hexo d -g</code>或<code>hexo g</code>在本地生成的静态文件，为<code>public</code>子目录。<code>hexo d</code>即上传该目录到仓库master分支。<br>而博客目录是保存在<code>source/_posts</code>目录下的，因此需要在git仓库中新建一个分支保存博客源文件。创建过程如下</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git <span class="keyword">add </span>source themes _<span class="built_in">config</span>.yml package.<span class="keyword">json</span></span><br><span class="line"><span class="keyword"></span>git commit -m <span class="string">&quot;blog source&quot;</span></span><br><span class="line">git <span class="keyword">branch </span>hexo</span><br><span class="line">git checkout hexo</span><br><span class="line">git remote <span class="keyword">add </span><span class="keyword">origin </span>git@github.com:<span class="keyword">BewareMyPower/BewareMyPower.github.io.git</span></span><br><span class="line"><span class="keyword"></span>git push <span class="keyword">origin </span>hexo</span><br></pre></td></tr></table></figure>
<p>普通的git命令，初始化、添加、提交、创建分支、切换分支、添加远程仓库、推送分支到该仓库。完成后远程仓库hexo分支如下图所示。<br><img src="/2018/10/15/hexo%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%90%8C%E6%AD%A5/hexo%E5%88%86%E6%94%AF%E7%9B%AE%E5%BD%95.jpg" alt="hexo分支目录"></p>
<h2 id="新环境下部署博客并添加新博客"><a href="#新环境下部署博客并添加新博客" class="headerlink" title="新环境下部署博客并添加新博客"></a>新环境下部署博客并添加新博客</h2><p>首先克隆源码分支。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -<span class="selector-tag">b</span> hexo git@github<span class="selector-class">.com</span>:BewareMyPower/BewareMyPower<span class="selector-class">.github</span><span class="selector-class">.io</span>.git</span><br></pre></td></tr></table></figure>
<p>由于hexo分支仅仅是源码，缺少了将源码转换成网页的nodejs模块(即hexo)，所以需要安装hexo在该目录。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd BewareMyPower.github.io/</span><br><span class="line">npm <span class="keyword">install</span> hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>然后会发现目录下多了个<code>node_modules</code>目录，即保存nodejs相关模块。<br>注意后面一个<code>npm install</code>不可少！否则会缺少某些模块，比如缺少hexo-asset-image模块导致图片无法显示。<br>此外无论是生成静态文件还是启动服务器，源码目录不受影响，因此可以放心大胆地操作。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">&quot;hexo多终端同步.md&quot;</span></span><br></pre></td></tr></table></figure>
<p>边修改边<code>hexo s</code>查看效果，直到修改完毕，便可以上传了，当然，也是分为上传源码到hexo分支和上传编译后静态文件到master分支这两步。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add <span class="keyword">source</span><span class="regexp">/_post/</span>多终端同步.md <span class="keyword">source</span><span class="regexp">/_posts/</span>hexo多终端同步</span><br><span class="line">git commit <span class="string">&quot;new blog&quot;</span></span><br><span class="line">git <span class="keyword">push</span> origin hexo</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>之前在阿里云上<code>hexo init</code>出错</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; nunjucks@<span class="number">3.1</span>.<span class="number">3</span> postinstall /root/hexo/node_modules/nunjucks</span><br><span class="line">&gt; <span class="keyword">node</span> <span class="title">postinstall-build</span>.js src</span><br><span class="line"></span><br><span class="line">sh: <span class="number">1</span>: <span class="keyword">node</span><span class="title">: Permission</span> denied</span><br></pre></td></tr></table></figure>
<p>原因是我是root用户，而<code>npm</code>的默认用户ID是500，因此要设为0。可以直接修改<code>.npmrc</code>文件，也可以<code>npm config</code>命令修改：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~# npm<span class="built_in"> config </span><span class="built_in">set</span><span class="built_in"> user </span>0</span><br><span class="line">~# npm<span class="built_in"> config </span><span class="built_in">set</span> unsafe-perm <span class="literal">true</span></span><br><span class="line">~# cat .npmrc</span><br><span class="line"><span class="attribute">user</span>=0</span><br><span class="line"><span class="attribute">unsafe-perm</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>hexo博客置顶需要修改npm模块代码，修改<code>node_modules/hexo-generator-index/lib/generator.js</code>如下，按照top值排序</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">locals</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="variable language_">this</span>.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.<span class="property">posts</span>.<span class="title function_">sort</span>(config.<span class="property">index_generator</span>.<span class="property">order_by</span>);</span><br><span class="line"></span><br><span class="line">  posts.<span class="property">data</span> = posts.<span class="property">data</span>.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.<span class="property">top</span> == b.<span class="property">top</span>) <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">top</span> - a.<span class="property">top</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.<span class="property">top</span> &amp;&amp; !b.<span class="property">top</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.<span class="property">top</span> &amp;&amp; b.<span class="property">top</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="property">date</span> - a.<span class="property">date</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.<span class="property">pagination_dir</span> || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">pagination</span>(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    <span class="attr">perPage</span>: config.<span class="property">index_generator</span>.<span class="property">per_page</span>,</span><br><span class="line">    <span class="attr">layout</span>: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    <span class="attr">format</span>: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">__index</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比如我这篇博客的top设置为0。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">hexo多终端同步</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-10-15 20:07:19</span></span><br><span class="line"><span class="attr">tags:</span> <span class="string">搭环境</span></span><br><span class="line"><span class="attr">top:</span> <span class="number">0</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/05/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2018/09/05/%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">生成字典序的全排列算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-09-05 16:38:11" itemprop="dateCreated datePublished" datetime="2018-09-05T16:38:11+08:00">2018-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="代码测试模板"><a href="#代码测试模板" class="headerlink" title="代码测试模板"></a>代码测试模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> a[n];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">iota</span>(a, a + n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : a)</span><br><span class="line">        cout &lt;&lt; x;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="1-交换元素法"><a href="#1-交换元素法" class="headerlink" title="1. 交换元素法"></a>1. 交换元素法</h1><p>《剑指Offer》第一版的面试题28：字符串的排列，书上给出的递归算法实现如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="built_in">Permutation</span>(int k) &#123;</span><br><span class="line">    if (k == n)</span><br><span class="line">        <span class="built_in">printX</span>();</span><br><span class="line">    for (int i = k; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">        <span class="built_in">Permutation</span>(k + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种做法的问题是，得出的结果无法保持字典序，比如n&#x3D;4时，1432在1423前面，原因是4和2交换后，后面的3和2就失去了有序性。<br>那么对后面进行排序呢？也不行，如果排序之后，2的位置变了，之后调用的<code>swap(a[1], a[3])</code>交换的便是4和3而非4和2。</p>
<h1 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2. DFS"></a>2. DFS</h1><p>其实字典序排序的就是找到N叉树的所有根节点到叶子节点的路径，以123为例</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">       [ ]</span><br><span class="line">    /   |<span class="string">   \</span></span><br><span class="line"><span class="string">  1     2     3</span></span><br><span class="line"><span class="string"> / \   / \   / \</span></span><br><span class="line"><span class="string">2   3 1   3 1   2</span></span><br><span class="line"><span class="string"></span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|<span class="string"> </span>|<span class="string">   </span>|</span><br><span class="line">3   2 3   2 2   1</span><br></pre></td></tr></table></figure>
<p>构造出这棵树，然后DFS即可。问题是如何构造？实际上是N叉树剪枝。剪枝通过为每个节点设置标志来判断，无需用哈希表，每个节点对应数组的一个下标。实现如下：<br>先添加全局变量以及修改<code>init()</code>函数</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">bool visited<span class="selector-attr">[n]</span>;</span><br><span class="line">int a0<span class="selector-attr">[n]</span>;  <span class="comment">// 保存a[n]的原始数据</span></span><br><span class="line">inline void <span class="built_in">init</span>() &#123;</span><br><span class="line">    <span class="built_in">iota</span>(a0, a0 + n, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">copy</span>(a0, a0 + n, a);</span><br><span class="line">    <span class="built_in">fill</span>(visited, visited + n, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后实现递归函数</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= n) &#123;</span><br><span class="line">        <span class="built_in">printA</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;  <span class="comment">// 剪枝</span></span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            a[k] = a0[i];</span><br><span class="line">            <span class="built_in">dfs</span>(k + <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-STL算法"><a href="#3-STL算法" class="headerlink" title="3. STL算法"></a>3. STL算法</h1><p>STL提供了现成的函数来提供下一个字典序(默认)排列</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sort(a, a + n);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    print<span class="constructor">A()</span>;</span><br><span class="line">&#125; <span class="keyword">while</span> (next<span class="constructor">_permutation(<span class="params">a</span>, <span class="params">a</span> + <span class="params">n</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>因此上述代码就足以实现算法了，这里主要研究下<code>next_permutation()</code>的实现。<br><code>next_permutation()</code>生成的是下一个较大的序列，比如对123生成的就是132而非213、231，因为不存在大小范围在123和132之间的排列。<br>设当前序列为a[n]，且存在i使得a[i]&gt;a[i+1]&gt;…&gt;a[n-1]。此时无法通过交换a[i]到a[n-1]之间的两个元素使其字典序更大。<br>因此必须将a[i-1]和a[i]..a[n-1]之间一个比a[i-1]大的数交换，比如对153642，后缀642单调递减，因此得交换3和6、4、2的一个数。而交换2会使字典序减小，因此交换4，得到154632，由于6&gt;4&gt;3&gt;2，相当于3插入2和4之间，因此后缀632是单调递减，需要将其逆置来获得最小字典序。<br>具体证明这里不详述，可参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/devymex/archive/2010/08/17/1801122.html">全排列生成算法: next_permutation</a></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> <span class="constructor">NextPermutation()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 找出右边最大递减序列a[i..n-1]</span></span><br><span class="line">    <span class="built_in">int</span> i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span><span class="operator"> &amp;&amp; </span>a<span class="literal">[<span class="identifier">i</span> - <span class="number">1</span>]</span> &gt;= a<span class="literal">[<span class="identifier">i</span>]</span>)</span><br><span class="line">        i--;</span><br><span class="line">    <span class="keyword">if</span> (i<span class="operator"> == </span><span class="number">0</span>) &#123;  <span class="comment">// 整个a[n]为降序</span></span><br><span class="line">        std::reverse(a, a + n);  <span class="comment">// 恢复成初始的升序状态</span></span><br><span class="line">        return <span class="literal">false</span>;  <span class="comment">// 已经是最大字典序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> j = std::lower<span class="constructor">_bound(<span class="params">a</span> + <span class="params">i</span>, <span class="params">a</span> + <span class="params">n</span>, <span class="params">a</span>[<span class="params">i</span> - 1], <span class="params">std</span>::<span class="params">greater</span>&lt;<span class="params">int</span>&gt;()</span>) - a - <span class="number">1</span>;</span><br><span class="line">    swap(a<span class="literal">[<span class="identifier">i</span> - <span class="number">1</span>]</span>, a<span class="literal">[<span class="identifier">j</span>]</span>);</span><br><span class="line">    std::reverse(a + i, a + n);</span><br><span class="line">    return <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法还有个优点就是避免了重复输出。<br>比如对序列112，用DFS做会生成两个112。而用这种方法做：</p>
<ol>
<li>a[1]和a[2]交换，得到121；</li>
<li>a[0]和a[1]交换，得到211，结束。</li>
</ol>
<p>因为每次交换的是a[i-1]和大于a[i-1]的a[j]，因此不会像交换法或DFS一样将a[i-1]和相等的a[j]交换。<br>这里使用<code>lower_bound()</code>在降序序列中进行二分查找，找到用来和a[i-1]交换的a[j]。而STL直接是从后往前查找，原因是<code>next_permutation()</code>是基于双向迭代器的，无法应用于二分查找。虽然理论上我这种做法更快，但实际上生成全排列的时间复杂度是O(n!)，n不可能很大，充其量上两位数，相比起全排列本身的复杂度，O(n)到O(logn)的效率提升实际上无关痛痒。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XYZ, aka BewareMyPower</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYZ, aka BewareMyPower</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
