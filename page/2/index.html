<!DOCTYPE html>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BewareMyPower的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="BewareMyPower的博客">
<meta property="og:locale">
<meta property="article:author" content="XYZ, aka BewareMyPower">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BewareMyPower的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BewareMyPower的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/31/vtable-%E5%92%8C-typeinfo-%E7%AC%A6%E5%8F%B7%E4%B8%A2%E5%A4%B1%E6%8E%92%E6%9F%A5%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/vtable-%E5%92%8C-typeinfo-%E7%AC%A6%E5%8F%B7%E4%B8%A2%E5%A4%B1%E6%8E%92%E6%9F%A5%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">vtable 和 typeinfo 符号丢失排查笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-31 19:56:06" itemprop="dateCreated datePublished" datetime="2020-08-31T19:56:06+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单说原来的结构是有一个类 <code>Foo</code>，并且重载了流运算符 <code>operator&lt;&lt;</code>，在另一个类 <code>Caller</code> 中直接 <code>&lt;&lt;</code> 打印出 <code>Foo</code> 对象。</p>
<p>现在由于功能扩充，<code>Foo</code> 可能有多种变体，因此需要进行以下重构：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FooBase</span><br><span class="line">  -&gt; Foo</span><br><span class="line">  -&gt; AnotherFoo</span><br><span class="line">  -&gt; ...</span><br></pre></td></tr></table></figure>

<p>然后 <code>Caller</code> 内部存放的对象从 <code>std::unique_ptr&lt;Foo&gt;</code> 改成了 <code>std::unique_ptr&lt;FooBase&gt;</code>。</p>
<h2 id="基本知识回顾：流运算符重载"><a href="#基本知识回顾：流运算符重载" class="headerlink" title="基本知识回顾：流运算符重载"></a>基本知识回顾：流运算符重载</h2><p>对于类 <code>Foo</code>，流运算符重载是一个全局函数（注意，不是类成员函数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Foo&amp; foo) &#123;</span><br><span class="line">    <span class="comment">// os &lt;&lt; foo 的内部字段</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了能直接访问 <code>Foo</code> 的内部字段，一般会将该重载函数声明为类 <code>Foo</code> 的友元函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp;, <span class="type">const</span> Foo&amp;);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里要避免一个误区，那就是将 <code>operator&lt;&lt;</code> 作为类成员函数的话，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// os &lt;&lt; 内部字段</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对应的调用是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.<span class="keyword">operator</span>&lt;&lt;(std::cout);  <span class="comment">// 完整调用方式</span></span><br><span class="line">foo &lt;&lt; std::cout;           <span class="comment">// 简略版调用方式</span></span><br></pre></td></tr></table></figure>

<p>而 <code>std::cout &lt;&lt; os</code> 则是由全局函数来重载的，也就是是标准库的 <code>std::ostream</code> 类的 <code>operator&lt;&lt;</code> 方法调用的是 <code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const T&amp;)</code> 函数来实现对任意类型 <code>T</code> 的对象进行输出。</p>
<h2 id="继承体系的解决方式以及-vtable-信息缺失问题"><a href="#继承体系的解决方式以及-vtable-信息缺失问题" class="headerlink" title="继承体系的解决方式以及 vtable 信息缺失问题"></a>继承体系的解决方式以及 vtable 信息缺失问题</h2><p>对于继承体系，我们想要的其实是下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> base = <span class="keyword">new</span> Derived;</span><br><span class="line">std::cout &lt;&lt; *base &lt;&lt; std::endl;  <span class="comment">// 调用 Derived 相关的 operator&lt;&lt;，且只暴露 Base 接口</span></span><br></pre></td></tr></table></figure>

<p>可以用间接的方式来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Base&amp; base) &#123;</span><br><span class="line">        <span class="keyword">return</span> base.<span class="built_in">print</span>(os);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// os &lt;&lt; 内部字段</span></span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类只要重载 <code>print</code> 方法即可。</p>
<p>然而我这么干了，编译 OK，但是链接时出错：</p>
<blockquote>
<p>undefined reference to &#96;vtable for 【基类名】</p>
<p>undefined reference to &#96;typeinfo for 【基类名】</p>
</blockquote>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>一开始只有这个信息，所以不好排除，我对比了半天（<code>override</code> 和 <code>virtual</code> 关键字数量对比），基类的虚函数我在派生类全都实现了啊。</p>
<hr>
<p>PS：用 <code>override</code> 关键字可以很大程度避免重载函数名写错的情况，比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">doSOmeting</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此时不小心写错了虚函数名字，用 <code>override</code> 关键字就直接能在编译时提示错误：</p>
<blockquote>
<p>error: ‘void Derived::doSOmeting()’ marked ‘override’, but does not override</p>
</blockquote>
<p>如果不加 <code>override</code> 关键字，编译就不会出错，但是调用的是基类 <code>Base</code> 的 <code>doSomething()</code> 方法，派生类并没有重写该方法。导致这种低级错误得等到运行期去排查。</p>
<hr>
<p>回到问题，这里我就有点束手无策了，总感觉自己有些基本知识弄错了（实际上并没有）。首先想了下是不是我虚析构函数的问题（因为除了虚析构函数外其他虚函数都是纯虚函数）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooBase</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FooBase</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后改成了头文件声明，源文件定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo_base.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FooBase</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">FooBase</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo_base.cc</span></span><br><span class="line">FooBase::~<span class="built_in">FooBase</span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>一个有趣的现象，虽然还是报错，但是报错信息变了，有了更具体的信息：</p>
<blockquote>
<p>undefined reference to &#96;FooBase::print(std::ostream&amp;) const’</p>
</blockquote>
<p>到这里我才回过头来审视 <code>print</code> 方法。不过为了验证观点，首先把这个虚函数给删掉，链接成功，证明了这个观点。再回过头来看，我并没有将其实现为纯虚函数，而是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(std::ostream&amp;)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure>

<p>只是声明，因此在基类的编译单元缺少其实现信息。看起来很简单的错误，但是在压力和恐慌之下，人的眼睛是不可相信的，至少我的肉眼看到的，这个分号前面就有个 <code>= 0</code>。</p>
<h2 id="追根溯源"><a href="#追根溯源" class="headerlink" title="追根溯源"></a>追根溯源</h2><p>能定位到这个错误，有一定程度上是因为我恰好把虚函数放到源文件中，有了新的报错信息。那么区别在哪呢？这里复现一下。</p>
<h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>给出以下源文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Base&amp; base) &#123;</span><br><span class="line">    <span class="keyword">return</span> base.<span class="built_in">print</span>(os);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// derived.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived</span> : Base &#123;</span><br><span class="line">  <span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// derived.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;derived.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">Derived::print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (os &lt;&lt; <span class="string">&quot;Derived&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成动态库 <code>libbase.so</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o libbase.so derived.cc -std=c++11 -fPIC -shared</span><br></pre></td></tr></table></figure>

<p>因为是动态库，开启了 <code>-fPIC</code> 选项，即  <strong>p</strong>osition-<strong>i</strong>ndependent <strong>c</strong>ode，位置无关的代码，也就是函数（符号）的实现暂时可以不定位到具体的位置，而是在和其他编译单元链接时再定位。</p>
<p>这里给出调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;derived.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_ptr&lt;Base&gt; <span class="title">base</span><span class="params">(<span class="keyword">new</span> Derived)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; *base &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -std=c++11 -L. -lfoo</span><br><span class="line">/tmp/cc39RCrN.o: In <span class="keyword">function</span> `Base::Base()<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.cc:(.text._ZN4BaseC2Ev[_ZN4BaseC5Ev]+0x9): undefined reference to `vtable for Base&#x27;</span></span><br><span class="line">/tmp/cc39RCrN.o: In <span class="keyword">function</span> `Derived::Derived()<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">main.cc:(.text._ZN7DerivedC2Ev[_ZN7DerivedC5Ev]+0x19): undefined reference to `vtable for Derived&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br></pre></td></tr></table></figure>

<h3 id="查看符号表"><a href="#查看符号表" class="headerlink" title="查看符号表"></a>查看符号表</h3><p>使用 <code>nm</code> 查看符号表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ nm libbase.so | egrep <span class="string">&quot;(Base|Derived)&quot;</span></span><br><span class="line">0000000000000cda W _ZN4BaseD0Ev</span><br><span class="line">0000000000000ca4 W _ZN4BaseD1Ev</span><br><span class="line">0000000000000ca4 W _ZN4BaseD2Ev</span><br><span class="line">0000000000000d42 W _ZN7DerivedD0Ev</span><br><span class="line">0000000000000d00 W _ZN7DerivedD1Ev</span><br><span class="line">0000000000000d00 W _ZN7DerivedD2Ev</span><br><span class="line">0000000000000c20 T _ZNK7Derived5printERSo</span><br><span class="line">                 U _ZTI4Base</span><br><span class="line">0000000000201058 V _ZTI7Derived</span><br><span class="line">0000000000000dc8 V _ZTS7Derived</span><br><span class="line">                 U _ZTV4Base</span><br><span class="line">0000000000201030 V _ZTV7Derived</span><br></pre></td></tr></table></figure>

<p>由于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Name_mangling">name mangling</a>，上面的比较难辨认。注意第二列的符号，从 <a target="_blank" rel="noopener" href="https://linux.die.net/man/1/nm"><code>nm</code> 帮助手册</a> 可知：</p>
<ul>
<li><code>W</code>：没有标记成<strong>弱对象</strong>的弱（<strong>W</strong>eak）符号，当弱符号链接到普通符号时不会报错，当弱符号被链接且该符号未定义时，该符号的值用一种系统特定的方式决定，不会报错。某些系统上，大写的 <code>W</code> 代表默认值被指定。</li>
<li><code>T</code>：符号在文本（代码）段。</li>
<li><code>U</code>：符号未定义（<strong>U</strong>ndefined ）。</li>
<li><code>V</code>：<strong>弱对象</strong>，其余说明同 <code>W</code>。</li>
</ul>
<p>PS：即使使用 <code>delete</code> 禁止拷贝构造函数和拷贝赋值运算符，符号表仍然不变。</p>
<p>如果将 <code>Base::print</code> 改成纯虚函数呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>符号表变成了：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000</span>dda W _ZN4BaseD0Ev</span><br><span class="line"><span class="number">0000000000000</span>da4 W _ZN4BaseD1Ev</span><br><span class="line"><span class="number">0000000000000</span>da4 W _ZN4BaseD2Ev</span><br><span class="line"><span class="number">0000000000000e42</span> W _ZN7DerivedD0Ev</span><br><span class="line"><span class="number">0000000000000e00</span> W _ZN7DerivedD1Ev</span><br><span class="line"><span class="number">0000000000000e00</span> W _ZN7DerivedD2Ev</span><br><span class="line"><span class="number">0000000000000d20</span> T _ZNK7Derived5printERSo</span><br><span class="line"><span class="number">00000000002010</span>b8 V _ZTI4Base</span><br><span class="line"><span class="number">00000000002010</span>a0 V _ZTI7Derived</span><br><span class="line"><span class="number">0000000000000</span>ed1 V _ZTS4Base</span><br><span class="line"><span class="number">0000000000000</span>ec8 V _ZTS7Derived</span><br><span class="line"><span class="symbol">0000000000201078 </span>V _ZTV4Base</span><br><span class="line"><span class="symbol">0000000000201050 </span>V _ZTV7Derived</span><br></pre></td></tr></table></figure>

<p>这里列出区别：</p>
<ul>
<li><code>_ZTI4Base</code> 和 <code>_ZTV4Base</code> 从 <code>U</code>（未定义）变成了 <code>V</code>，也就是弱对象。</li>
<li>多了个弱对象 <code>_ZTS4Base</code>。</li>
</ul>
<p>然后将析构函数单独抽离到 <code>base.cc</code> 来实现，重新编译动态库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o libbase.so base.cc derived.cc -std=c++11 -fPIC -shared</span><br></pre></td></tr></table></figure>

<p>符号表变成了：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000d66</span> T _ZN4BaseD0Ev</span><br><span class="line"><span class="number">0000000000000d30</span> T _ZN4BaseD1Ev</span><br><span class="line"><span class="number">0000000000000d30</span> T _ZN4BaseD2Ev</span><br><span class="line"><span class="number">0000000000000</span>eb2 W _ZN7DerivedD0Ev</span><br><span class="line"><span class="number">0000000000000e70</span> W _ZN7DerivedD1Ev</span><br><span class="line"><span class="number">0000000000000e70</span> W _ZN7DerivedD2Ev</span><br><span class="line"><span class="number">0000000000000</span>dec T _ZNK7Derived5printERSo</span><br><span class="line"><span class="symbol">0000000000201138 </span>V _ZTI4Base</span><br><span class="line"><span class="symbol">0000000000201170 </span>V _ZTI7Derived</span><br><span class="line"><span class="number">0000000000000</span>f29 V _ZTS4Base</span><br><span class="line"><span class="number">0000000000000</span>f38 V _ZTS7Derived</span><br><span class="line"><span class="symbol">0000000000201110 </span>V _ZTV4Base</span><br><span class="line"><span class="symbol">0000000000201148 </span>V _ZTV7Derived</span><br></pre></td></tr></table></figure>

<p>主要区别：</p>
<ul>
<li>三个 <code>_ZN4BaseD&lt;i&gt;Ev</code>（i 是0，1，2）从 <code>W</code>（弱符号）变成了 <code>T</code>（文本段）。</li>
</ul>
<p>而重新将 <code>print</code> 改成未定义的函数后，符号表变成了：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000</span>d96 T <span class="variable">_ZN4BaseD0Ev</span></span><br><span class="line"><span class="number">0000000000000</span>d60 T <span class="variable">_ZN4BaseD1Ev</span></span><br><span class="line"><span class="number">0000000000000</span>d60 T <span class="variable">_ZN4BaseD2Ev</span></span><br><span class="line"><span class="number">0000000000000</span>ee2 W <span class="variable">_ZN7DerivedD0Ev</span></span><br><span class="line"><span class="number">0000000000000</span>ea0 W <span class="variable">_ZN7DerivedD1Ev</span></span><br><span class="line"><span class="number">0000000000000</span>ea0 W <span class="variable">_ZN7DerivedD2Ev</span></span><br><span class="line">                 U <span class="variable">_ZNK4Base5printERSo</span></span><br><span class="line"><span class="number">0000000000000</span>e1c T <span class="variable">_ZNK7Derived5printERSo</span></span><br><span class="line"><span class="number">0000000000201168</span> V <span class="variable">_ZTI4Base</span></span><br><span class="line"><span class="number">00000000002011</span>a0 V <span class="variable">_ZTI7Derived</span></span><br><span class="line"><span class="number">0000000000000</span>f59 V <span class="variable">_ZTS4Base</span></span><br><span class="line"><span class="number">0000000000000</span>f68 V <span class="variable">_ZTS7Derived</span></span><br><span class="line"><span class="number">0000000000201140</span> V <span class="variable">_ZTV4Base</span></span><br><span class="line"><span class="number">0000000000201178</span> V <span class="variable">_ZTV7Derived</span></span><br></pre></td></tr></table></figure>

<p>最大的区别，这里的 <code>U</code> 是 <code>_ZNK4Base5printERSo</code>，很显然，就是基类 <code>Base</code> 的 <code>print</code> 方法。虽然对链接的知识已经忘了不少（得去补课了），但回顾这 4 张符号表，还是可以大致看出为啥析构函数单独分离出去后信息发生变化。</p>
<p>最开始析构函数实现写在 .h 文件里时，未定义的符号有两个（一个是 <code>typeinfo</code> 一个是 <code>vtable</code>）：</p>
<ul>
<li><code>_ZTI4Base</code></li>
<li><code>_ZTV4Base</code></li>
</ul>
<p>而析构函数独立出去后，未定义的符号：</p>
<ul>
<li><code>_ZNK4Base5printERSo</code>：<code>Base</code> 类的 <code>print</code> 函数。</li>
</ul>
<p>至少现在我们知道了为啥会有提示错误区别，但是编译器为啥这么干，还是不清楚。只能说，从经验的角度</p>
<h3 id="优化一下？"><a href="#优化一下？" class="headerlink" title="优化一下？"></a>优化一下？</h3><p>所以说明明可以写在源文件里，为何要写在头文件中？写在源文件里至少还能帮助调试。当然这是出自 C++er 的直觉：要是内联了呢？</p>
<p>于是回到最初的模式（<code>Base</code> 虚析构函数在头文件实现，<code>print</code> 不实现），开 <code>-O2</code> 编译，符号表：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000b30</span> W _ZN7DerivedD0Ev</span><br><span class="line"><span class="number">0000000000000b20</span> W _ZN7DerivedD1Ev</span><br><span class="line"><span class="number">0000000000000b20</span> W _ZN7DerivedD2Ev</span><br><span class="line"><span class="number">0000000000000b00</span> T _ZNK7Derived5printERSo</span><br><span class="line">                 U _ZTI4Base</span><br><span class="line"><span class="number">0000000000200cb0</span> V _ZTI7Derived</span><br><span class="line"><span class="number">0000000000000bc0</span> V _ZTS7Derived</span><br><span class="line"><span class="number">0000000000200cc8</span> V _ZTV7Derived</span><br></pre></td></tr></table></figure>

<p>相比默认的（<code>-O0</code> 编译）：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000</span>cda W <span class="variable">_ZN4BaseD0Ev</span></span><br><span class="line"><span class="number">0000000000000</span>ca4 W <span class="variable">_ZN4BaseD1Ev</span></span><br><span class="line"><span class="number">0000000000000</span>ca4 W <span class="variable">_ZN4BaseD2Ev</span></span><br><span class="line"><span class="number">0000000000000</span>d42 W <span class="variable">_ZN7DerivedD0Ev</span></span><br><span class="line"><span class="number">0000000000000</span>d00 W <span class="variable">_ZN7DerivedD1Ev</span></span><br><span class="line"><span class="number">0000000000000</span>d00 W <span class="variable">_ZN7DerivedD2Ev</span></span><br><span class="line"><span class="number">0000000000000</span>c20 T <span class="variable">_ZNK7Derived5printERSo</span></span><br><span class="line">                 U <span class="variable">_ZTI4Base</span></span><br><span class="line"><span class="number">0000000000201058</span> V <span class="variable">_ZTI7Derived</span></span><br><span class="line"><span class="number">0000000000000</span>dc8 V <span class="variable">_ZTS7Derived</span></span><br><span class="line">                 U <span class="variable">_ZTV4Base</span></span><br><span class="line"><span class="number">0000000000201030</span> V <span class="variable">_ZTV7Derived</span></span><br></pre></td></tr></table></figure>

<p>首先前三个 <code>Base</code> 的符号（构造函数）被直接内联了。<code>_ZTV4Base</code> 也没了（虚表？），编译 <code>main.cc</code> 报错信息也少了：</p>
<blockquote>
<p>$ g++ main.cc -std&#x3D;c++11 -L. -lbase -O2<br>.&#x2F;libbase.so: undefined reference to &#96;typeinfo for Base’<br>collect2: error: ld returned 1 exit status</p>
</blockquote>
<p>也就是说 <code>_ZTV4Base</code> 实际上就是 <code>vtable</code>（<code>V</code> 代表 <strong>v</strong>table），而另一个保留的 <code>_ZTI4Base</code> 则是类型信息（<code>I</code> 代表 type<strong>i</strong>nfo）。</p>
<p>看来我作为 C++er 的直觉还是对的，内联了导致虚析构函数就是个普通函数一样。但如果把虚析构函数给独立出去，那么开不开 <code>-O2</code> 优化，结果都一样。</p>
<h3 id="name-mangling-还原"><a href="#name-mangling-还原" class="headerlink" title="name mangling 还原"></a>name mangling 还原</h3><p>其实 <code>nm</code> 已经提供了还原功能了，加上 <code>-C</code> 选项即可（这是 <code>-O2</code> 优化+析构函数在头文件里+<code>print</code> 函数未定义）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nm -C libbase.so | egrep <span class="string">&quot;(Base|Derived)&quot;</span></span><br><span class="line">0000000000000b30 W Derived::~Derived()</span><br><span class="line">0000000000000b20 W Derived::~Derived()</span><br><span class="line">0000000000000b20 W Derived::~Derived()</span><br><span class="line">0000000000000b00 T Derived::<span class="built_in">print</span>(std::ostream&amp;) const</span><br><span class="line">                 U typeinfo <span class="keyword">for</span> Base</span><br><span class="line">0000000000200cb0 V typeinfo <span class="keyword">for</span> Derived</span><br><span class="line">0000000000000bc0 V typeinfo name <span class="keyword">for</span> Derived</span><br><span class="line">0000000000200cc8 V vtable <span class="keyword">for</span> Derived</span><br></pre></td></tr></table></figure>

<p>PS：嗯，前面的内容就当踩坑了……懒得改……</p>
<p>此外，也可以看到析构函数放在源文件里时符号表多了：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000d70</span> T <span class="keyword">Base</span>::~<span class="keyword">Base</span>()</span><br><span class="line"><span class="number">0000000000000d60</span> T <span class="keyword">Base</span>::~<span class="keyword">Base</span>()</span><br><span class="line"><span class="number">0000000000000d60</span> T <span class="keyword">Base</span>::~<span class="keyword">Base</span>()</span><br></pre></td></tr></table></figure>

<p>对应的符号是以 <code>D</code> 结尾的，即 <code>D0</code>&#x2F;<code>D1</code>&#x2F;<code>D2</code>。至于为啥有三个析构函数我也不知道……对比了下普通类，只有两个析构函数（<code>D1</code>&#x2F;<code>D2</code>）。</p>
<h3 id="为何析构函数的符号有无会导致结果变化"><a href="#为何析构函数的符号有无会导致结果变化" class="headerlink" title="为何析构函数的符号有无会导致结果变化"></a>为何析构函数的符号有无会导致结果变化</h3><p>从上述分析可知，析构函数如果放在头文件里，无论是否内联优化，最终符号表里都只是 vtable 缺失。我大致猜测是，仅有一个虚函数的符号没有定义。</p>
<p>于是修改 <code>Base</code> 类的实现，加一个有实现的虚函数 <code>f</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">  <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Base&amp; base) &#123;</span><br><span class="line">    <span class="keyword">return</span> base.<span class="built_in">print</span>(os);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Base::f</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o libbase.so base.cc derived.cc -std=c++11 -fPIC -shared -O2</span><br><span class="line">$ nm -C libbase.so | egrep <span class="string">&quot;(Base|Derived)&quot;</span></span><br><span class="line">0000000000000d70 W Base::~Base()</span><br><span class="line">0000000000000d60 W Base::~Base()</span><br><span class="line">0000000000000d60 W Base::~Base()</span><br><span class="line">0000000000000de0 W Derived::~Derived()</span><br><span class="line">0000000000000dd0 W Derived::~Derived()</span><br><span class="line">0000000000000dd0 W Derived::~Derived()</span><br><span class="line">0000000000000d50 T Base::f() const</span><br><span class="line">                 U Base::<span class="built_in">print</span>(std::ostream&amp;) const</span><br><span class="line">0000000000000db0 T Derived::<span class="built_in">print</span>(std::ostream&amp;) const</span><br><span class="line">0000000000201038 V typeinfo <span class="keyword">for</span> Base</span><br><span class="line">0000000000201078 V typeinfo <span class="keyword">for</span> Derived</span><br><span class="line">0000000000000e68 V typeinfo name <span class="keyword">for</span> Base</span><br><span class="line">0000000000000e78 V typeinfo name <span class="keyword">for</span> Derived</span><br><span class="line">0000000000201048 V vtable <span class="keyword">for</span> Base</span><br><span class="line">0000000000201090 V vtable <span class="keyword">for</span> Derived</span><br></pre></td></tr></table></figure>

<p>可见，这里 <code>U</code> 不再是符号表，而是虚函数本身。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ 的 unsolved symbol 问题其实挺常见的，即使是踩过 N 次坑的我也容易因为一点失误而犯错。本文主要讲述了通过 <code>nm</code> 排查问题的方式，其中如果只有 <code>vtable</code>&#x2F;<code>typeinfo</code> 缺失这种难以排查的信息，可以尝试加一个带实现的虚函数（比如前文的 <code>f</code>），再来排查符号表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/14/%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9-rpath-%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/14/%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9-rpath-%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">链接选项 rpath 的应用和原理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-07-14 18:28:05" itemprop="dateCreated datePublished" datetime="2020-07-14T18:28:05+08:00">2020-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在测试和部署 C++ 动态库时，经常遇到的问题就是程序链接到了系统路径下的动态库，有时候 <code>make</code> 编译时链接到本地路径的动态库，但实际 <code>make install</code> 时则会丢失这个依赖。本文将要介绍的就是一种通用解决方法，使用 <code>RPATH</code> 来绑定链接路径。</p>
<h2 id="简单动态库编译和使用示例"><a href="#简单动态库编译和使用示例" class="headerlink" title="简单动态库编译和使用示例"></a>简单动态库编译和使用示例</h2><p>给出以下示例库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;foo\n&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>生成动态库 libfoo.so：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o libfoo.so -fPIC -shared foo.cc</span><br></pre></td></tr></table></figure>

<p>然后给出调用代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译时指定链接当前目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c -L . -lfoo</span><br><span class="line">$ ./a.out </span><br><span class="line">foo</span><br><span class="line">$ ldd a.out | grep libfoo</span><br><span class="line">	libfoo.so (0x00007fc2010f7000)</span><br></pre></td></tr></table></figure>

<p>至此，一切正常。</p>
<h2 id="依赖动态库的动态库"><a href="#依赖动态库的动态库" class="headerlink" title="依赖动态库的动态库"></a>依赖动态库的动态库</h2><p>实际编写程序时，往往会依赖一些第三方库来避免重复造轮子。比如，这里我们要写一个库依赖于 libfoo.so。</p>
<p>目录层次：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">include</span></span><br><span class="line">│   └── bar.<span class="keyword">h</span></span><br><span class="line">├── src</span><br><span class="line">│   └── bar.<span class="keyword">cc</span></span><br><span class="line">└── thirdparty</span><br><span class="line">    ├── <span class="keyword">include</span></span><br><span class="line">    │   └── foo.<span class="keyword">h</span></span><br><span class="line">    └── lib</span><br><span class="line">        └── libfoo.<span class="keyword">so</span></span><br></pre></td></tr></table></figure>

<p>然后编译 libbar.so：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o libbar.so -fPIC -shared src/bar.cc -I include/ -I thirdparty/include/ -L thirdparty/lib/ -lfoo</span><br></pre></td></tr></table></figure>

<p>问题来了，编译出的 libbar.so 找不到 libfoo.so 的依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ldd libbar.so | grep foo</span><br><span class="line">	libfoo.so =&gt; not found</span><br></pre></td></tr></table></figure>

<p>当然，这样的话，你编译依赖 libbar.so 的程序时会直接失败，从而提醒你去寻找依赖的 libfoo.so：</p>
<blockquote>
<p>&#x2F;usr&#x2F;bin&#x2F;ld: warning: libfoo.so, needed by .&#x2F;libbar.so, not found (try using -rpath or -rpath-link)<br>.&#x2F;libbar.so: undefined reference to &#96;foo’</p>
</blockquote>
<p>注意这里我们第一次见到 <em>rpath</em> 这个概念。</p>
<p>但是问题更大的是，假如 libfoo.so 是一个旧版的库，而有个其他用户完全无视影响，直接将 libfoo.so 安装到了系统目录，比如 <code>/usr/lib64</code> 下面。这样，你的程序依赖的 libbar.so 将会找到系统目录下旧的 libfoo.so，而不是你自己维护的新版。如果新版 libfoo.so 的 ABI 发生了改变而 API 不变，比如这里 C 库变成了 C++ 库：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.cc</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">&quot;foo: %d\n&quot;</span>, i); &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>API 兼容指的是，调用 <code>foo()</code> 仍然合法，但是由于 C++ 的 name mangling，带有默认参数的 <code>foo</code> 对应的符号发生了变化，因此 foo 可能还会出现这样的错误（main.cc 仅仅是调用 <code>bar()</code> 函数，这里就不贴代码了）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -L . -lbar</span><br><span class="line">./libbar.so: undefined reference to `<span class="built_in">foo</span>(<span class="type">int</span>)&#x27;</span><br><span class="line">collect2: error: ld returned <span class="number">1</span> exit status</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看 libbar.so 的依赖就什么都明白了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ldd libbar.<span class="keyword">so</span> | <span class="keyword">grep</span> libfoo</span><br><span class="line">	libfoo.<span class="keyword">so</span> =&gt; /usr/lib64/libfoo.<span class="keyword">so</span> (<span class="number">0</span>x00007efd6daf1000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原因是 <code>foo</code> 的函数签名变成了 <code>void foo(int)</code>，而链接到的动态库却是全局的 libfoo.so。简单的解决方式是，将本地库的路径加入 <code>LD_LIBRARY_PATH</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$PWD</span>/thirdparty/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">$ g++ main.cc -L . -lbar</span><br><span class="line">$ ./a.out </span><br><span class="line">bar</span><br><span class="line">foo: 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用 <code>ldd</code> 也能查看 libbar.so 依赖的 libfoo.so 不再是全局的，而是本地的。但问题是，如果发布单独的 libbar.so 给用户，而用户又因为某些原因无法升级全局的 libfoo.so，那么每次用户都要手动设置 <code>LD_LIBRARY_PATH</code>。</p>
<p>此时，另一种解决方法刚好能避免这个问题，也就是使用 rpath。</p>
<h2 id="rpath-的使用"><a href="#rpath-的使用" class="headerlink" title="rpath 的使用"></a>rpath 的使用</h2><p>rpath 即 runtime path，运行时路径。既可以指定相对路径也可以指定绝对路径。</p>
<p>编译方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o libbar.so -fPIC -shared src/bar.cc \</span><br><span class="line">   -I include/ -I thirdparty/include/ \</span><br><span class="line">   -L thirdparty/lib/ -lfoo -Wl,-rpath=thirdparty/lib/</span><br><span class="line">$ ldd libbar.so | grep foo</span><br><span class="line">	libfoo.so =&gt; thirdparty/lib/libfoo.so (0x00007f8319965000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意最后的 <code>-Wr,-rpath</code> 指定的是动态库的路径。看似和 <code>-L</code> 重复，实际不然。<code>-L</code> 指定的是编译时链接的 libfoo.so 路径，而 <code>-Wl,-rpath</code> 指定的是（libbar.so）运行时链接的 libfoo.so 路径。这里指定的是相对路径。</p>
<p>因此如果我们安装 libbar.so 到全局又不影响全局的 libfoo.so，比如安装到 <code>/usr/lib64</code> 下面：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">cp</span> libbar.so /usr/lib64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们继续编译 libbar.so 的使用程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -lbar</span><br><span class="line">$ ldd a.out | grep foo</span><br><span class="line">	libfoo.so =&gt; thirdparty/lib/libfoo.so (0x00007f5d3d79f000)</span><br><span class="line">$ ldd a.out | grep bar</span><br><span class="line">	libbar.so =&gt; /usr/lib64/libbar.so (0x00007fed07e78000)</span><br><span class="line">$ <span class="built_in">ls</span> /usr/lib64/libfoo.so </span><br><span class="line">/usr/lib64/libfoo.so</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样想发布依赖高版本 libfoo.so 的 libbar.so 时，用户只需要在<strong>编译和运行</strong>时，相对路径 <code>thirdparty/lib</code> 下面有高版本 libfoo.so 就行了，无需覆盖全局路径下的低版本 libfoo.so。</p>
<p>注意如果换个路径运行 a.out，由于 rpath 指定的是相对路径，此时会找不到 libfoo.so。</p>
<p>所以 rpath 指定绝对路径的做法也是比较常见的，比如编译 libbar.so 时将 libfoo.so 置于不会冲突的系统目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo <span class="built_in">mkdir</span> -p /usr/lib64/foo-1.1</span><br><span class="line">$ sudo <span class="built_in">cp</span> thirdparty/lib/libfoo.so /usr/lib64/foo-1.1</span><br><span class="line">$ g++ -o libbar.so -fPIC -shared src/bar.cc \</span><br><span class="line">   -I include/ -I thirdparty/include/ \</span><br><span class="line">   -L /usr/lib64/foo-1.1 -lfoo -Wl,-rpath=/usr/lib64/foo-1.1</span><br><span class="line"> $ ldd libbar.so | grep foo</span><br><span class="line">	libfoo.so =&gt; /usr/lib64/foo-1.1/libfoo.so (0x00007f83df270000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么用户部署时，只需要将 libfoo.so 放置在 <code>/usr/lib64/foo-1.1</code> 下面就行，这里的 1.1 用于标识版本号。由于该目录并不会被自动连接，从而防止了其他程序自动链接到这个版本的 libfoo.so。</p>
<h2 id="回到现代，使用-CMake"><a href="#回到现代，使用-CMake" class="headerlink" title="回到现代，使用 CMake"></a>回到现代，使用 CMake</h2><p>但凡稍有规模的程序，直接使用 GCC 编译来构建项目是难以维护的。即使有了 Makefile，管理和维护起来还是相对麻烦。C++ 缺乏类似 Maven 那样的构建系统，但退而求其次，CMake 已经成为了事实上的 C++ 构建通用解决方案。（虽然早期流行的 Autotools 仍然有一定市场）</p>
<p>以一个极简的 CMakeLists.txt 为例，将 rpath 指定为相对路径</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">12</span>)</span><br><span class="line"><span class="keyword">project</span>(Bar CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 find_path/find_library 查找的根目录，默认会从 include 以及 lib 子目录查找</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/thirdparty&quot;</span>)</span><br><span class="line"><span class="keyword">find_path</span>(FOO_INCLUDE_DIR NAMES foo.h)</span><br><span class="line"><span class="keyword">find_library</span>(FOO_LIB NAMES libfoo.so)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(bar SHARED src/bar.cc)</span><br><span class="line"><span class="keyword">include_directories</span>(./<span class="keyword">include</span> <span class="variable">$&#123;FOO_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(bar <span class="variable">$&#123;FOO_LIB&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 rpath，这里是绝对路径</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/thirdparty/lib&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装到 lib 子目录，该相对路径是相对 CMAKE_INSTALL_PREFIX 而言的</span></span><br><span class="line"><span class="keyword">install</span>(TARGETS bar LIBRARY DESTINATION lib)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>PS：说是回到现代，我这个 CMake 还是老式的风格，现代 CMake 又是另一个话题了，不熟悉 CMake 的话，可以直接从现代 CMake 学起。</p>
<p>当前目录层次：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">├── include</span><br><span class="line">│   └── bar<span class="selector-class">.h</span></span><br><span class="line">├── <span class="selector-tag">main</span><span class="selector-class">.cc</span></span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">│   └── bar<span class="selector-class">.cc</span></span><br><span class="line">└── thirdparty</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── foo<span class="selector-class">.h</span></span><br><span class="line">    └── lib</span><br><span class="line">        └── libfoo<span class="selector-class">.so</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 CMake 构建项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> _builds &amp;&amp; $ <span class="built_in">cd</span> _builds/</span><br><span class="line">$ cmake .. -DCMAKE_INSTALL_PREFIX=<span class="variable">$PWD</span>/..</span><br><span class="line">$ make</span><br><span class="line">$ make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后目录层次（忽略中间目录 <code>_builds</code>）：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists<span class="selector-class">.txt</span></span><br><span class="line">├── include</span><br><span class="line">│   └── bar<span class="selector-class">.h</span></span><br><span class="line">├── lib</span><br><span class="line">│   └── libbar<span class="selector-class">.so</span></span><br><span class="line">├── <span class="selector-tag">main</span><span class="selector-class">.cc</span></span><br><span class="line">├── <span class="attribute">src</span></span><br><span class="line">│   └── bar<span class="selector-class">.cc</span></span><br><span class="line">└── thirdparty</span><br><span class="line">    ├── include</span><br><span class="line">    │   └── foo<span class="selector-class">.h</span></span><br><span class="line">    └── lib</span><br><span class="line">        └── libfoo<span class="selector-class">.so</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似地，为了部署的话，可以将 libfoo.so 部署到系统目录 <code>/usr/lib64</code> 的子目录。</p>
<p>也可以修改成相对路径：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SHARED_LINKER_FLAGS <span class="variable">$&#123;CMAKE_SHARED_LINKER_FLAGS&#125;</span> -Wl,-rpath,&#x27;$ORIGIN/thirdparty&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 <code>$ORIGIN</code> 会被替换成动态库所处的绝对路径，也就是说只要 libfoo.so 处于 libbar.so 同级目录 thirdparty 下面，如下图所示：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── libbar.<span class="keyword">so</span></span><br><span class="line">└── thirdparty</span><br><span class="line">    └── libfoo.<span class="keyword">so</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后 libbar.so 就会链接到 thirdparty&#x2F;libfoo.so，并且都是绝对路径。</p>
<h2 id="Linux-动态库查找路径"><a href="#Linux-动态库查找路径" class="headerlink" title="Linux 动态库查找路径"></a>Linux 动态库查找路径</h2><p>最后一节，以理论来结尾。前文侧重实践，有了实践作为基础，回过头来看原理就更有体会了。</p>
<p>一个典型的 C&#x2F;C++ 程序的构建流程是：预处理，汇编，编译，链接。而执行链接的程序其实是 <code>ld</code>，通常编译器比如 GCC 都会自动调用 <code>ld</code> 去进行链接，用户不必关注其中的细节。而 <code>ld</code> 查找动态库的顺序是：</p>
<ol>
<li>rpath 指定的目录；</li>
<li>环境变量 <code>LD_LIBRARY_PATH</code> 指定的目录；</li>
<li>runpath 指定的目录；</li>
<li><code>/etc/ld.so.cache </code> 缓存文件，通常包含 <code>/etc/ld.so.conf</code> 文件编译出的二进制俩别哦（比如 CentOS 上，该文件会使用 include 从而使用 <code>ld.so.conf.d</code> 目录下面所有的 <code>*.conf</code> 文件，这些都会缓存在 ld.so.cache 中）</li>
<li>系统默认路径，比如 <code>/lib</code>，<code>/usr/lib</code>。</li>
</ol>
<p>在编译时若使用 <code>-z nodefaultlib</code> 选项编译，则会跳过 4 和 5。至于 runpath，和 rpath 类似，都是二进制（ELF）文件的动态 section 属性（分别为 <code>DT_RUNPATH</code> 和 <code>DT_RPATH</code>），唯一区别就是是否优先于 <code>LD_LIBRARY_PATH</code> 来查找。这里就不详述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，读者对如何编译&#x2F;部署动态库，以及动态库之间的依赖关系应该有了一定的认识。</p>
<p>相比而言，静态链接，静态链接部署简单，像 Golang 这种语言直接全部静态链接，受到了不少用户的青睐，而且占用体积大在现代已经几乎不再是需要特别考虑的问题。</p>
<p>但动态库有动态库的好处，比如在大型项目有多个组件依赖时，如果全部静态链接，则每次修改依赖的模块，都要将主模块重新编译一遍，对于 C++ 这种编译速度可能会非常耗时的语言是灾难性的。</p>
<p>另外，提供插件式接口给解释型语言（比如 Python 和 PHP）来调用时，动态库是必须的，解释器可以动态加载动态库。如果使用静态链接，恐怕没人愿意每换一个插件就要将解释器重新编译一遍。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/05/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB12-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8SystemTimer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/05/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB12-%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E6%97%B6%E5%99%A8SystemTimer/" class="post-title-link" itemprop="url">Kafka源码阅读12: 高性能计时器SystemTimer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-05 19:22:54" itemprop="dateCreated datePublished" datetime="2020-02-05T19:22:54+08:00">2020-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇阅读了时间轮 <code>TimingWheel</code> 的实现，遗留了两个重要问题：</p>
<ol>
<li>时间轮中被插入延迟队列的桶，何时被移除？</li>
<li>高层时间轮运转时，定时任务何时被插入低层时间轮？</li>
</ol>
<p>实际上，在 <code>kafka.utils.timer</code> 包的类中，真正暴露给其它包的只有 <code>SystemTimer</code>，而且注解为 <code>@threadsafe</code>（线程安全），时间轮 <code>TimingWheel</code> 只不过是它的一个字段，本身注解也是 <code>@nonthreadsafe</code>（非线程安全）。<code>SystemTimer</code> 实现了接口 <code>Timer</code>，是基于 Kafka 时间轮设计的高性能定时器。</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><h3 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemTimer</span>(<span class="params">executorName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                  tickMs: <span class="type">Long</span> = 1,</span></span></span><br><span class="line"><span class="params"><span class="class">                  wheelSize: <span class="type">Int</span> = 20,</span></span></span><br><span class="line"><span class="params"><span class="class">                  startMs: <span class="type">Long</span> = <span class="type">Time</span>.<span class="type">SYSTEM</span>.hiResClockMs</span>) <span class="keyword">extends</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 线程池（任务执行器），固定大小为 1，也就是同时只能执行最多一个任务</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> taskExecutor = <span class="type">Executors</span>.newFixedThreadPool(<span class="number">1</span>, <span class="keyword">new</span> <span class="type">ThreadFactory</span>() &#123;</span><br><span class="line">    <span class="comment">// 自定义线程创建方式：非守护线程，指定 executorName 作为线程名后缀</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newThread</span></span>(runnable: <span class="type">Runnable</span>): <span class="type">Thread</span> =</span><br><span class="line">      <span class="type">KafkaThread</span>.nonDaemon(<span class="string">&quot;executor-&quot;</span>+executorName, runnable)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> delayQueue = <span class="keyword">new</span> <span class="type">DelayQueue</span>[<span class="type">TimerTaskList</span>]()</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> taskCounter = <span class="keyword">new</span> <span class="type">AtomicInteger</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> timingWheel = <span class="keyword">new</span> <span class="type">TimingWheel</span>(</span><br><span class="line">    tickMs = tickMs,</span><br><span class="line">    wheelSize = wheelSize,</span><br><span class="line">    startMs = startMs,</span><br><span class="line">    taskCounter = taskCounter,</span><br><span class="line">    delayQueue</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读写锁，保护时间轮运转（tick）时的相关数据结构</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> readWriteLock = <span class="keyword">new</span> <span class="type">ReentrantReadWriteLock</span>()</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> readLock = readWriteLock.readLock()</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> writeLock = readWriteLock.writeLock()</span><br></pre></td></tr></table></figure>

<p>主构造器 4 个参数第一个用于指定线程名称，后面三个用于构造时间轮。此外，所有时间轮（包括各个桶）共享一个延迟队列和任务计数器。<strong>多层时间轮共享的延迟队列</strong>就是这里的 <code>delayQueue</code>，调用 <code>poll</code> 时会将过期的桶弹出队列。</p>
<h3 id="细节-1：高精度时间戳计时"><a href="#细节-1：高精度时间戳计时" class="headerlink" title="细节 1：高精度时间戳计时"></a>细节 1：高精度时间戳计时</h3><p>注意到 <code>startMs</code> 是通过 <code>System.nanoTime()</code> 转换得到的高精度纳秒级时间戳：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Time</span> <span class="variable">SYSTEM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemTime</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemTime</span> <span class="keyword">implements</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">milliseconds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">hiResClockMs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TimeUnit.NANOSECONDS.toMillis(nanoseconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nanoseconds</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.nanoTime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之所以使用 <code>nanoTime</code> 是为了高精度计时，但是由于纳秒级时间戳超过了 64位 整型能表达的上限，所以得到的是溢出值（还有可能为负数），只能用于计算两个时间戳的时间间隔，而不能用作时间戳。因此在记录时间戳（比如 <code>Produce</code> 请求得到 <code>LogAppendTime</code> 时）以及对时间间隔精确性不敏感的地方都是用的 <code>currentMilliseconds</code> 方法计时。</p>
<h3 id="细节-2：KafkaThread"><a href="#细节-2：KafkaThread" class="headerlink" title="细节 2：KafkaThread"></a>细节 2：<code>KafkaThread</code></h3><p>Java 线程池屏蔽了线程的细节，用户只要提供了实现 <code>Runnable</code> 的类，即可通过 <code>execute</code> 或 <code>submit</code> 方法创建线程。出于灵活性考虑，Java 线程池也支持用户自定义 <code>ThreadFactory</code> 接口，实现 <code>newThread</code> 通过 <code>Runnable</code> 对象创建线程的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> KafkaThread <span class="title function_">nonDaemon</span><span class="params">(<span class="keyword">final</span> String name, Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaThread</span>(name, runnable, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">KafkaThread</span><span class="params">(<span class="keyword">final</span> String name, Runnable runnable, <span class="type">boolean</span> daemon)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(runnable, name);</span><br><span class="line">    configureThread(name, daemon);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">configureThread</span><span class="params">(<span class="keyword">final</span> String name, <span class="type">boolean</span> daemon)</span> &#123;</span><br><span class="line">    setDaemon(daemon);</span><br><span class="line">    setUncaughtExceptionHandler(<span class="keyword">new</span> <span class="title class_">UncaughtExceptionHandler</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught exception in thread &#x27;&#123;&#125;&#x27;:&quot;</span>, name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是通过 <code>KafkaThread</code> 类（位于 <code>org.apache.kafka.common.utils</code> 包下）的工厂方法创建的，关键的是设置了异常处理器，当线程函数中抛出意想不到的异常时，将其写入错误日志。</p>
<p>但是，仅当 <code>Runnable</code> 对象由 <code>execute</code> 执行时才会调用这个处理器，因为 <code>submit</code> 执行 <code>Runnable</code> 会返回 <code>Future&lt;?&gt;</code> 对象，只有调用 <code>Future</code> 对象的 <code>get</code> 方法时才会触发异常，这样用户就可以手动 <code>try-catch</code> 捕获异常，而不用自定义异常处理器。</p>
<p>而在 <code>SystemTimer</code> 中，任务是使用 <code>submit</code> 执行的，并且未处理返回的 <code>Future</code> 对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskExecutor.submit(timerTaskEntry.timerTask)</span><br></pre></td></tr></table></figure>

<p>因此，虽然 <code>KafkaThread</code> 设置了异常处理器，但是在这里，定时任务抛出的异常实际上被忽略了。</p>
<h2 id="Timer-接口实现"><a href="#Timer-接口实现" class="headerlink" title="Timer 接口实现"></a>Timer 接口实现</h2><h3 id="接口概览"><a href="#接口概览" class="headerlink" title="接口概览"></a>接口概览</h3><p><code>SystemTimer</code> 是基于 <code>TimingWheel</code> 实现的定时器，对外提供的功能即它所实现的接口 <code>Timer</code>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 添加新的任务到当前执行器（线程池），在任务过期后会执行任务。</span></span><br><span class="line"><span class="comment">    * @param timerTask 待添加的任务</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(timerTask: <span class="type">TimerTask</span>): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 推进内部时钟，执行任何在走过的时间间隔内过期的任务</span></span><br><span class="line"><span class="comment">    * @param timeoutMs</span></span><br><span class="line"><span class="comment">    * @return 是否有任务被执行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">advanceClock</span></span>(timeoutMs: <span class="type">Long</span>): <span class="type">Boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取得待执行的任务数量</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">size</span></span>: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭定时器服务，待执行的任务将不会被执行</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>(): <span class="type">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>size</code> 和 <code>shutdown</code> 的实现很简单，分别是取得 <code>taskCounter</code> 的值以及关闭线程池。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">size</span></span>: <span class="type">Int</span> = taskCounter.get</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>() &#123;</span><br><span class="line">  taskExecutor.shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="add"><a href="#add" class="headerlink" title="add"></a><code>add</code></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(timerTask: <span class="type">TimerTask</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  readLock.lock()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 通过任务的延时加上当前时间得到延时的具体时刻，作为定时任务的过期时间</span></span><br><span class="line">    addTimerTaskEntry(<span class="keyword">new</span> <span class="type">TimerTaskEntry</span>(timerTask, timerTask.delayMs + <span class="type">Time</span>.<span class="type">SYSTEM</span>.hiResClockMs))</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    readLock.unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">addTimerTaskEntry</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// 尝试将任务加入时间轮</span></span><br><span class="line">  <span class="keyword">if</span> (!timingWheel.add(timerTaskEntry)) &#123;</span><br><span class="line">    <span class="comment">// 仅当 任务已经过期 或者 任务主动取消 才会进入此分支</span></span><br><span class="line">    <span class="keyword">if</span> (!timerTaskEntry.cancelled) <span class="comment">// 任务过期则执行任务</span></span><br><span class="line">      taskExecutor.submit(timerTaskEntry.timerTask)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是将任务扔进时间轮中，添加失败只有可能是过期或者主动取消，这里额外判断了是否任务主动取消。</p>
<p>唯一值得注意的是这里用了读锁，按照常理，<code>add</code> 并不是读操作而是写操作，为什么是读锁呢？读锁意味着可以多线程同时调用 <code>add</code> 时无需上锁。这是因为 <code>TimingWheel.add</code> 是线程安全的，回顾下时间轮添加任务的流程：</p>
<ol>
<li><p>判断任务是否被取消</p>
<p>任务绑定的 <code>Entry</code> 是 <code>private[this]</code> 修饰的，也就是仅有当前对象能访问。因此只要不是两个相同任务，那么这个判断是线程安全的</p>
</li>
<li><p>判断过期时间处于那个桶，是否需要加入更高一级时间轮</p>
<p>所有桶的时间范围由 <code>currentTime</code>（即取整后的 <code>startMs</code>）、<code>tickMs</code>、<code>wheelSize</code> 决定的，而 <code>add</code> 方法并不会修改它们</p>
</li>
<li><p>将任务添加进桶：<code>TimeTaskList.add</code> 内部用内置锁保护了，线程安全；</p>
</li>
<li><p>设置桶的过期时间：调用原子变量的 <code>getAndSet</code> 方法，也是线程安全的。</p>
</li>
</ol>
<p>保证线程安全的策略是要么不修改内部状态，要么调用那些线程安全的方法，因此允许并发地 <code>add</code>。</p>
<h3 id="advanceClock"><a href="#advanceClock" class="headerlink" title="advanceClock"></a><code>advanceClock</code></h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">advanceClock</span></span>(timeoutMs: <span class="type">Long</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="comment">// 尝试在 timeoutMs 内取出完成的任务</span></span><br><span class="line">  <span class="keyword">var</span> bucket = delayQueue.poll(timeoutMs, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br><span class="line">  <span class="keyword">if</span> (bucket != <span class="literal">null</span>) &#123; <span class="comment">// 取出了过期的 bucket</span></span><br><span class="line">    writeLock.lock()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (bucket != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 推进当前时间轮，内部可能会递归推进更高一层时间轮，currentTime 被修改</span></span><br><span class="line">        timingWheel.advanceClock(bucket.getExpiration())</span><br><span class="line">        <span class="comment">// 取出 bucket 所有任务节点，将其传入 reinsert 方法</span></span><br><span class="line">        bucket.flush(reinsert)</span><br><span class="line">        <span class="comment">// 非阻塞地取出任务，将当前时点所有过期的 bucket 全部取出</span></span><br><span class="line">        bucket = delayQueue.poll()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      writeLock.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有 bucket 过期</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推进 <code>timeoutMs</code> 毫秒，尽可能取出此时所有过期的 bucket（<strong>问题 1 解决</strong>），然后调用 <code>flush</code> 将 bucket 中所有任务节点传入 <code>reinsert</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flush</span></span>(f: (<span class="type">TimerTaskEntry</span>)=&gt;<span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="keyword">var</span> head = root.next</span><br><span class="line">    <span class="keyword">while</span> (head ne root) &#123;</span><br><span class="line">      remove(head)</span><br><span class="line">      f(head)</span><br><span class="line">      head = root.next</span><br><span class="line">    &#125;</span><br><span class="line">    expiration.set(<span class="number">-1</span>L)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TimerTaskList.flush</code> 方法很简单，用内置锁保护，然后依次删除链表（bucket）所有节点，并应用到函数上，最后重置 <code>expiration</code> 以保证下次有任务加入该 bucket 时，该 bucket 会被加入延迟队列。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> reinsert = (timerTaskEntry: <span class="type">TimerTaskEntry</span>) =&gt; addTimerTaskEntry(timerTaskEntry)</span><br></pre></td></tr></table></figure>

<p><code>reinsert</code> 则是尝试将这些从 bucket 中删除的节点重新加入时间轮。</p>
<p>这里需要注意， bucket 过期时，内部节点也都过期了，因为 bucket 的过期时间是所有内部过期时间取整后得到的被 <code>tickMs</code> 整除的值。那为什么要这么做呢？</p>
<p>回顾我们开始提出的问题 2，如果取出的这个 bucket 是属于高层时间轮的，由于高层时间轮精度不够，此时 bucket 可能并未过期。</p>
<p>举个两层时间轮的例子（单位：毫秒）：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>buckets</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>[0,1)</code> <code>[1,2)</code></td>
</tr>
<tr>
<td>2</td>
<td><code>[0,2)</code> <code>[2,4)</code></td>
</tr>
</tbody></table>
<p>初始状态下，延时为 3 的任务被加入 <code>[2,4)</code>，调用 <code>advanceClock(2)</code> 后，时间轮变成了</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>buckets</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>[2,3)</code> <code>[3,4)</code></td>
</tr>
<tr>
<td>2</td>
<td><code>[2,4)</code> <code>[4,6)</code></td>
</tr>
</tbody></table>
<p>第 2 层的 <code>[2,4)</code> 被取出，然后延时为 3 的任务被取出，此时调用 <code>reinsert</code> 就会将其加入第 1 层的 <code>[3,4)</code>，而不是立刻判断它过期。至此，<strong>问题 2 解决</strong>，从高层时间轮降级到底层时间轮被隐藏在了这句不起眼的 <code>bucket.flush(reinsert)</code> 中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章阅读了 Kafka 高精度定时器 <code>SystemTimer</code> 的实现，它管理了延迟队列和时间轮，每次加入定时任务将任务扔进时间轮中，并将任务节点所在的 bucket 扔进延迟队列中。它本身的推进是通过延迟队列进行的，每次推进一段时间，尽可能取出到期的 bucket，并依次取出 bucket 的所有任务节点。通过将取出的任务节点重新加入到时间轮中，可能会将高层时间轮中过期任务转移到底层时间轮中。</p>
<p>此外，对于到期的任务，<code>SystemTimer</code> 使用仅包含单线程的线程池执行，若推进时又多个任务节点被取出，会等待前一个任务对应的线程完成后才会继续执行该任务（复用这个线程）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB11-%E6%97%B6%E9%97%B4%E8%BD%AETimingWheel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/04/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB11-%E6%97%B6%E9%97%B4%E8%BD%AETimingWheel/" class="post-title-link" itemprop="url">Kafka源码阅读11: 时间轮TimingWheel</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-04 21:40:43" itemprop="dateCreated datePublished" datetime="2020-02-04T21:40:43+08:00">2020-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一章阅读了各种延迟操作类的基类 <code>DelayedOperation</code>，而延迟操作对象会传入 <code>DelayedOperationPurgatory</code>，查看其构造参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">purgatoryName: <span class="type">String</span>,</span><br><span class="line">timeoutTimer: <span class="type">Timer</span>,</span><br><span class="line">brokerId: <span class="type">Int</span> = <span class="number">0</span>,</span><br><span class="line">purgeInterval: <span class="type">Int</span> = <span class="number">1000</span>,</span><br><span class="line">reaperEnabled: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">timerEnabled: <span class="type">Boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在 <code>ReplicaManager</code> 中是调用 <code>apply</code> 方法构造的，这里的 <code>timer</code> 使用 <code>util.timer.SystemTimer</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> timer = <span class="keyword">new</span> <span class="type">SystemTimer</span>(purgatoryName)</span><br></pre></td></tr></table></figure>

<p><code>SystemTimer</code>内部一个重要字段就是时间轮 <code>TimingWheel</code> 对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> timingWheel = <span class="keyword">new</span> <span class="type">TimingWheel</span>(</span><br><span class="line">  tickMs = tickMs,</span><br><span class="line">  wheelSize = wheelSize,</span><br><span class="line">  startMs = startMs,</span><br><span class="line">  taskCounter = taskCounter,</span><br><span class="line">  delayQueue</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p>实现在 <code>utils/timer/TimingWheel.scala</code> 中，这是 Kafka 精心设计的时间轮，因此关于该类的说明有长达 70 多行，这里首先阅读其设计思路。</p>
<h3 id="简单时间轮"><a href="#简单时间轮" class="headerlink" title="简单时间轮"></a>简单时间轮</h3><p>简单时间轮通常是时间任务桶的循环链表。令 u 为时间单元，一个大小为 n 的时间轮有 n 个桶，能够持有 <code>n * u</code> 个时间间隔的定时任务。</p>
<p>每个桶持有进入相应时间范围的定时任务。最开始，第一个桶持有 <code>[0, u)</code> 范围的任务，第二个桶持有 <code>[u, 2u)</code> 范围的任务……第 n 个桶持有 <code>[u * (n - 1), u * n)</code> 范围的任务。每过一个时间单元 u，定时器会 tick 并移动到下个桶，然后其中所有的定时任务都会过期。由于任务已经过期，此时定时器不会插入任务到当前桶中。定时器会立刻运行过期的任务。因为空桶在下一轮是可用的，所以如果当前的桶对应时间 t，那么它会在 tick 后变成 <code>[t + u * n, t + (n + 1) * u)</code> 的桶。</p>
<p>时间轮的插入&#x2F;删除（即启动&#x2F;停止定时器）的时间复杂度是 <code>O(1)</code>，而基于优先队列的定时器，比如 <code>java.util.concurrent.DelayQueue</code> 和 <code>java.util.Timer</code> 插入&#x2F;删除的时间复杂度是 <code>O(log n)</code>。</p>
<hr>
<p>本质上时间轮就是个哈希表，因此插入&#x2F;删除的时间复杂度是 <code>O(1)</code>，而哈希表的 value 类型是链表，插入&#x2F;删除的时间复杂度也是 <code>O(1)</code>，因此将定时任务 <code>TimerTaskEntry</code> 插入到时间轮&#x2F;从时间轮中删除的时间复杂度也是 <code>O(1)</code>。</p>
<h3 id="分层时间轮"><a href="#分层时间轮" class="headerlink" title="分层时间轮"></a>分层时间轮</h3><p>简单时间轮的主要缺点是它假设定时器请求是在从当前时刻开始的 <code>n * u</code> 时间间隔内，如果定时器请求超出了这个间隔就会产生溢出。分层时间轮会处理这种溢出，它以层次来组织时间轮，最底层的精度更高，层数越高，表示的精度更低。如果某一层时间轮的精度是 u，大小是 n，则更高一层的精度是 <code>n * u</code>。每一层的溢出会被委托给更高层的时间轮。当更高层的时间轮 tick 时，它会把定时任务插入到更底层。溢出的时间轮会按照需求来创建。当溢出的时间轮的桶过期时，其中所有任务会重新递归地插入到定时器中，之后这些任务会被移动到精度更高的时间轮中或者被执行。设 m 是时间轮的数量，则插入（启动定时器）的时间复杂度是 <code>O(m)</code>，相比起系统中请求的数量，通常是小很多的。而删除（停止定时器）的时间复杂度仍然是 <code>O(1)</code>。</p>
<hr>
<p>像时钟就是一个典型的三层时间轮，秒针能表示 0 到 59 秒，但是对 60 秒以上则需要分针进一步表示，再进一步即时针，一共能表示的时间范围为 0 到 43199 秒，精度为 1 秒。从秒针到分针到时针，表示精度是依次降低的，秒针精度为 1 秒，有 60 格，因此分针精度是 <code>1 * 60 = 60</code> 秒，类似地，时钟精度是 3600 秒。而上文用到的 tick 一词，则对应秒针&#x2F;分针&#x2F;时针的走动。</p>
<p>时间轮的每个时间间隔都对应了一个桶（bucket），即定时任务链表 <code>TimerTaskList</code>。根据每个定时任务的 timeout（过期时间），决定将任务分配给那个桶。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>令 <code>u = 1, n = 3</code>，设起始时刻是 c，则各层次的桶为</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>桶</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>[c,c]</code> <code>[c+1,c+1]</code> <code>[c+2,c+2]</code></td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td><code>[c,c+2]</code> <code>[c+3,c+5]</code> <code>[c+6,c+8]</code></td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td><code>[c,c+8]</code> <code>[c+9,c+17]</code> <code>[c+18,c+26]</code></td>
<td>9</td>
</tr>
</tbody></table>
<p>PS：这里沿用了代码注释里的表示，即闭区间，而前面讲述原理时都是左闭右开区间，两者是等价的，只是表示不一致。</p>
<p>在 <code>c+1</code> 时刻，桶 <code>[c,c]</code>、<code>[c,c+2]</code>、<code>[c,c+8]</code>过期了，之后：</p>
<ul>
<li>1 层的时钟移动到 <code>c+1</code>，并且创建新的桶 <code>[c+3,c+3]</code>；</li>
<li>2、3 层的时钟仍然在 c 处，因为他们的精度是 3 和 9。</li>
</ul>
<p>此时各层次的桶为：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>桶</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>[c+1,c+1]</code> <code>[c+2,c+2]</code> <code>[c+3,c+3]</code></td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td><code>[c,c+2]</code> <code>[c+3,c+5]</code> <code>[c+6,c+8]</code></td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td><code>[c,c+8]</code> <code>[c+9,c+17]</code> <code>[c+18,c+26]</code></td>
<td>9</td>
</tr>
</tbody></table>
<p>注意，桶 <code>[c,c+2]</code> 不会接收任何任务，因为此时时刻是 <code>c+1</code>，只有 timeout 为 <code>c+1</code> 和 <code>c+2</code> 才会被分配到该桶，然而 1 层的两个桶 <code>[c+1,c+1]</code> <code>[c+2,c+2]</code> 会优先接收任务。类似地，3 层的 <code>[c+1,c+8]</code> 也不会接收任何任务，因为这个范围被 2 层的桶覆盖了。</p>
<p>依次类推，在  <code>c+3</code> 时刻，2 层也会创建新的桶，各层次的桶为：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>桶</th>
<th>精度</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>[c+3,c+3]</code> <code>[c+4,c+4]</code> <code>[c+5,c+5]</code></td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td><code>[c+3,c+5]</code> <code>[c+6,c+8]</code> <code>[c+9,c+11]</code></td>
<td>3</td>
</tr>
<tr>
<td>3</td>
<td><code>[c,c+8]</code> <code>[c+9,c+17]</code> <code>[c+18,c+26]</code></td>
<td>9</td>
</tr>
</tbody></table>
<p>PS：这里源码的注释说 3 层的第 3 个桶是 <code>[c+8,c+11]</code>，看了下，大概是注释错误？</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="TimeWheel-的字段"><a href="#TimeWheel-的字段" class="headerlink" title="TimeWheel 的字段"></a><code>TimeWheel</code> 的字段</h3><p>主构造器的字段</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>tickMs</code></td>
<td><code>Long</code></td>
<td>每 tick 一次经过的毫秒数，即前文的时间单元 u</td>
</tr>
<tr>
<td><code>wheelSize</code></td>
<td><code>Int</code></td>
<td>时间轮大小，即前文的桶数 n</td>
</tr>
<tr>
<td><code>startMs</code></td>
<td><code>Long</code></td>
<td>毫秒级时间戳</td>
</tr>
<tr>
<td><code>taskCounter</code></td>
<td><code>AtomicInteger</code></td>
<td>任务数量，即所有桶（链表）中的节点数量之和</td>
</tr>
<tr>
<td><code>queue</code></td>
<td><code>DelayQueue[TimerTaskList]</code></td>
<td></td>
</tr>
</tbody></table>
<p>注意到这里还有个 <code>DelayQueue</code> 作为辅助，具体作用之后再看。</p>
<p>通过上述主构造参数可以计算出以下私有字段（<code>private[this]</code>，可以被包内其他类访问）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前时间轮的整个时间跨度，即更高一层时间轮的 tickMs</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> interval = tickMs * wheelSize</span><br><span class="line"><span class="comment">// 创建 wheelSize 个桶（定时任务链表）</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> buckets = <span class="type">Array</span>.tabulate[<span class="type">TimerTaskList</span>](wheelSize) &#123; _ =&gt; <span class="keyword">new</span> <span class="type">TimerTaskList</span>(taskCounter) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整，使起始时间戳能被 tickMs 整除</span></span><br><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> currentTime = startMs - (startMs % tickMs) <span class="comment">// rounding down to multiple of tickMs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 高一层时间轮，用来保存超过 interval 的任务</span></span><br><span class="line"><span class="meta">@volatile</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> overflowWheel: <span class="type">TimingWheel</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>注意这里做了取整，因此左闭右开区间 <code>[currentTime, currentTime + tickMs)</code>  即时间轮第一个桶的范围。</p>
<p>通过 <code>addOverflowWheel</code> 创建高一层时间轮：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">addOverflowWheel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) &#123; <span class="comment">// Double-Checked Locking 模式</span></span><br><span class="line">      overflowWheel = <span class="keyword">new</span> <span class="type">TimingWheel</span>(</span><br><span class="line">        tickMs = interval, <span class="comment">// 仅有此参数和之前不同，见分层时间轮一节的解释</span></span><br><span class="line">        wheelSize = wheelSize,</span><br><span class="line">        startMs = currentTime,</span><br><span class="line">        taskCounter = taskCounter,</span><br><span class="line">        queue</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="comment">// 定时任务的过期时间戳</span></span><br><span class="line">  <span class="keyword">val</span> expiration = timerTaskEntry.expirationMs</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timerTaskEntry.cancelled) &#123;</span><br><span class="line">    <span class="comment">// Entry 绑定的 TimerTask 调用了 cancel() 方法主动将 Entry 从链表中移除</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; currentTime + tickMs) &#123;</span><br><span class="line">    <span class="comment">// 过期时间在第一个桶的范围内，表示已经过期，此时无需加入时间轮</span></span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (expiration &lt; currentTime + interval) &#123;</span><br><span class="line">    <span class="comment">// 过期时间在当前时间轮能表示的时间范围内，加入到其中一个桶</span></span><br><span class="line">    <span class="comment">// 注意按照这个算法，第一个桶的时间范围是 [c+u,c+u*2)，因为 [c,c+u) 范围内被视为已过期</span></span><br><span class="line">    <span class="comment">// 而且第一个桶对应 buckets 的下标并不一定是 0，因为数组只是作为循环队列的存储方式，起始下标无所谓</span></span><br><span class="line">    <span class="keyword">val</span> virtualId = expiration / tickMs</span><br><span class="line">    <span class="keyword">val</span> bucket = buckets((virtualId % wheelSize.toLong).toInt)</span><br><span class="line">    bucket.add(timerTaskEntry)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置过期时间，这里也取整了，即可以被 tickMs 整除</span></span><br><span class="line">    <span class="keyword">if</span> (bucket.setExpiration(virtualId * tickMs)) &#123; <span class="comment">// 仅在新的过期时间和之前的不同才返回 true</span></span><br><span class="line">      <span class="comment">// 由于进行了取整，同一个 bucket 所有节点的过期时间都相同，因此仅在 bucket 的第一个节点加入时才会进入此 if 块</span></span><br><span class="line">      <span class="comment">// 因此保证了每个桶只会被加入一次到 queue 中，queue 存放所有包含定时任务节点的 bucket</span></span><br><span class="line">      <span class="comment">// 借助 DelayQueue 来检测 bucket 是否过期，bucket 时遍历即可取出所有节点</span></span><br><span class="line">      queue.offer(bucket)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 过期时间在当前时间轮表示的范围之外，即溢出，需要创建高一层时间轮来加入</span></span><br><span class="line">    <span class="keyword">if</span> (overflowWheel == <span class="literal">null</span>) addOverflowWheel() <span class="comment">// 双重检查上锁的第一层检查</span></span><br><span class="line">    overflowWheel.add(timerTaskEntry) <span class="comment">// 注意高一层时间轮也可能无法容纳，因此可能会递归创建更高层级的时间轮</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要知识点在前面的设计思路中都讲到了，可以看到 <code>DelayQueue</code> 对象 <code>queue</code> 在时间轮的作用是，保存包含定时任务节点的桶，桶可以来自不同层次的时间轮，当然，所有层次时间轮也共享这个队列。</p>
<p><code>TimeWheel</code> 本身没有实现 tick 功能，而是借助延迟队列 <code>DelayQueue</code> 来实现时间的推移，假设有 M 个定时任务分布在 N 个桶中，那么插入的时间复杂度为 <code>O(M + N * log N)</code>，其中 <code>M &gt;= N</code>。如果把任务全存到延迟队列中，那么插入的时间复杂度为 <code>O(M * log M)</code>，因此 Kafka 时间轮的优化是有意义的。</p>
<p>比如对于 1 层时间轮的 3 个桶：<code>[0,4)</code>，<code>[4,8)</code>，<code>[8,12)</code>，有以下过期时间的定时任务：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>那么会向 <code>queue</code> 中插入 2 个桶，然后利用 <code>queue</code> 依次弹出 2 个桶，通过遍历弹出每个桶的节点：</p>
<ul>
<li>时刻 0：弹出节点 1,2,3；</li>
<li>时刻 8：弹出节点 8,9,10,11。</li>
</ul>
<h3 id="删除定时任务"><a href="#删除定时任务" class="headerlink" title="删除定时任务"></a>删除定时任务</h3><p>再再再次回顾，延迟操作 <code>DelayedOperation</code> 对象，继承自定时任务 <code>TimerTask</code> 接口，而 <code>TimerTask</code> 会绑定一个 <code>TimerTaskEntry</code> 节点，每个节点位于唯一对应的链表 <code>TimerTaskList</code> （即 bucket）上。</p>
<p>定时任务的删除即调用 <code>TimerTaskList.remove</code> 方法（<code>TimerTaskEntry.remove</code> 也会调用该方法），有以下几种可能：</p>
<ul>
<li>延时操作对象主动调用 <code>cancel</code> 和节点解绑，解绑后的节点也无法加入到 bucket 中；</li>
<li>当前 bucket 上的节点被另一个 bucket 调用 <code>add</code> 方法，此时会先从当前 bucket 上移除该节点。</li>
</ul>
<h3 id="时间轮的转动"><a href="#时间轮的转动" class="headerlink" title="时间轮的转动"></a>时间轮的转动</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">advanceClock</span></span>(timeMs: <span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (timeMs &gt;= currentTime + tickMs) &#123; <span class="comment">// timeMs 超过了当前 bucket 的时间范围</span></span><br><span class="line">    currentTime = timeMs - (timeMs % tickMs) <span class="comment">// 修改当前时间，即原先的第一个桶已经失效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若存在更高层的时间轮，则也会向前运转</span></span><br><span class="line">    <span class="keyword">if</span> (overflowWheel != <span class="literal">null</span>) overflowWheel.advanceClock(currentTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文叙述了 Kafka 分层时间轮的设计思路，并阅读了其源码实现，在 Kafka 这种需要处理大量异步任务（延时请求、定时任务，都可以视为等价的概念）的系统上，基于优先级队列的 <code>DelayQueue</code> 性能不够高，因此 Kafka 借助了时间轮的思想，将同一个时间范围内的异步任务放到一个桶中，进一步将桶放入优先级队列。核心思想是同一个时间区间范围的多个任务，只需要加入一次到优先级队列中。</p>
<p>底层数据结构是：</p>
<ul>
<li>定长数组实现循环队列，来模拟时间轮；</li>
<li>时间轮的每个 bucket（即数组元素）为链表，链表上每个节点对应一个定时任务；</li>
<li>多层时间轮通过单个时间轮的链表来实现。</li>
</ul>
<p>顺便，本文留下了一个问题，那就是 <code>queue</code> 调用了 <code>offer</code> 方法将 bucket 加入到队列中，但是在 <code>TimeWheel.scala</code> 源码中，没有看到 <code>queue</code> 调用 <code>poll</code> 方法弹出 bucket。</p>
<p>此外，设计思路部分前文提到的了：</p>
<blockquote>
<p>当更高层的时间轮 tick 时，它会把定时任务插入到更底层。</p>
</blockquote>
<p>如何降级，在 <code>TimingWheel</code> 中没有体现。</p>
<p>其实这些是在 <code>SystemTimer</code> 中实现的，它进一步包装了 <code>TimingWheel</code>，也是 <code>kafka.utils.timer</code> 包中唯一暴露给外部的类，下一篇文章将会阅读其实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB10-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9CDelayedOperation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB10-%E5%BB%B6%E8%BF%9F%E6%93%8D%E4%BD%9CDelayedOperation/" class="post-title-link" itemprop="url">Kafka源码阅读10: 延迟操作DelayedOperation</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-20 14:10:18" itemprop="dateCreated datePublished" datetime="2020-01-20T14:10:18+08:00">2020-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前阅读了 Produce 和 Fetch 请求的实现，对于需要耗时处理的网络请求，都是利用 <code>DelayedOperation</code> 和 <code>DelayedOperationPurgatory</code> 来进行异步延迟操作，防止阻塞 <code>KafkaRequestHandler</code> 线程。</p>
<p>比如处理 Produce 请求时，<code>ReplicaManager.appendRecords</code> 方法在 ack 为 -1，有数据发送且有至少有一个分区的 append 操作成功时：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> delayedProduce = <span class="keyword">new</span> <span class="type">DelayedProduce</span>(timeout, produceMetadata, <span class="keyword">this</span>, responseCallback, delayedProduceLock)</span><br><span class="line"><span class="keyword">val</span> producerRequestKeys = entriesPerPartition.keys.map(<span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(_)).toSeq</span><br><span class="line">delayedProducePurgatory.tryCompleteElseWatch(delayedProduce, producerRequestKeys)</span><br></pre></td></tr></table></figure>

<p>再比如，处理 Fetch 请求时，<code>ReplicaManager.fetchMessages</code> 方法在 timeout 大于 0，读取本地数据没出错且响应积攒的字节数足够多时：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> delayedFetch = <span class="keyword">new</span> <span class="type">DelayedFetch</span>(timeout, fetchMetadata, <span class="keyword">this</span>, quota, isolationLevel, responseCallback)</span><br><span class="line"><span class="keyword">val</span> delayedFetchKeys = fetchPartitionStatus.map &#123; <span class="keyword">case</span> (tp, _) =&gt; <span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(tp) &#125;</span><br><span class="line">delayedFetchPurgatory.tryCompleteElseWatch(delayedFetch, delayedFetchKeys)</span><br></pre></td></tr></table></figure>

<p>用法很类似，首先创建 DelayedXXX 对象，然后对每个分区都创建 <code>TopicPartitionOperationKey</code> 对象组成 <code>Seq</code>，将两者传入 purgatory 中进行 tryXXX 操作，从命名和注释可以猜到，这个操作是尝试完全请求，就像 Scala 的 <code>Promise</code> 类的 <code>tryComplete</code> 方法一样，异步操作的常见模式就是下面两个非阻塞操作：</p>
<ol>
<li>启动一个任务异步执行，然后当前线程该干嘛干嘛；</li>
<li>想要确认任务是否执行结束时，看一眼，如果结束了就取得结果。</li>
</ol>
<p>不过除了确认操作（Operation）是否完成外，还会在没有完成的时候，监控（Watch）相应的延迟操作。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryCompleteElseWatch</span></span>(operation: <span class="type">T</span>, watchKeys: <span class="type">Seq</span>[<span class="type">Any</span>]): <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* used by delayed-produce and delayed-fetch operations */</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPartitionOperationKey</span>(<span class="params">topic: <span class="type">String</span>, partition: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">DelayedOperationKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(topicPartition: <span class="type">TopicPartition</span>) = <span class="keyword">this</span>(topicPartition.topic, topicPartition.partition)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">keyLabel</span> </span>= <span class="string">&quot;%s-%d&quot;</span>.format(topic, partition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 Key 可以是任意类型，只要实现了 <code>keyLabel</code> 方法，主题和分区组成的 Key 是用于延迟的 Produce 和 Fetch 操作，而对于其它请求&#x2F;操作则用的其它类型的 Key，比如 JoinGroup 操作用 group id 和 consumer id 组成 Key。</p>
<p>通过前面的源码阅读可知，Produce 和 Fetch 请求全程都是按照分区去处理，也就是每个分区对应一个类型，然后对这个类型进行 map, filter 等等，所以这里传入 purgatory 的 key 可以唯一标识延迟处理的数据，比如 Fetch 操作中需要处理的 <code>FetchMetadata</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchMetadata</span>(<span class="params">/* 其它字段... */</span></span></span><br><span class="line"><span class="params"><span class="class">                         // key: 分区; value: 获取分区的状态</span></span></span><br><span class="line"><span class="params"><span class="class">                         fetchPartitionStatus: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchPartitionStatus</span></span>)]) </span></span><br></pre></td></tr></table></figure>

<h2 id="DelayOperation"><a href="#DelayOperation" class="headerlink" title="DelayOperation"></a>DelayOperation</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>首先看看 <code>DelayedOperationPurgatory</code> 类及其 <code>tryCompleteElseWatch</code> 方法的完整签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedOperationPurgatory</span>[<span class="type">T</span> &lt;: <span class="type">DelayedOperation</span>](<span class="params">/* ... */</span>)</span></span><br><span class="line">        <span class="keyword">extends</span> <span class="type">Logging</span> <span class="keyword">with</span> <span class="type">KafkaMetricsGroup</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">tryCompleteElseWatch</span></span>(operation: <span class="type">T</span>, watchKeys: <span class="type">Seq</span>[<span class="type">Any</span>]): <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>

<p>参数 1 是泛型参数 <code>T</code>，该类型必须继承自 <code>DelayedOperation</code>，该类型是抽象类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedOperation</span>(<span class="params">override val delayMs: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    lockOpt: <span class="type">Option</span>[<span class="type">Lock</span>] = <span class="type">None</span></span>) <span class="keyword">extends</span> <span class="title">TimerTask</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>设置了毫秒级延时 <code>delayMs</code> 以及可选的锁 <code>lockOpt</code>。要实现一个延迟操作，也就是继承 <code>DelayedOperation</code> 类并重写（override）以下抽象方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回调: 当延迟操作过期时执行, 因此 delayMs 到期时会强制完成</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onExpiration</span></span>(): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调: 当操作完成时执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onComplete</span></span>(): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查现在操作是否已经完成:</span></span><br><span class="line"><span class="comment">// 1. 已完成, 则调用 forceComplete() 并返回 true 如果 forceComplete 返回 true;</span></span><br><span class="line"><span class="comment">// 2. 否则返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tryComplete</span></span>(): <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>

<p>此外提供了原子 <code>Boolean</code> 类型的字段来标识是否完成</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> completed = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isCompleted</span></span>: <span class="type">Boolean</span> = completed.get()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forceComplete</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (completed.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">    cancel() <span class="comment">// 调用基类 TimerTask 的方法取消当前定时任务</span></span><br><span class="line">    onComplete() <span class="comment">// 执行派生类自定义的回调</span></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该原子变量是在 <code>forceComplete</code> 中设置为 true 的，可能有多个线程尝试完成同一个任务，由于是执行原子 <code>Boolean</code> 的 CAS 操作，只有第一个线程会返回 true，<code>onComplete()</code> 回调只会被调用一次。</p>
<p>前面的注释也提过，简单查看 <code>DelayedProduce</code> 和 <code>DelayedFetch</code> 的 <code>tryComplete()</code> 实现也能看到，每个代表任务已完成的分支，都会将 <code>forceComplete()</code> 的返回值作为 <code>tryComplete()</code> 的返回值。</p>
<p>此外，基类 <code>TimerTask</code> 继承自 <code>Runnable</code> 接口，因此 <code>DelayedOperation</code> 可以作为线程被启动，执行 <code>run()</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (forceComplete())</span><br><span class="line">    onExpiration()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果任务未完成，则强制完成（期间会执行 <code>onComplete</code> 回调），并执行 <code>onExpiration</code> 回调。相当于多了个对超时的处理，因此可以猜测会在过期时启动线程来执行超时回调。</p>
<h3 id="maybeTryComplete"><a href="#maybeTryComplete" class="headerlink" title="maybeTryComplete"></a>maybeTryComplete</h3><p>该方法是 server 包私有的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[server] <span class="function"><span class="keyword">def</span> <span class="title">maybeTryComplete</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> retry = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">      <span class="comment">// 上锁成功, 直接调用 tryComplete</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        tryCompletePending.set(<span class="literal">false</span>)</span><br><span class="line">        done = tryComplete()</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 此时可能另外一个线程调用了 `maybeTryComplete` 并将 `tryCompletePending` 置为 true(在此之前已经设为了 false)</span></span><br><span class="line">      <span class="comment">// 因此 retry 为 true 就代表这种情况发生, 此时会触发重试条件, 继续 while 循环</span></span><br><span class="line">      retry = tryCompletePending.get()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 上锁失败, 说明另一个线程持有锁</span></span><br><span class="line">      <span class="comment">// 如果此时 `tryCompletePending` 为 true, 那么持锁线程必然看到了 true 并且重试, 那么当前线程可以退出。</span></span><br><span class="line">      <span class="comment">// 否则持锁线程正在 `tryComplete`, 此时将其设为 true 因为持锁线程可能在 `tryCompletePending` 设为 true 的时候返回</span></span><br><span class="line">      retry = !tryCompletePending.getAndSet(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (!isCompleted &amp;&amp; retry)</span><br><span class="line">  done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来有点绕，分情况讨论。</p>
<ol>
<li>单线程：调用 <code>tryComplete</code> 后退出循环，因为自己将 <code>tryCompletePending</code> 置为了 false，解锁后<code>retry</code> 为false，此时和直接 <code>tryComplete</code> 无异；</li>
<li>双线程：记为 A 和 B，假设 A 上锁成功，且在 <code>tryComplete</code> 检查完成状态的时候 B 上锁失败，那么 B 将 <code>tryCompletePending</code> 置为 true，这会导致两种情况：<ul>
<li>A <code>tryComplete</code> 成功，代表 <code>onComplete</code> 已被调用，<code>isCompleted</code> 为 true，A 和 B 都会退出循环；</li>
<li>A <code>tryComplete</code> 失败，<code>isCompleted</code> 为 false，由于 <code>tryCompletePending</code> 被 B 置为 false，A 的 <code>retry</code> 为 true，而由于不存在其它等待线程，所以 B 在 <code>getAndSet</code> 时得到的值（赋给 <code>retry</code>）也是 true，A 和 B 重新争夺锁，也就是说至少会再调用一次 <code>tryComplete</code>。</li>
</ul>
</li>
<li>三个以上线程：存在 1 个持锁线程和 N 个等待线程（N &gt; 1），<code>getAndSet</code> 是原子操作，也就是说 N 个等待线程只有 1 个等待线程的 <code>retry</code> 会被置为 true，其它线程都因为第一个调用 <code>getAndSet</code> 的等待线程将 <code>tryCompletePending</code> 置为 false 时退出，此时和双线程的情况无异。</li>
</ol>
<p>核心就是双线程的情况，这种做法是为了针对这种场景：线程 A 检查完成状态的时候，此时还未完成，而线程 B 检查完成状态的时候，虽然实际已经完成了，但由于线程 A 正持有锁，B 不会检查状态。这种做法能让无论线程 A 还是 B，都会再调用一次 <code>tryComplete</code> 检查是否完成了。</p>
<p>举个例子，假设状态由 1 个 <code>Boolean</code> 表示，只有都为 <code>true</code> 时才算完成。如果不这么设计，那就可能出现下面的情况：</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>状态</th>
<th>线程 A</th>
<th>线程 B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>false</td>
<td>上锁</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>false</td>
<td>取得状态 false</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>true</td>
<td>判断状态（已经是旧的状态）是否为 true</td>
<td>上锁失败，不检查状态</td>
</tr>
<tr>
<td>4</td>
<td>true</td>
<td>返回 false</td>
<td>返回 false</td>
</tr>
</tbody></table>
<p>而现在的做法就是在第 4 步，让线程 A 和 B 再次竞争 <code>tryComplete</code> 的机会，至少有一个线程能检查新的状态。</p>
<h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p><code>DelayedOperation.forceComplete</code> 有一个关键的 <code>cancel()</code> 调用来自于基类 <code>TimerTask</code>，从源码注释可知，这个方法是取消 timeout 计时器，即强行停止耗时超过 <code>delayedMs</code> 的延时任务。这个方法是在基类 <code>TimerTask</code> 中实现的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> timerTaskEntry: <span class="type">TimerTaskEntry</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cancel</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="keyword">if</span> (timerTaskEntry != <span class="literal">null</span>) timerTaskEntry.remove()</span><br><span class="line">    timerTaskEntry = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上是调用了 <code>TimerTaskEntry.remove</code> 方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[timer] <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskEntry</span>(<span class="params">val timerTask: <span class="type">TimerTask</span>, val expirationMs: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">TimerTaskEntry</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@volatile</span></span><br><span class="line">  <span class="keyword">var</span> list: <span class="type">TimerTaskList</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> currentList = list</span><br><span class="line">    <span class="comment">// 如果另一个线程将当前节点从一个链表移动到另一个链表，由于 list 会被修改成新链表的引用</span></span><br><span class="line">    <span class="comment">// 所以 remove 会失败，因此在这里用 currentList 暂存之前链表的引用，这样就避免锁住整个 list</span></span><br><span class="line">    <span class="comment">// 单线程: list.remove(this) 会将 this.list 置为 null, 移除后退出循环；</span></span><br><span class="line">    <span class="comment">// 多线程: 如果 this.list 被其它线程修改指向了新的链表, 那么循环会继续, 将该节点从新链表移除</span></span><br><span class="line">    <span class="comment">// 一个罕见场景: 线程 B 将该节点从链表 A 移除加入链表 B, 但是在修改节点的 list 之前, 线程 A</span></span><br><span class="line">    <span class="comment">// 就移除成功了, 获取的 list 为 null, 退出循环, 之后线程 B 将节点加入链表 B</span></span><br><span class="line">    <span class="keyword">while</span> (currentList != <span class="literal">null</span>) &#123;</span><br><span class="line">      currentList.remove(<span class="keyword">this</span>)</span><br><span class="line">      currentList = list</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>TimerTaskEntry</code> 是 <code>TimerTaskList</code> （定时任务链表）上的一个<strong>节点（Entry）</strong>，内部维护了链表的引用，调用 <code>remove</code> 即将当前节点从链表上移除。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123; <span class="comment">// 保护多线程 remove 和 add</span></span><br><span class="line">    timerTaskEntry.synchronized &#123; <span class="comment">// 保护单个节点的 add 和 remove</span></span><br><span class="line">      <span class="keyword">if</span> (timerTaskEntry.list eq <span class="keyword">this</span>) &#123; <span class="comment">// 确认当前节点还在当前链表上才移除</span></span><br><span class="line">        timerTaskEntry.next.prev = timerTaskEntry.prev</span><br><span class="line">        timerTaskEntry.prev.next = timerTaskEntry.next</span><br><span class="line">        timerTaskEntry.next = <span class="literal">null</span></span><br><span class="line">        timerTaskEntry.prev = <span class="literal">null</span></span><br><span class="line">        timerTaskEntry.list = <span class="literal">null</span></span><br><span class="line">        taskCounter.decrementAndGet()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可见 <code>TimerTaskList</code> 是双向链表，移除节点时会锁住该节点，然后修改其 <code>prev</code> 和 <code>next</code>，并维护了原子变量的 <code>taskCounter</code> 记录任务节点的数量。除了 <code>remove</code> 外只有 <code>add</code> 方法会在多线程下造成 race condition，因此要加锁。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(timerTaskEntry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">var</span> done = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">    <span class="comment">// 如果节点存在于另一个链表中, 将其删除从而保证一个节点只被一个链表拥有</span></span><br><span class="line">    <span class="comment">// 这里不加锁是因为 remove 也会调用 synchronized, 会造成死锁, remove 本身</span></span><br><span class="line">    <span class="comment">// 会反复重试直到节点的链表为 null</span></span><br><span class="line">    timerTaskEntry.remove()</span><br><span class="line"></span><br><span class="line">    synchronized &#123; <span class="comment">// 保护多线程 add</span></span><br><span class="line">      timerTaskEntry.synchronized &#123; <span class="comment">// 保护单个节点的 add 和 remove</span></span><br><span class="line">        <span class="keyword">if</span> (timerTaskEntry.list == <span class="literal">null</span>) &#123; <span class="comment">// 确认当前节点已经成功被 remove</span></span><br><span class="line">          <span class="keyword">val</span> tail = root.prev</span><br><span class="line">          timerTaskEntry.next = root</span><br><span class="line">          timerTaskEntry.prev = tail</span><br><span class="line">          timerTaskEntry.list = <span class="keyword">this</span></span><br><span class="line">          tail.next = timerTaskEntry</span><br><span class="line">          root.prev = timerTaskEntry</span><br><span class="line">          taskCounter.incrementAndGet()</span><br><span class="line">          done = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：这里似乎锁住单个节点没必要，因为 <code>add</code> 和 <code>remove</code> 本身都已经上锁了，大概是防止将来有其它方法直接修改节点的字段吧，毕竟节点的字段（这里主要指<code>list</code>）都不是私有的。（虽然我看到的对 <code>list</code> 的修改也就只在 <code>add</code>&#x2F;<code>remove</code> 方法中）。</p>
<p>总之，这里单独实现的 <code>TimerTaskList</code>，除了实现了线程安全的增删操作外，主要是保证了链表上的节点（对应一个定时任务）是对应唯一的链表的，主要是为了保证节点在从链表 A 迁移到链表 B 时，不会继续留存在 A 中。</p>
<p><code>TimerTask</code> 会绑定一个 <code>TimerTaskEntry</code> 类型的节点，该节点位于 <code>TimerTaskList</code> 类型的双向链表上，链表包含一个字段：<code>expirationMs</code>，即任务的毫秒级 timeout。任务链表在源码注释中也被称为 <strong>bucket（桶）</strong>，其本身也有一个原子类型的 <code>expiration</code> 字段代表任务链表本身的 timeout，提供了 setter 和 getter，需要注意的是 setter 返回的是 <code>Boolean</code> 而非 <code>Unit</code>，为 true 时则代表 <code>expiration</code> 发生了变化。</p>
<p><code>TimerTask</code>  在绑定新的 <code>TimerTaskEntry</code> 时，如果和之前的节点不一样，也会将其移除：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[timer] <span class="function"><span class="keyword">def</span> <span class="title">setTimerTaskEntry</span></span>(entry: <span class="type">TimerTaskEntry</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  synchronized &#123;</span><br><span class="line">    <span class="comment">// if this timerTask is already held by an existing timer task entry,</span></span><br><span class="line">    <span class="comment">// we will remove such an entry first.</span></span><br><span class="line">    <span class="keyword">if</span> (timerTaskEntry != <span class="literal">null</span> &amp;&amp; timerTaskEntry != entry)</span><br><span class="line">      timerTaskEntry.remove()</span><br><span class="line"></span><br><span class="line">    timerTaskEntry = entry</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在创建定时任务节点时，会自动和构造参数的 <code>TimerTask</code> 对象绑定：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[timer] <span class="class"><span class="keyword">class</span> <span class="title">TimerTaskEntry</span>(<span class="params">val timerTask: <span class="type">TimerTask</span>, val expirationMs: <span class="type">Long</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">TimerTaskEntry</span>] </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// if this timerTask is already held by an existing timer task entry,</span></span><br><span class="line">  <span class="comment">// setTimerTaskEntry will remove it.</span></span><br><span class="line">  <span class="keyword">if</span> (timerTask != <span class="literal">null</span>) timerTask.setTimerTaskEntry(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>延时操作（<code>DelayedOperation</code>）是一个抽象基类，继承自定时任务（<code>TimerTask</code>），由派生类实现以下方法：</p>
<ul>
<li>任务完成的回调；</li>
<li>任务超时的回调；</li>
<li>非阻塞地确认任务是否完成。</li>
</ul>
<p>每个延时操作都是一个定时任务（<code>TimerTask</code>），对应一个定时任务节点（<code>TimerTaskEntry</code>），而每个任务节点都是存在一个 bucket（定时任务链表，<code>TimerTaskList</code>）上的。通过线程安全的 <code>remove</code> 和 <code>add</code> 操作可以让节点从一个 bucket 移动到另一个 bucket，整个过程中节点都始终对应唯一的 bucket，不可能被多个 bucket 共享。这使得任务能安全地在多个 bucket 之间迁移。也就是接下来要阅读的时间轮 <code>TimeWheel</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/13/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB09-Fetch%E8%AF%B7%E6%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/13/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB09-Fetch%E8%AF%B7%E6%B1%82/" class="post-title-link" itemprop="url">Kafka源码阅读09: Fetch请求</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-13 12:55:45" itemprop="dateCreated datePublished" datetime="2020-01-13T12:55:45+08:00">2020-01-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Fetch协议"><a href="#Fetch协议" class="headerlink" title="Fetch协议"></a>Fetch协议</h2><p>Fetch API用于为某些分区获取日志，逻辑上它指定<strong>主题</strong>，<strong>分区</strong>和<strong>起始offset</strong>来取得消息，消息格式参考<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html#The_Messages_Fetch">The Messages Fetch</a></p>
<h2 id="KafkaApis-handleFetchRequest"><a href="#KafkaApis-handleFetchRequest" class="headerlink" title="KafkaApis.handleFetchRequest"></a>KafkaApis.handleFetchRequest</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> versionId = request.header.apiVersion</span><br><span class="line"><span class="keyword">val</span> clientId = request.header.clientId</span><br><span class="line"><span class="keyword">val</span> fetchRequest = request.body[<span class="type">FetchRequest</span>]</span><br><span class="line"><span class="keyword">val</span> fetchContext = fetchManager.newContext(fetchRequest.metadata(),</span><br><span class="line">  fetchRequest.fetchData(),</span><br><span class="line">  fetchRequest.toForget(),</span><br><span class="line">  fetchRequest.isFromFollower()) <span class="comment">// replicaId &gt;= 0, 即非负id代表fetch请求来自follower</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> erroneous = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>)]() <span class="comment">// 分区 -&gt; 响应</span></span><br><span class="line"><span class="keyword">val</span> interesting = mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchRequest</span>.<span class="type">PartitionData</span>)]() <span class="comment">// 分区 -&gt; 请求</span></span><br><span class="line"><span class="keyword">if</span> (fetchRequest.isFromFollower()) &#123; <span class="comment">// fetch 请求来自于 follower</span></span><br><span class="line">  <span class="keyword">if</span> (authorize(request.session, <span class="type">ClusterAction</span>, <span class="type">Resource</span>.<span class="type">ClusterResource</span>)) &#123;</span><br><span class="line">    <span class="comment">// 认证成功，判断请求的每个分区是否存在，若存在则将分区对应的请求加入 interesting 中</span></span><br><span class="line">    <span class="comment">// 否则则构造错误响应加入 erroneous</span></span><br><span class="line">    fetchContext.foreachPartition((part, data) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!metadataCache.contains(part.topic)) &#123;</span><br><span class="line">        erroneous += part -&gt; <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>,</span><br><span class="line">          <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">          <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        interesting += (part -&gt; data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 认证失败，对所有分区都构造错误响应加入 erroneous</span></span><br><span class="line">    fetchContext.foreachPartition((part, data) =&gt; &#123;</span><br><span class="line">      erroneous += part -&gt; <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// fetch 请求来自于客户端（消费者），和之前处理一样，认证失败或者分区不存在则构造错误响应</span></span><br><span class="line">  fetchContext.foreachPartition((part, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!authorize(request.session, <span class="type">Read</span>, <span class="keyword">new</span> <span class="type">Resource</span>(<span class="type">Topic</span>, part.topic)))</span><br><span class="line">      erroneous += part -&gt; <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(part.topic))</span><br><span class="line">      erroneous += part -&gt; <span class="keyword">new</span> <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_HIGHWATERMARK</span>, <span class="type">FetchResponse</span>.<span class="type">INVALID_LAST_STABLE_OFFSET</span>,</span><br><span class="line">        <span class="type">FetchResponse</span>.<span class="type">INVALID_LOG_START_OFFSET</span>, <span class="literal">null</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      interesting += (part -&gt; data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见主要是调用<code>authorize</code>方法进行 ACL 认证，以及查询<code>metadataCache</code>判断请求的分区是否存在。对于 follower，认证是基于整个请求的，操作是<code>ClusterAction</code>；对于 consumer，认证是基于每个分区的，类型是<code>Read</code>。</p>
<p>只有经过认证且存在于<code>metadataCache</code>的分区对应的请求会加入<code>interesting</code>中，其它分区会构造一个默认的不合法响应加入<code>erroneous</code>中。</p>
<p>接下来定义了如下回调函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convertedPartitionData</span></span>(tp: <span class="type">TopicPartition</span>, data: <span class="type">FetchResponse</span>.<span class="type">PartitionData</span>): <span class="type">FetchResponse</span>.<span class="type">PartitionData</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processResponseCallback</span></span>(responsePartitionData: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchPartitionData</span>)])</span><br></pre></td></tr></table></figure>

<p>然后调用<code>ReplicaManager.fetchMessages</code>方法对 <code>interesting</code> 请求进行处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (interesting.isEmpty)</span><br><span class="line">  processResponseCallback(<span class="type">Seq</span>.empty)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  replicaManager.fetchMessages(</span><br><span class="line">    fetchRequest.maxWait.toLong, <span class="comment">// 最大等待时间，毫秒</span></span><br><span class="line">    fetchRequest.replicaId, <span class="comment">// 副本 id，客户端为 Consumer 则为 -1</span></span><br><span class="line">    fetchRequest.minBytes, <span class="comment">// 响应中积攒的最小字节数</span></span><br><span class="line">    fetchRequest.maxBytes, <span class="comment">// 响应中积攒的最大字节数</span></span><br><span class="line">    versionId &lt;= <span class="number">2</span>, <span class="comment">// maxBytes 字段是从 V3 才引入的，因此判断 API 版本以兼容旧版本请求</span></span><br><span class="line">    interesting, <span class="comment">// 通过认证且分区存在的请求</span></span><br><span class="line">    replicationQuota(fetchRequest),</span><br><span class="line">    processResponseCallback, <span class="comment">// 处理响应的回调</span></span><br><span class="line">    fetchRequest.isolationLevel)</span><br></pre></td></tr></table></figure>

<h2 id="ReplicaManager-fetchMessages"><a href="#ReplicaManager-fetchMessages" class="headerlink" title="ReplicaManager.fetchMessages"></a>ReplicaManager.fetchMessages</h2><h3 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h3><p>方法说明：从 leader 副本取得消息，等待足够数据可以获取。一旦超时或者请求条件被满足则回调被调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetchMessages</span></span>(timeout: <span class="type">Long</span>,</span><br><span class="line">                  replicaId: <span class="type">Int</span>,</span><br><span class="line">                  fetchMinBytes: <span class="type">Int</span>,</span><br><span class="line">                  fetchMaxBytes: <span class="type">Int</span>,</span><br><span class="line">                  hardMaxBytesLimit: <span class="type">Boolean</span>,</span><br><span class="line">                  fetchInfos: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">PartitionData</span>)],</span><br><span class="line">                  quota: <span class="type">ReplicaQuota</span> = <span class="type">UnboundedQuota</span>,</span><br><span class="line">                  responseCallback: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">FetchPartitionData</span>)] =&gt; <span class="type">Unit</span>,</span><br><span class="line">                  isolationLevel: <span class="type">IsolationLevel</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> isFromFollower = <span class="type">Request</span>.isValidBrokerId(replicaId) <span class="comment">// replicaId &gt;= 0 (Follower) 则为 true</span></span><br><span class="line">  <span class="comment">// replica id 不为 -2 (debugging) 和 -3 (future local) 则为 true, 即正常 Fetch 请求都只从 leader 获取</span></span><br><span class="line">  <span class="keyword">val</span> fetchOnlyFromLeader = replicaId != <span class="type">Request</span>.<span class="type">DebuggingConsumerId</span> &amp;&amp; replicaId != <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span></span><br><span class="line">  <span class="comment">// replica id 为 -1 (Consumer) 且不为 -3 (future local) 则为 true, 即 Consumer 仅获取已提交的 offsets</span></span><br><span class="line">  <span class="keyword">val</span> fetchOnlyCommitted = !isFromFollower &amp;&amp; replicaId != <span class="type">Request</span>.<span class="type">FutureLocalReplicaId</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">readFromLog</span></span>(): <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)] = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从本地消息日志读取结果</span></span><br><span class="line">  <span class="keyword">val</span> logReadResults = readFromLog() <span class="comment">// Seq[(TopicPartition, LogReadResult)]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有分区的 LogReadResult 组成的 Seq</span></span><br><span class="line">  <span class="keyword">val</span> logReadResultValues = logReadResults.map &#123; <span class="keyword">case</span> (_, v) =&gt; v &#125;</span><br><span class="line">  <span class="comment">// 总共读取的字节数</span></span><br><span class="line">  <span class="keyword">val</span> bytesReadable = logReadResultValues.map(_.info.records.sizeInBytes).sum</span><br><span class="line">  <span class="comment">// 如果存在 LogReadResult 的 error 字段不为 NONE 则为 true, 即存在读取错误</span></span><br><span class="line">  <span class="keyword">val</span> errorReadingData = logReadResultValues.foldLeft(<span class="literal">false</span>) ((errorIncurred, readResult) =&gt;</span><br><span class="line">    errorIncurred || (readResult.error != <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span> || fetchInfos.isEmpty || bytesReadable &gt;= fetchMinBytes || errorReadingData) &#123;</span><br><span class="line">    <span class="comment">// 请求不想等待 or 请求消息为空 or 读取的总字节数超过了最小积攒字节数 or 存在读取错误</span></span><br><span class="line">    <span class="comment">// 此时直接生成结果给回调函数处理</span></span><br><span class="line">    <span class="keyword">val</span> fetchPartitionData = logReadResults.map &#123; <span class="keyword">case</span> (tp, result) =&gt;</span><br><span class="line">      tp -&gt; <span class="type">FetchPartitionData</span>(result.error, result.highWatermark, result.leaderLogStartOffset, result.info.records,</span><br><span class="line">        result.lastStableOffset, result.info.abortedTransactions)</span><br><span class="line">    &#125;</span><br><span class="line">    responseCallback(fetchPartitionData)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Map 类型, key 为 TopicPartition, value 为 FetchPartitionStatus</span></span><br><span class="line">    <span class="keyword">val</span> fetchPartitionStatus = logReadResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">      <span class="comment">// 对每个 LogReadResult, 从 fetchInfos 中找到第一个分区相同的 PartitionData, 若找不到分区, 则抛出 RuntimeException</span></span><br><span class="line">      <span class="comment">// PartitionData 包含以下字段：</span></span><br><span class="line">      <span class="comment">//   fetchOffset: Long     要获取的消息 offset</span></span><br><span class="line">      <span class="comment">//   logStartOffset: Long  follower 第一个可用 offset, V5 新增字段</span></span><br><span class="line">      <span class="comment">//   maxBytes: Long        响应中累积的最大字节数, V3 新增字段</span></span><br><span class="line">      <span class="keyword">val</span> fetchInfo = fetchInfos.collectFirst &#123;</span><br><span class="line">        <span class="keyword">case</span> (tp, v) <span class="keyword">if</span> tp == topicPartition =&gt; v</span><br><span class="line">      &#125;.getOrElse(sys.error(<span class="string">s&quot;Partition <span class="subst">$topicPartition</span> not found in fetchInfos&quot;</span>))</span><br><span class="line">      <span class="comment">// fetchOffsetMetadata: LogOffsetMetadata 来自从本地日志读取的信息</span></span><br><span class="line">      <span class="comment">// fetchInfo: PartitionData 来自客户端的请求字段, 利用 FetchContext 得到的</span></span><br><span class="line">      (topicPartition, <span class="type">FetchPartitionStatus</span>(result.info.fetchOffsetMetadata, fetchInfo))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转发输入参数构造 DelayedFetch 对象</span></span><br><span class="line">    <span class="keyword">val</span> fetchMetadata = <span class="type">FetchMetadata</span>(fetchMinBytes, fetchMaxBytes, hardMaxBytesLimit, fetchOnlyFromLeader,</span><br><span class="line">      fetchOnlyCommitted, isFromFollower, replicaId, fetchPartitionStatus)</span><br><span class="line">    <span class="keyword">val</span> delayedFetch = <span class="keyword">new</span> <span class="type">DelayedFetch</span>(timeout, fetchMetadata, <span class="keyword">this</span>, quota, isolationLevel, responseCallback)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 (topic, partition) 键值对作为延迟 fetch 操作的 key</span></span><br><span class="line">    <span class="keyword">val</span> delayedFetchKeys = fetchPartitionStatus.map &#123; <span class="keyword">case</span> (tp, _) =&gt; <span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(tp) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试立刻完成请求, 否则将其放入 purgatory, 因为每次创建延迟 fetch 操作时, 新的请求可能到达并使其可完成</span></span><br><span class="line">    delayedFetchPurgatory.tryCompleteElseWatch(delayedFetch, delayedFetchKeys)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从本地日志文件中读取得到请求的每个分区的结果（<code>LogReadResult</code>）；</li>
<li>若出现以下错误，则立刻将读取结果构造成 <code>FetchPartitionData</code> 交给回调函数处理；<ul>
<li>timeout（对应请求的 <code>max_wait_time</code>字段）小于0，即客户端不想等待；</li>
<li>读取结果为空，即客户端请求的任何分区都无法从本地读到结果；</li>
<li>读取字节数不小于 <code>fetchMinBytes</code>（对应请求的 <code>min_bytes</code> 字段）；</li>
<li>在读取某个请求的分区的结果时存在错误。</li>
</ul>
</li>
<li>否则，遍历每个分区的读取结果，和请求中同一分区的请求字段一起构造 <code>FetchPartitionStatus</code>；</li>
<li>构造 <code>DelayedFetch</code> 对象，尝试完成请求，否则将其放入 <code>delayedFetchPurgatory</code> 中延迟处理。</li>
</ol>
<p>关键的部分就是 <code>readFromLog()</code> 函数和延迟处理的部分。延迟处理相关设施（purgatory，<code>DelayedOperation</code>）在之后去阅读，本篇最后阅读 <code>readFromLog()</code> 和发送响应的回调函数的实现。</p>
<h3 id="responseCallback"><a href="#responseCallback" class="headerlink" title="responseCallback"></a>responseCallback</h3><p>即 <code>KafkaApis.handleFetchRequest</code> 方法中定义的回调函数 <code>processResponseCallback</code>，用来在处理请求完成，构造响应后将响应发送给客户端。</p>
<p>这部分不细看了，因为有不少逻辑是为了实现事务以及配置限额的，这不是目前我阅读源码的重点。核心处理分为两步：</p>
<ol>
<li>通过 <code>convertedPartitionData</code> 将 <code>PartitionData</code> 转换成和兼容旧版本的响应结构；</li>
<li>调用 <code>KafkaApis.sendResponse</code> 发送响应，在之前的  <a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/11/07/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB07-Produce%E8%AF%B7%E6%B1%82-2-%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94/">Produce 请求(2): 发送响应</a>  中都看过这个方法，简单回顾下，实际上就是把响应加入 <code>Processor</code> 的响应队列，之后的发送由 <code>Processor</code> 处理，参考  <a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/09/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB02-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BAcceptor%E5%92%8CProcessor/">网络层阅读之 Acceptor 和 Processor</a> 的 4.2 节。</li>
</ol>
<h2 id="readFromLog"><a href="#readFromLog" class="headerlink" title="readFromLog"></a>readFromLog</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readFromLog</span></span>(): <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)] = &#123;</span><br><span class="line">  <span class="keyword">val</span> result = readFromLocalLog(</span><br><span class="line">    replicaId = replicaId, <span class="comment">// 副本 id, 客户端为 Consumer 则为 -1</span></span><br><span class="line">    fetchOnlyFromLeader = fetchOnlyFromLeader,</span><br><span class="line">    readOnlyCommitted = fetchOnlyCommitted,</span><br><span class="line">    fetchMaxBytes = fetchMaxBytes, <span class="comment">// max_bytes 字段</span></span><br><span class="line">    hardMaxBytesLimit = hardMaxBytesLimit, <span class="comment">// 请求版本 &gt;= V3 则为 true, 此时请求有 max_bytes 字段</span></span><br><span class="line">    readPartitionInfo = fetchInfos, <span class="comment">// 通过认证且分区存在的分区信息</span></span><br><span class="line">    quota = quota,</span><br><span class="line">    isolationLevel = isolationLevel)</span><br><span class="line">  <span class="keyword">if</span> (isFromFollower) updateFollowerLogReadResults(replicaId, result)</span><br><span class="line">  <span class="keyword">else</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>readFromLocalLog</code>，如果 Fetch 请求来自 follower 则还需要调用 <code>updateFollowerLogReadResults</code> 更新 follower 的结果。</p>
<h3 id="readFromLocalLog"><a href="#readFromLocalLog" class="headerlink" title="readFromLocalLog"></a>readFromLocalLog</h3><p>首先看看内部定义的 <code>read</code> 函数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(tp: <span class="type">TopicPartition</span>, fetchInfo: <span class="type">PartitionData</span>, limitBytes: <span class="type">Int</span>, minOneMessage: <span class="type">Boolean</span>): <span class="type">LogReadResult</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> offset = fetchInfo.fetchOffset</span><br><span class="line">  <span class="keyword">val</span> partitionFetchSize = fetchInfo.maxBytes</span><br><span class="line">  <span class="keyword">val</span> followerLogStartOffset = fetchInfo.logStartOffset</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 决定是否仅从 leader 获取, 然而无论是 Consumer 还是 Follower 都会从 leader 获取</span></span><br><span class="line">    <span class="keyword">val</span> localReplica = <span class="keyword">if</span> (fetchOnlyFromLeader)</span><br><span class="line">      getLeaderReplicaIfLocal(tp) <span class="comment">// 分区的 leader 副本</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      getReplicaOrException(tp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> initialHighWatermark = localReplica.highWatermark.messageOffset</span><br><span class="line">    <span class="keyword">val</span> lastStableOffset = <span class="keyword">if</span> (isolationLevel == <span class="type">IsolationLevel</span>.<span class="type">READ_COMMITTED</span>)</span><br><span class="line">      <span class="type">Some</span>(localReplica.lastStableOffset.messageOffset)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="type">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// decide whether to only fetch committed data (i.e. messages below high watermark)</span></span><br><span class="line">    <span class="keyword">val</span> maxOffsetOpt = <span class="keyword">if</span> (readOnlyCommitted)</span><br><span class="line">      <span class="type">Some</span>(lastStableOffset.getOrElse(initialHighWatermark))</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="type">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在读取日志之前首先读取 LogOffsetMetadata, 它能判断指定副本是否同步</span></span><br><span class="line"><span class="comment">     * 在读取之后再使用 LEO 会导致 race condition, 比如在副本完成消费后, 数据立刻添加到了日志末尾,</span></span><br><span class="line"><span class="comment">     * 这可能导致副本一直被判断不同步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> initialLogEndOffset = localReplica.logEndOffset.messageOffset <span class="comment">// 在读取操作之前取得 LEO</span></span><br><span class="line">    <span class="keyword">val</span> initialLogStartOffset = localReplica.logStartOffset</span><br><span class="line">    <span class="keyword">val</span> fetchTimeMs = time.milliseconds <span class="comment">// 当前时间戳</span></span><br><span class="line">    <span class="keyword">val</span> logReadInfo = localReplica.log <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(log) =&gt;</span><br><span class="line">        <span class="comment">// 取得 partition_max_bytes (分区本身的最大读取字节数) 和 max_bytes 的较小值作为 fetch 字节数上限</span></span><br><span class="line">        <span class="keyword">val</span> adjustedFetchSize = math.min(partitionFetchSize, limitBytes)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取 offset 开始的最多 adjustedFetchSize 个字节, 若 minOneMessage 为 true, 则即使第一条消息大小</span></span><br><span class="line">        <span class="comment">// 超过了 adjustedFetchSize 也会返回这条消息, 返回类型: FetchDataInfo</span></span><br><span class="line">        <span class="keyword">val</span> fetch = log.read(offset, adjustedFetchSize, maxOffsetOpt, minOneMessage, isolationLevel)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该分区正在被限速, 即限制访问该分区, 清空消息</span></span><br><span class="line">        <span class="keyword">if</span> (shouldLeaderThrottle(quota, tp, replicaId))</span><br><span class="line">          <span class="type">FetchDataInfo</span>(fetch.fetchOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">        <span class="comment">// V3 版本开始 hardMaxBytesLimit 为 false, 如果第一条消息大小超过了 max_bytes 限制也会读取</span></span><br><span class="line">        <span class="comment">// 为了防止客户端报错 RecordToolLargeException, 此时将过大的消息替换成空消息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!hardMaxBytesLimit &amp;&amp; fetch.firstEntryIncomplete)</span><br><span class="line">          <span class="type">FetchDataInfo</span>(fetch.fetchOffsetMetadata, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">        <span class="keyword">else</span> fetch</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// leader 副本在该分区不存在本地日志</span></span><br><span class="line">        error(<span class="string">s&quot;Leader for partition <span class="subst">$tp</span> does not have a local log&quot;</span>)</span><br><span class="line">        <span class="type">FetchDataInfo</span>(<span class="type">LogOffsetMetadata</span>.<span class="type">UnknownOffsetMetadata</span>, <span class="type">MemoryRecords</span>.<span class="type">EMPTY</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">LogReadResult</span>(info = logReadInfo, <span class="comment">// localReplica.log 调用 read 方法的返回值</span></span><br><span class="line">                  <span class="comment">// localReplica 在内存中维护的 HW, LogStartOffset, LEO</span></span><br><span class="line">                  highWatermark = initialHighWatermark,</span><br><span class="line">                  leaderLogStartOffset = initialLogStartOffset,</span><br><span class="line">                  leaderLogEndOffset = initialLogEndOffset,</span><br><span class="line">                  <span class="comment">// 请求中 follower 的 LogStartOffset, 客户端为 Consumer 则为 -1</span></span><br><span class="line">                  followerLogStartOffset = followerLogStartOffset,</span><br><span class="line">                  fetchTimeMs = fetchTimeMs, <span class="comment">// 从本地读取数据之前记录的时间戳</span></span><br><span class="line">                  readSize = partitionFetchSize, <span class="comment">// <span class="doctag">NOTE:</span> 这里是请求的 max_bytes 字段，而非实际读取字节数</span></span><br><span class="line">                  lastStableOffset = lastStableOffset, <span class="comment">// LSO, 用于事务实现</span></span><br><span class="line">                  exception = <span class="type">None</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="comment">// (...) 异常处理, 返回一个 exception 字段为捕获的异常, 其它字段都不合法的 LogReadResult</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程：首先取得本地副本（实际上对 Consumer 和 Follower 而言都是 Leader 副本），然后取得 HW，LEO 等字段，记录时间戳，然后通过本地副本读取本地数据。这里还利用了 V3 版本请求的 <code>max_bytes</code> 字段，限制读取的字节数上限，但如果第一条消息长度就超出上限的话，仍然会返回整条消息（此时读取字节数超过了 <code>max_bytes</code>）。</p>
<p>注意 <code>LogReadResult</code> 的第一个字段是从本地日志读取的信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">FetchDataInfo</span>(<span class="params">fetchOffsetMetadata: <span class="type">LogOffsetMetadata</span>, // offset 元数据, 包括:</span></span></span><br><span class="line"><span class="params"><span class="class">                         // offset; <span class="type">Segment</span> 的基础 offset; 相对于 <span class="type">Segment</span> 的物理偏移字节数</span></span></span><br><span class="line"><span class="params"><span class="class">                         records: <span class="type">Records</span>, // 消息集</span></span></span><br><span class="line"><span class="params"><span class="class">                         firstEntryIncomplete: <span class="type">Boolean</span> = false,</span></span></span><br><span class="line"><span class="params"><span class="class">                         abortedTransactions: <span class="type">Option</span>[<span class="type">List</span>[<span class="type">AbortedTransaction</span>]] = <span class="type">None</span></span></span></span><br></pre></td></tr></table></figure>

<p>主要是前两个字段，消息集就不说了，元数据的作用是记录了 offset 对应消息相对本地 Segment 的实际偏移量。这里回顾一个基本概念，Kafka 的每个分区都用本地文件记录消息，为了防止单个文件过大，会根据文件大小和写入时间分成多个文件，单个文件被称为 <strong>Segment</strong>（对应代码中的 <code>LogSegment</code> 类），而 <code>Log</code> 类则是管理这些 Segment。因此，记录消息的物理偏移量，便于在从本地 Segment 中快速通过 offset 定位到对应消息。</p>
<p>接着看 <code>readFromLocalLog</code> 的逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> limitBytes = fetchMaxBytes <span class="comment">// 初始值为 max_bytes 字段, 整个响应(多条消息)中可积累的最大字节数</span></span><br><span class="line"><span class="keyword">val</span> result = <span class="keyword">new</span> mutable.<span class="type">ArrayBuffer</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)]</span><br><span class="line"><span class="keyword">var</span> minOneMessage = !hardMaxBytesLimit</span><br><span class="line">readPartitionInfo.foreach &#123; <span class="keyword">case</span> (tp, fetchInfo) =&gt;</span><br><span class="line">  <span class="keyword">val</span> readResult = read(tp, fetchInfo, limitBytes, minOneMessage) <span class="comment">// 指定分区的读取结果</span></span><br><span class="line">  <span class="keyword">val</span> recordBatchSize = readResult.info.records.sizeInBytes <span class="comment">// 实际读取字节数</span></span><br><span class="line">  <span class="comment">// 读取了至少一条消息, 那么以后严格遵守 max_bytes 的限制</span></span><br><span class="line">  <span class="keyword">if</span> (recordBatchSize &gt; <span class="number">0</span>)</span><br><span class="line">    minOneMessage = <span class="literal">false</span></span><br><span class="line">  limitBytes = math.max(<span class="number">0</span>, limitBytes - recordBatchSize)</span><br><span class="line">  result += (tp -&gt; readResult)</span><br><span class="line">&#125;</span><br><span class="line">result</span><br></pre></td></tr></table></figure>

<p>可见，每个分区都对应一条读取结果（<code>LogReadResult</code>），包含 offset 对应消息，还有 HW&#x2F;LEO 等信息 。V3 开始外部的 <code>max_bytes</code> 字段限制所有消息的最大字节数，而每个分区都有自己的 <code>partition_max_bytes</code> 限制单条消息的最大字节数。</p>
<p>读完这部分代码后，可以回顾 Fetch 请求的协议（V3 版本），并附上注释说明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Fetch Request (Version: <span class="number">3</span>) =&gt; replica_id max_wait_time min_bytes max_bytes [topics] </span><br><span class="line">  replica_id =&gt; INT32 <span class="comment">// -1: Consumer, &gt;= 0: Follower</span></span><br><span class="line">  max_wait_time =&gt; INT32 <span class="comment">// 延迟请求中的 timeout，用于构造 DelayedFetch 对象</span></span><br><span class="line">  min_bytes =&gt; INT32 <span class="comment">// 响应字节数超过则立刻发送响应，见ReplicaManager.fetchMessages</span></span><br><span class="line">  max_bytes =&gt; INT32 <span class="comment">// 整个响应的最大字节数</span></span><br><span class="line">  topics =&gt; topic [partitions] </span><br><span class="line">    topic =&gt; STRING</span><br><span class="line">    partitions =&gt; partition fetch_offset partition_max_bytes </span><br><span class="line">      partition =&gt; INT32</span><br><span class="line">      fetch_offset =&gt; INT64</span><br><span class="line">      partition_max_bytes =&gt; INT32 <span class="comment">// 每个分区消息的最大字节数</span></span><br></pre></td></tr></table></figure>

<p>其中 fetch_offset 可由 <code>FetchContext</code> 的相关方法取得：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">FetchContext</span> <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Get the fetch offset for a given partition.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getFetchOffset</span></span>(part: <span class="type">TopicPartition</span>): <span class="type">Option</span>[<span class="type">Long</span>]</span><br></pre></td></tr></table></figure>

<h3 id="updateFollowerLogReadResults"><a href="#updateFollowerLogReadResults" class="headerlink" title="updateFollowerLogReadResults"></a>updateFollowerLogReadResults</h3><p>当 replica id 大于 0 时，代表客户端为 Follower，在从本地日志读取信息后，会调用该方法更新 Follower 的 fetch 状态，并更新读取结果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">updateFollowerLogReadResults</span></span>(replicaId: <span class="type">Int</span>,</span><br><span class="line">                                         readResults: <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)]): <span class="type">Seq</span>[(<span class="type">TopicPartition</span>, <span class="type">LogReadResult</span>)] = &#123;</span><br><span class="line">  readResults.map &#123; <span class="keyword">case</span> (topicPartition, readResult) =&gt;</span><br><span class="line">    <span class="keyword">var</span> updatedReadResult = readResult</span><br><span class="line">    nonOfflinePartition(topicPartition) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(partition) =&gt;</span><br><span class="line">        partition.getReplica(replicaId) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(replica) =&gt;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(replica) =&gt;</span><br><span class="line">            <span class="comment">// 首先更新分区上的 follower 的状态, 若 LW 或 HW 增加则返回 true</span></span><br><span class="line">            <span class="keyword">if</span> (partition.updateReplicaLogReadResult(replica, readResult))</span><br><span class="line">              <span class="comment">// 将 leader 副本的信息 (HW, LogStartOffset, LEO) 更新到读取结果上</span></span><br><span class="line">              partition.leaderReplicaIfLocal.foreach &#123; leaderReplica =&gt;</span><br><span class="line">                updatedReadResult = readResult.updateLeaderReplicaInfo(leaderReplica)</span><br><span class="line">              &#125;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// 当前副本不是分区的副本, 清空读取结果的 records 字段并将 metadata 标记为未知</span></span><br><span class="line">            <span class="comment">// 略去日志...</span></span><br><span class="line">            updatedReadResult = readResult.withEmptyFetchInfo</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// 分区不可用（即 offline 分区）, 打印警告日志, 不修改读取结果</span></span><br><span class="line">        warn(<span class="string">s&quot;While recording the replica LEO, the partition <span class="subst">$topicPartition</span> hasn&#x27;t been created.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    topicPartition -&gt; updatedReadResult</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对读取结果调用 <code>updateLeaderReplicaInfo</code> 更新为 leader 副本的信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateLeaderReplicaInfo</span></span>(leaderReplica: <span class="type">Replica</span>): <span class="type">LogReadResult</span> =</span><br><span class="line">  copy(highWatermark = leaderReplica.highWatermark.messageOffset,</span><br><span class="line">    leaderLogStartOffset = leaderReplica.logStartOffset,</span><br><span class="line">    leaderLogEndOffset = leaderReplica.logEndOffset.messageOffset)</span><br></pre></td></tr></table></figure>

<p>利用 Scala case 类的 <code>copy</code> 方法，返回更新对应字段后的对象。这里将读取结果的 HW，LogStartOffset，LEO 更新为 leader 副本维护的相应信息。因为 follower 副本发送 Fetch 请求时，leader 副本可能更新 HW（如果之前 follower 没有同步到最新），因此需要把更新后的 HW 发送给 follower。</p>
<p>顺带提下这里涉及到的另一个概念：低水位（LW, Low Watermark）。LW 即所有副本中最小的 LogStartOffset，一般情况下 LW 都是 0，但是如果服务端收到了 <code>DeleteRecords</code> 请求，删除日志文件的部分记录（消息）时，会更新 LW。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇阅读了 Fetch 请求的处理流程，主要根据 replica id 字段分 Consumer 和 Follower 来处理：</p>
<ol>
<li>会话认证，判断请求分区是否存在，将没有问题的分区对应的请求构成 Map 由 <code>ReplicaManager</code> 处理；</li>
<li><code>ReplicaManager</code> 对每个分区，找到其 leader 副本；</li>
<li>leader 副本从本地读取请求的 offset 开始的若干消息（由全局的以及各分区的 <code>max_bytes</code> 字段来限制读取最大字节数），和维护的其它信息构成读取结果；</li>
<li>对 follower 副本的请求，还会将 leader 副本的 HW，LEO，LogStartOffset 更新到读取结果中；</li>
<li>根据读取结果和请求的相关字段判断是否立刻发送响应，比如读取没问题时，读取字节数超过了 <code>min_bytes</code> 即可发送；</li>
<li>否则，构造 <code>DelayedFetch</code> 对象传入 <code>DelayedFetchPurgatory</code> 对象中，此时 purgatory 还会判断一次处理是否完成，若已完成则不用延迟处理。</li>
</ol>
<p>主要区别还是第 4 步，因为 follower 的 Fetch 请求是用来与 leader 同步的，因此需要将 HW 记录在结果中让 follower 更新自己的 HW。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/07/Scala-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%88%9D%E6%8E%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/07/Scala-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC%E5%88%9D%E6%8E%A2/" class="post-title-link" itemprop="url">Scala 笔记 - 函数式编程风格初探</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-07 10:54:08" itemprop="dateCreated datePublished" datetime="2020-01-07T10:54:08+08:00">2020-01-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一段时间写 Scala 比较多，虽然用传统的风格写代码也没问题，但 Scala 既然提供了比较方便的函数式编程方式，那么还是入乡随俗，好好利用比较好。</p>
<p>目前写下来几个感受最深的还是：尽量避免使用 <code>var</code> 和 <code>mutable</code> 数据结构。</p>
<p>上周末抽空看了下 <strong>Java 并发编程实战</strong>，基于锁和原子变量的线程安全实现虽然用起来很方便，但是一旦逻辑复杂了，锁住哪些变量，粒度多大，都会使代码变得比较复杂。而使用不可变（immutable）数据结构则能很大程度简化线程安全的实现（当然，锁和原子变量一定程度上还是需要的），因为不可变数据结构本身是线程安全的。</p>
<p>此外，Scala 不提供原生的 <code>break</code> 和 <code>continue</code> 来进行流程控制，虽然可以通过导入模块的方式使用，但尽量还是避免。</p>
<p>不过作为 C++er，有些地方从 C++ 转过来还是不太适应，因此记录一些笔记。</p>
<h2 id="编程习惯的改变"><a href="#编程习惯的改变" class="headerlink" title="编程习惯的改变"></a>编程习惯的改变</h2><p>Scala 使用 <code>()</code> 来使用下标访问集合，而其它大多数语言都是使用 <code>[]</code>，比如用 C 风格代码遍历数组：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i &lt;- array.indices)</span><br><span class="line">  println(array(i)) <span class="comment">// array(i) 而非 array[i]</span></span><br></pre></td></tr></table></figure>

<p>原因很简单，因为 Scala 使用 <code>[]</code> 来指定泛型，而其它语言比如 C++ 和 Java 都是使用 <code>&lt;&gt;</code>，Scala 的 <code>&lt;</code> 和 <code>&gt;</code> 都有各自用法：</p>
<ul>
<li><code>&lt;-</code>：用于 for 循环，左边的引用为右边集合的遍历；</li>
<li><code>-&gt;</code>：二元元组的定义，左边为 key，右边为 value；</li>
<li><code>=&gt;</code>：定义<strong>函数</strong>（而非方法），左边是参数列表，右边是函数体；</li>
<li><code>&lt;=</code>：嗯？这是小于或等于的意思。笑话出自<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19748408/answer/264461050">Scala 是一门怎样的语言，具有哪些优缺点？ - 颜巍的回答 - 知乎</a></li>
</ul>
<p>Scala 有比其它大部分语言更为强大的 for 循环，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="string">&quot;Java&quot;</span>, <span class="number">2</span> -&gt; <span class="string">&quot;C&quot;</span>, <span class="number">3</span> -&gt; <span class="string">&quot;Python&quot;</span>, <span class="number">4</span> -&gt; <span class="string">&quot;C++&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> ((key, value) &lt;- map <span class="keyword">if</span> value.matches(<span class="string">&quot;C.*&quot;</span>))</span><br><span class="line">  println(<span class="string">s&quot;<span class="subst">$key</span> =&gt; <span class="subst">$value</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>打印出 value 以 C 开头的键值对，当然，Scala 也可以使用传统函数式编程常用的 <code>map</code>，<code>filter</code> 等方法构成调用链：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map.filter(_._2.matches(<span class="string">&quot;C.*&quot;</span>)).foreach &#123; <span class="keyword">case</span> (key, value) =&gt;</span><br><span class="line">  println(<span class="string">s&quot;<span class="subst">$key</span> =&gt; <span class="subst">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 <code>_2</code> 是取得元组（前面说 <code>-&gt;</code> 提到了二元元组）的第 2 个元素。两者是基于 Scala 强大的模式匹配（<code>match</code>）的，并且都用语法糖省略了多余代码。</p>
<p>这里由于仅仅是处理每个元素，因此用了 <code>foreach</code>，如果需要得到结果，比如将 <code>println</code> 打印的字符串构成数组或链表，就可以用 <code>map</code>，然后用 <code>mkString</code> 将换行符作为分隔符即可实现一样的功能：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = map.filter(_._2.matches(<span class="string">&quot;C.*&quot;</span>)).map &#123; <span class="keyword">case</span> (key, value) =&gt; <span class="string">s&quot;<span class="subst">$key</span> =&gt; <span class="subst">$value</span>&quot;</span> &#125;</span><br><span class="line">println(list.mkString(<span class="string">&quot;\n&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>因此 <code>map</code> 可谓最常用的方法了，前面说了，多线程访问共享的可变数据结构时存在 race condition，而如果使用 <code>map</code> 将共享的不可变数据结构映射为线程内部可见的另一个不可变数据结构时，则避免了 race condition，也不用麻烦地去加锁来解决，加锁还要考虑锁的粒度，还要谨慎思考粒度太小会不会导致线程不安全了。</p>
<p>当然，作为 C++er 的一个坏习惯就是过早优化，比如担心拷贝和内存多次分配的开销会不会太大。</p>
<p>然而实践起来，很多时候性能的瓶颈是网络延迟，磁盘 I&#x2F;O，算法处理速度这些因素，而不是拷贝和内存分配。有些拷贝也是必要的，用 C++ 写，不加锁要实现线程安全，也得拷贝一份，至于内存分配，JVM 的 GC 经过一代代发展已经相当强大了。</p>
<p>这里不是说性能不重要，而是说，性能导致问题之前，编写不易出 BUG 的代码优先级更高。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>比如，从 N 台副本服务器上取数据，只要成功取得一份就返回，因此不需要并行操作，而是循环依次去访问服务器，这里给几个模拟实际场景的变量和方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> servers = <span class="type">Seq</span>(<span class="string">&quot;Server1&quot;</span>, <span class="string">&quot;Server2&quot;</span>, <span class="string">&quot;Server3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">DataType</span> </span>= <span class="type">String</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getDataFromServer</span></span>(server: <span class="type">String</span>): <span class="type">DataType</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (server.contains(<span class="string">&quot;2&quot;</span>)) <span class="string">&quot;Ok&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="return-vs-break"><a href="#return-vs-break" class="headerlink" title="return vs break"></a>return vs break</h3><p>使用 <code>return</code> 单独写个方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span></span>: <span class="type">DataType</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span> (server &lt;- servers) &#123;</span><br><span class="line">    <span class="keyword">val</span> data = getDataFromServer(server)</span><br><span class="line">    <span class="keyword">if</span> (data.nonEmpty)</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>for (server &lt;- servers) &#123;</code> 也可以换成 <code>servers.foreach &#123; server =&gt;</code>，看个人喜好。</p>
<p>当然也可以用 <code>break</code>，首先 <code>import scala.util.control.Breaks</code>，然后代码改成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data: <span class="type">DataType</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">breakable &#123;</span><br><span class="line">  servers.foreach &#123; server =&gt;</span><br><span class="line">    data = getDataFromServer(server)</span><br><span class="line">    <span class="keyword">if</span> (data.nonEmpty)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这种方式仅仅是举例，实际写代码应该避免</strong>。除了少写一个函数外，没任何好处。</p>
<ol>
<li><p>是破坏了不用<code>var</code> 的原则，虽然在这里并没有什么影响，但很容易让人逐渐依赖于 <code>var</code>;</p>
</li>
<li><p>Scala 使用 <code>break</code> 本来就比其它语言的 <code>break</code> 要复杂，多了外层的 <code>breakable</code> 块；</p>
</li>
<li><p>底层是用异常来实现的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BreakControl</span> <span class="keyword">extends</span> <span class="title">ControlThrowable</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Breaks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> breakException = <span class="keyword">new</span> <span class="type">BreakControl</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">breakable</span></span>(op: =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      op</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> ex: <span class="type">BreakControl</span> =&gt;</span><br><span class="line">        <span class="keyword">if</span> (ex ne breakException) <span class="keyword">throw</span> ex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">break</span></span>(): <span class="type">Nothing</span> = &#123; <span class="keyword">throw</span> breakException &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，如果在 <code>breakable</code> 块中处理异常时，还得额外捕获 <code>ControlThrowable</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">breakable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用了 break 的代码（略）</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e <span class="comment">// 抛给外层来流程控制</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; <span class="comment">// <span class="doctag">TODO:</span> 处理真正的异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>总之，<code>break</code> 仅仅是让习惯了其它语言的用户方便上手而已。</p>
<h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><p>之前 <code>foreach</code> 的做法还是避免不了 return 跳出循环，实际上 Scala 提供了尾递归优化，这里不详述，简单说就是将特殊条件下函数的递归调用优化替换成循环调用，并且无法优化的场景利用 <code>tailrec</code> 注解会抛出异常说明此处无法尾递归优化。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.tailrec</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span></span>(servers: <span class="type">Seq</span>[<span class="type">String</span>]): <span class="type">DataType</span> = &#123;</span><br><span class="line">  servers <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Seq</span>() =&gt; <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Seq</span>(server, rest@_*) =&gt;</span><br><span class="line">      <span class="keyword">val</span> data = getDataFromServer(server)</span><br><span class="line">      <span class="keyword">if</span> (data.nonEmpty)</span><br><span class="line">        data</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        getData(rest.toSeq)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码利用了 Scala 强大的模式匹配能力。</p>
<p>第一行的 <code>case Seq()</code> 匹配空 <code>Seq</code>，也就是递归终止条件。</p>
<p>第二行的需要说明的是 <code>rest@_*</code>，进行匹配的是 <code>_*</code>，<code>_</code> 匹配类型，而 <code>*</code> 在 Scala 中则是匹配可变参数列表。前面在通过 <code>@</code> 运算符将匹配到的可变参数列表绑定到变量 <code>rest</code> 上。</p>
<p>这里的主要好处还是略去了 <code>return</code>，在其它语言中 <code>return</code> 的一个好处是提前返回来避免 N 层缩进的难以阅读的代码。不过另一方面，<code>return</code> 的滥用会导致程序流程不是那么清晰，因为代码太长的话不知道前面哪里会直接 <code>return</code>了。不过其实说起来，这里的 <code>return</code> 是用在单独的方法中，相当于被隐藏了，也不会导致跳出方法外层的循环，可读性并不受影响。</p>
<p>一开始我是认为尾递归的方式比 <code>return</code> 更好，当时最大原因错以为 <code>return</code> 会抛出 <code>ControlThrowable</code> 来进行流程控制导致外层的 <code>try-catch</code> 需要额外处理这个异常，后来发现并不会抛出。因此在这里使用尾递归+模式匹配某种程度上有点炫技的意味。</p>
<p>另外，如果 <code>servers</code> 类型是 <code>List</code> 则可以用这种尾递归方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.tailrec</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getData</span></span>(servers: <span class="type">List</span>[<span class="type">String</span>]): <span class="type">DataType</span> = &#123;</span><br><span class="line">  servers <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">case</span> server :: rest =&gt;</span><br><span class="line">      <span class="keyword">val</span> data = getDataFromServer(server)</span><br><span class="line">      <span class="keyword">if</span> (data.nonEmpty)</span><br><span class="line">        data</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        getData(rest) <span class="comment">// tail recursion</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Future-的处理"><a href="#Future-的处理" class="headerlink" title="Future 的处理"></a>Future 的处理</h2><p>Scala 可以用 Java 的线程设施来编写多线程程序，但是内置的 <code>Future</code> 一般情况下够用和好用了，最近用到的 <a target="_blank" rel="noopener" href="https://www.playframework.com/documentation/2.8.x/ScalaWS">play framework WS 模块</a>，<code>Post</code> 和 <code>Get</code> 方法返回的都是 <code>Future</code>。</p>
<p>一般情况下 <code>Future</code> 用 <code>onComplete</code> 方法，利用回调函数来处理正常返回或者异常发送的场景：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="keyword">val</span> future = <span class="type">Future</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.length % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    s.length</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">s&quot;&quot;</span><span class="string">&quot;&quot;</span>$<span class="string">s&quot;&#x27;s length is not even&quot;</span><span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">future.onComplete &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; <span class="comment">// <span class="doctag">TODO:</span> 处理 future 抛出的异常</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(result) =&gt; <span class="comment">// <span class="doctag">TODO:</span> 处理 future 的结果，这里即字符串长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>Future</code> 底层还是使用线程池的，因此需要导入 <code>ExecutionContext</code>，一般用默认的就行：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.<span class="type">ExecutionContext</span>.<span class="type">Implicits</span>.global</span><br></pre></td></tr></table></figure>

<p>但是有些时候还是需要等待 <code>Future</code> 完成的，这里不回顾 <code>Future</code> 的语法，而是谈一些同步方面的处理。</p>
<h3 id="等待多个-Future-结束"><a href="#等待多个-Future-结束" class="headerlink" title="等待多个 Future 结束"></a>等待多个 Future 结束</h3><p>比如最常见的分块计算，然后将结果汇总：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = (<span class="number">1</span> to <span class="number">10</span>).toArray</span><br><span class="line"><span class="keyword">val</span> blockSize = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> blocks = (array.indices by blockSize).map &#123; i =&gt; (i, i + blockSize) &#125;.map &#123; pair =&gt;</span><br><span class="line">  <span class="keyword">if</span> (pair._2 &lt;= array.length) pair <span class="keyword">else</span> pair._1 -&gt; array.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> futures = blocks.map &#123; <span class="keyword">case</span> (from, to) =&gt;</span><br><span class="line">  <span class="type">Future</span>(array.slice(from, to).sum)</span><br><span class="line">&#125; <span class="comment">// Seq[Future[Int]]</span></span><br></pre></td></tr></table></figure>

<p>现在得到了 <code>Future[Int]</code> 的序列，可以用回调函数的方法将结果存入一个 <code>ConcurrentHashMap</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了 Future 的定义，加入了 from 作为 key</span></span><br><span class="line"><span class="keyword">val</span> futures = blocks.map &#123; <span class="keyword">case</span> (from, to) =&gt;</span><br><span class="line">  <span class="type">Future</span>(from -&gt; array.slice(from, to).sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> results = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Int</span>, <span class="type">Int</span>]()</span><br><span class="line">futures.foreach &#123; future =&gt;</span><br><span class="line">  future.onComplete &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; <span class="comment">// <span class="doctag">TODO:</span> 处理单个计算错误的异常</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Success</span>((from, sum)) =&gt; results.put(from, sum)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span>.sleep(<span class="number">100</span>) <span class="comment">// 模拟主线程做其它操作</span></span><br><span class="line"><span class="keyword">while</span> (futures.size != blocks.size) &#123; <span class="comment">// 无事可做了，轮询等待</span></span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> sum = results.entrySet().asScala.map(_.getValue).sum</span><br></pre></td></tr></table></figure>

<p>注意 <code>asScala</code> 将 Java 的集合类型转换成 Scala 对应的集合类型，在 Scala 2.13 之前需要：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConverters</span>._</span><br></pre></td></tr></table></figure>

<p>从 Scala 2.13 开始则是导入另一个包：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.jdk.<span class="type">CollectionConverters</span>._</span><br></pre></td></tr></table></figure>

<p>PS：本文默认都是 Scala 2.8 以上。</p>
<p>回正题，如果主线程不需要做其他操作，就只想等待，那么这种基于回调的方式就未免过于麻烦，不如直接等待。但是 <code>Await.result</code> 或者 <code>Await.ready</code> 只能等待单个 <code>Future</code>，于是得 for 循环等待，然后还是得将结果一个个存入 <code>HashMap</code> 或者其它容器中。</p>
<p><code>Future</code> 类提供了 <code>sequence()</code> 方法来简化这个操作，直接一行搞定：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = <span class="type">Await</span>.result(<span class="type">Future</span>.sequence(futures), <span class="number">2.</span>seconds).sum</span><br></pre></td></tr></table></figure>

<p>注意 <code>seconds</code> 需要导入相关包：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.concurrent.duration._</span><br></pre></td></tr></table></figure>

<p><code>sequence</code> 方法将 <code>Future[A]</code> 的集合转换成 <code>A</code> 的集合的 <code>Future</code>，在这里即将<code>Seq[Future[Int]]</code> 转换成了 <code>Future[Seq[Int]]</code>，这样直接等待就行了。</p>
<h3 id="任务的顺序执行"><a href="#任务的顺序执行" class="headerlink" title="任务的顺序执行"></a>任务的顺序执行</h3><p>有时候一个任务需要等待另一个任务完成后才能执行，此时可以用 <code>Future</code> 的 <code>map</code> 或 <code>flatMap</code> 方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> f1 = <span class="type">Future</span> &#123; <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">val</span> f2 = f1.map &#123; _ * <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">val</span> f3 = f2.map &#123; _ * <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span>.result(f3, <span class="number">10.</span>milliseconds)</span><br></pre></td></tr></table></figure>

<p><code>map</code> 方法接收的 block 是将结果类型映射到结果类型，但是 <code>flatMap</code> 方法是将结果类型映射到结果类型的 <code>Future</code>，有时候外部方法返回的是 <code>Future</code> 类型，此时就得用 <code>flatMap</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟外部的接口，比如 PlayWS</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span></span>(x: <span class="type">Int</span>) = <span class="type">Future</span> &#123;</span><br><span class="line">  x * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> f1 = <span class="type">Future</span> &#123; <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">val</span> f2 = f1.flatMap(getResponse)</span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span>.result(f2, <span class="number">10.</span>milliseconds)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>

<p>假如任务数量不确定，也就回到前文提到的类型，多个服务器，取到一个就退出：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> servers = <span class="type">List</span>(<span class="string">&quot;Server1&quot;</span>, <span class="string">&quot;Server2&quot;</span>, <span class="string">&quot;Server3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponseFromServer</span></span>(server: <span class="type">String</span>) = <span class="type">Future</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (server.contains(<span class="string">&quot;2&quot;</span>)) <span class="string">&quot;Ok&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以用类似前文尾递归的方法得到新 <code>Future</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span></span>(servers: <span class="type">List</span>[<span class="type">String</span>]): <span class="type">Future</span>[<span class="type">String</span>] = servers <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="type">Future</span> &#123; <span class="string">&quot;&quot;</span> &#125;</span><br><span class="line">  <span class="keyword">case</span> server :: rest =&gt;</span><br><span class="line">    getResponseFromServer(server).flatMap &#123; result =&gt;</span><br><span class="line">      <span class="keyword">if</span> (result.nonEmpty)</span><br><span class="line">        <span class="type">Future</span> &#123; result &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        getResponse(rest)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = <span class="type">Await</span>.result(getResponse(servers), <span class="number">10.</span>milliseconds)</span><br></pre></td></tr></table></figure>

<p>这里无法用尾递归，因为递归调用发生在 <code>flatMap</code> 接收的 block 中，而非当前方法末尾。</p>
<p>如果把该方法做成同步调用就行了，因为反正要等待，不如直接每次 <code>Future</code> 都等待：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.tailrec</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getResponse</span></span>(servers: <span class="type">List</span>[<span class="type">String</span>]): <span class="type">String</span> = servers <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span> =&gt; <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">case</span> server :: rest =&gt;</span><br><span class="line">    <span class="keyword">val</span> result = <span class="type">Await</span>.result(getResponseFromServer(server), <span class="number">10.</span>milliseconds)</span><br><span class="line">    <span class="keyword">if</span> (result.nonEmpty)</span><br><span class="line">      result</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      getResponse(rest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = getResponse(servers)</span><br></pre></td></tr></table></figure>

<p>这也是我在项目里实际采用的做法，这种做法有个缺点就是不便于扩展，如果返回 <code>Future</code>，那么如果以后要用到 <code>getResponse</code> 的结果，直接 <code>map</code> 或 <code>flatMap</code> 即可，但是现在的话，就必须同步等待 <code>getResponse</code> 完成了。</p>
<p>但是考虑到基本上没有进一步扩展的需求，目前就保持这样了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文算是最近写 Scala 时的一些笔记，其实学 Scala 主要是为了看 Kafka 源码，Kafka 的 Scala 代码其实很多还是并不那么函数式的，毕竟很大一块基础设施还是 Java 写的然后 Scala 来调用，当然，不否认不少地方也用了函数式编程来节省代码和增加可读性。</p>
<p>比如在 1.1.0 版本的 <code>ReplicaManager.scala</code> 中，有一段代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> errorReadingData = logReadResultValues.foldLeft(<span class="literal">false</span>) ((errorIncurred, readResult) =&gt;</span><br><span class="line">  errorIncurred || (readResult.error != <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br></pre></td></tr></table></figure>

<p><code>foldLeft</code> 之前只用过一遍，所以看到这里根本不知道什么意思，实际上等价于</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> errorReadingData = <span class="literal">false</span></span><br><span class="line">logReadResultValues.foreach &#123; readResult =&gt;</span><br><span class="line">  errorReadingData = (errorReadingData || (readResult.error != <span class="type">Errors</span>.<span class="type">NONE</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是 <code>logReadResultValues</code> 中存在一个元素的 <code>error</code> 字段为 <code>Errors.NONE</code> 则为 false。当然，其实存在一个就可以 break 或 return 了，但后面继续循环也不会有什么显著性开销，所以用 <code>foldLeft</code> 非常简洁有效地实现了功能。重要的还是没有使用 <code>var</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/22/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB08-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB08-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/" class="post-title-link" itemprop="url">Kafka源码阅读08: 写入本地日志的具体实现</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-22 11:36:37" itemprop="dateCreated datePublished" datetime="2019-11-22T11:36:37+08:00">2019-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>在<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/11/06/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB06-Produce%E8%AF%B7%E6%B1%82-1-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97/">06: Produce请求之写入本地日志</a>中，对<code>ReplicaManager</code>类的<code>appendToLocalLog</code>方法的阅读，主要集中在对异常场景的处理：</p>
<ul>
<li>非admin客户端写入<code>__consumer_offsets</code>等特殊主题；</li>
<li>找不到请求的主题+分区；</li>
<li>请求的是离线分区；</li>
<li>当前broker不是请求分区的leader；</li>
<li>请求的<code>acks</code>字段不合法，或者为-1（all）但ISR数量小于<code>min.insync.replicas</code>配置。</li>
</ul>
<p>会抛出异常被捕获后生成<code>LogAppendResult</code>对象（见server&#x2F;ReplicaManager.scala）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAppendResult</span>(<span class="params">info: <span class="type">LogAppendInfo</span>, exception: <span class="type">Option</span>[<span class="type">Throwable</span>] = <span class="type">None</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">error</span></span>: <span class="type">Errors</span> = exception <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Errors</span>.<span class="type">NONE</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(e) =&gt; <span class="type">Errors</span>.forException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述异常场景，<code>LogAppendResult.info</code>被置为无效值：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LogAppendInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">UnknownLogAppendInfo</span> = <span class="type">LogAppendInfo</span>(<span class="number">-1</span>, <span class="number">-1</span>, <span class="type">RecordBatch</span>.<span class="type">NO_TIMESTAMP</span>, <span class="number">-1</span>L, <span class="type">RecordBatch</span>.<span class="type">NO_TIMESTAMP</span>, <span class="number">-1</span>L,</span><br><span class="line">    <span class="type">RecordsProcessingStats</span>.<span class="type">EMPTY</span>, <span class="type">NoCompressionCodec</span>, <span class="type">NoCompressionCodec</span>, <span class="number">-1</span>, <span class="number">-1</span>, offsetsMonotonic = <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>appendToLocalLog</code>返回的<code>LogAppendResult</code>在 <a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/11/07/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB07-Produce%E8%AF%B7%E6%B1%82-2-%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94/">07: Produce请求之发送响应</a>  中会用来生成<code>PartitionResponse</code>对象和对应主题分区构成<code>Map</code>传给发送响应给客户端的回调函数中。</p>
<p>也就是说，最关键的部分我们之前暂且跳过了，也就是在正常清空下如何写入本地日志文件，然后生成<code>LogAppendInfo</code>。</p>
<h2 id="Log-append代码分析"><a href="#Log-append代码分析" class="headerlink" title="Log.append代码分析"></a>Log.append代码分析</h2><p>在<code>cluster</code>包的<code>Partition.scala</code>中，将当前分区的<code>leaderEpoch</code>字段传入了<code>appendAsLeader</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> info = log.appendAsLeader(records, leaderEpoch = <span class="keyword">this</span>.leaderEpoch, isFromClient)</span><br></pre></td></tr></table></figure>

<p><code>log</code>为<code>Log</code>对象，位于<code>log</code>包下的<code>Log.scala</code>。该方法会调用<code>append</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendAsLeader</span></span>(records: <span class="type">MemoryRecords</span>, leaderEpoch: <span class="type">Int</span>, isFromClient: <span class="type">Boolean</span> = <span class="literal">true</span>): <span class="type">LogAppendInfo</span> = &#123;</span><br><span class="line">  append(records, isFromClient, assignOffsets = <span class="literal">true</span>, leaderEpoch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只考虑来自客户端的请求，因此接下来阅读时<strong>默认<code>isFromClient</code>和<code>assignOffsets</code>为true</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">append</span></span>(records: <span class="type">MemoryRecords</span>, isFromClient: <span class="type">Boolean</span>, assignOffsets: <span class="type">Boolean</span>, leaderEpoch: <span class="type">Int</span>): <span class="type">LogAppendInfo</span> = &#123;</span><br><span class="line">  maybeHandleIOException(<span class="string">s&quot;Error while appending records to <span class="subst">$topicPartition</span> in dir <span class="subst">$&#123;dir.getParent&#125;</span>&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">maybeHandleIOException</span></span>[<span class="type">T</span>](msg: =&gt; <span class="type">String</span>)(fun: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fun</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt;</span><br><span class="line">      logDirFailureChannel.maybeAddOfflineLogDir(dir.getParent, msg, e)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaStorageException</span>(msg, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>maybeHandleIOException</code>捕获<code>fun</code>可能抛出的<code>IOException</code>，进一步抛出<code>KafkaStorageException</code>会被上层捕获生成<code>LogAppendResult</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 校验消息的CRC以及消息长度(字节数)是否合法(不超过配置的 max.message.bytes), 并且会设置以下字段:</span></span><br><span class="line">  <span class="comment">// - firstOffset: 第1条消息的offset, V2版本可以从header的firstOffset字段直接取得</span></span><br><span class="line">  <span class="comment">// - lastOffset: 最后1条消息的offset, V2版本可以从header的firstOffset + lastOffsetDelta得到</span></span><br><span class="line">  <span class="comment">// - shallowCount: 消息集的数量，shallow即浅层，以消息集为单位</span></span><br><span class="line">  <span class="comment">// - validBytes: 所有长度合法的消息的长度之和</span></span><br><span class="line">  <span class="comment">// - offsetsMonotic: 消息offset是否单调递增，利用每个消息集的lastOffset判断</span></span><br><span class="line">  <span class="comment">// - sourceCodec: 生产者消息集的编码方式</span></span><br><span class="line">  <span class="keyword">val</span> appendInfo = analyzeAndValidateRecords(records, isFromClient = isFromClient)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (appendInfo.shallowCount == <span class="number">0</span>) <span class="comment">// 没有合法消息则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> appendInfo</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 截断records中不合法的字节数, 然而按照前面的逻辑, 如果 analyzeAndValidateRecords 不抛出异常,</span></span><br><span class="line">  <span class="comment">// appendInfo.validBytes 和 records.sizeInBytes 是相等的, 猜测是遗留方法?</span></span><br><span class="line">  <span class="keyword">var</span> validRecords = trimInvalidBytes(records, appendInfo)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 validRecords 插入到日志中, 由于可能其他处理线程也在将消息写入本地文件, 所以用锁保护</span></span><br><span class="line">  lock synchronized &#123;</span><br><span class="line">    <span class="comment">// 检查内存映射的缓冲区是否关闭, 比如在 closeHandlers() 会导致其关闭</span></span><br><span class="line">    <span class="comment">// 若关闭, 则表示无法写入, 抛出 KafkaStorageException</span></span><br><span class="line">    checkIfMemoryMappedBufferClosed()</span><br><span class="line">    <span class="keyword">if</span> (assignOffsets) &#123;</span><br><span class="line">      <span class="comment">// assign offsets to the message set</span></span><br><span class="line">      <span class="comment">// 生产者发送的消息集的offset为0,1,...,n, nextOffsetMetadata记录了本地日志</span></span><br><span class="line">      <span class="comment">// 下一条消息的offset, 将其置为新的firstOffset, 也就是绝对offset</span></span><br><span class="line">      <span class="keyword">val</span> offset = <span class="keyword">new</span> <span class="type">LongRef</span>(nextOffsetMetadata.messageOffset)</span><br><span class="line">      appendInfo.firstOffset = offset.value</span><br><span class="line">      <span class="keyword">val</span> now = time.milliseconds <span class="comment">// 当前时间戳, 即LogAppendTime类型的时间戳</span></span><br><span class="line">      <span class="comment">// 重新验证/解压/压缩得到更新内部offset后的validRecords</span></span><br><span class="line">      <span class="keyword">val</span> validateAndOffsetAssignResult = <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 更新消息集的offset, 对于V1版本以上的消息, 可能因为时间戳类型字段来覆盖时间戳</span></span><br><span class="line">        <span class="type">LogValidator</span>.validateMessagesAndAssignOffsets(validRecords,</span><br><span class="line">          offset, <span class="comment">// 会更新为最后1条消息的绝对offset+1, 即下一次写入本地日志的消息的offset</span></span><br><span class="line">          time,</span><br><span class="line">          now,</span><br><span class="line">          appendInfo.sourceCodec,</span><br><span class="line">          appendInfo.targetCodec,</span><br><span class="line">          config.compact,</span><br><span class="line">          config.messageFormatVersion.messageFormatVersion.value,</span><br><span class="line">          config.messageTimestampType,</span><br><span class="line">          config.messageTimestampDifferenceMaxMs,</span><br><span class="line">          leaderEpoch,</span><br><span class="line">          isFromClient)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaException</span>(<span class="string">&quot;Error in validating messages while appending to log &#x27;%s&#x27;&quot;</span>.format(name), e)</span><br><span class="line">      &#125;</span><br><span class="line">      validRecords = validateAndOffsetAssignResult.validatedRecords</span><br><span class="line">      <span class="comment">// 设置 appendInfo 的以下字段：</span></span><br><span class="line">      <span class="comment">// - maxTimestamp: 消息集的最大时间戳</span></span><br><span class="line">      <span class="comment">// - offsetOfMaxTimestamp: 最大时间戳对应消息的绝对offset</span></span><br><span class="line">      <span class="comment">// - lastOffset: 最后1条消息的offset</span></span><br><span class="line">      <span class="comment">// - logAppendTime: 如果时间戳类型为LOG_APPEND_TIME, 则设为刚刚获取的时间戳</span></span><br><span class="line">      appendInfo.maxTimestamp = validateAndOffsetAssignResult.maxTimestamp</span><br><span class="line">      appendInfo.offsetOfMaxTimestamp = validateAndOffsetAssignResult.shallowOffsetOfMaxTimestamp</span><br><span class="line">      appendInfo.lastOffset = offset.value - <span class="number">1</span></span><br><span class="line">      appendInfo.recordsProcessingStats = validateAndOffsetAssignResult.recordsProcessingStats</span><br><span class="line">      <span class="keyword">if</span> (config.messageTimestampType == <span class="type">TimestampType</span>.<span class="type">LOG_APPEND_TIME</span>)</span><br><span class="line">        appendInfo.logAppendTime = now</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 重新验证消息大小是否超过max.message.size, 因为修改字段后重新压缩可能导致消息大小改变</span></span><br><span class="line">      <span class="keyword">if</span> (validateAndOffsetAssignResult.messageSizeMaybeChanged) &#123;</span><br><span class="line">        <span class="keyword">for</span> (batch &lt;- validRecords.batches.asScala) &#123;</span><br><span class="line">          <span class="keyword">if</span> (batch.sizeInBytes &gt; config.maxMessageSize) &#123;</span><br><span class="line">            <span class="comment">// 更新stats(略)</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RecordTooLargeException</span>(<span class="string">&quot;Message batch size is %d bytes which exceeds the maximum configured size of %d.&quot;</span></span><br><span class="line">              .format(batch.sizeInBytes, config.maxMessageSize))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// assignOffsets为false的处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 对V2以上版本的消息集, 更新 leader epoch cache</span></span><br><span class="line">    validRecords.batches.asScala.foreach &#123; batch =&gt;</span><br><span class="line">      <span class="keyword">if</span> (batch.magic &gt;= <span class="type">RecordBatch</span>.<span class="type">MAGIC_VALUE_V2</span>)</span><br><span class="line">        _leaderEpochCache.assign(batch.partitionLeaderEpoch, batch.baseOffset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查消息集的总大小是否超过配置的segment.bytes, 即每个日志文件的大小</span></span><br><span class="line">    <span class="keyword">if</span> (validRecords.sizeInBytes &gt; config.segmentSize) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RecordBatchTooLargeException</span>(<span class="string">&quot;Message batch size is %d bytes which exceeds the maximum configured segment size of %d.&quot;</span></span><br><span class="line">        .format(validRecords.sizeInBytes, config.segmentSize))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now that we have valid records, offsets assigned, and timestamps updated, we need to</span></span><br><span class="line">    <span class="comment">// validate the idempotent/transactional state of the producers and collect some metadata</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 验证生产者的 幂等性/事务 状态, 并收集一些元数据</span></span><br><span class="line">    <span class="keyword">val</span> (updatedProducers, completedTxns, maybeDuplicate) = analyzeAndValidateProducerState(validRecords, isFromClient)</span><br><span class="line">    maybeDuplicate.foreach &#123; duplicate =&gt;</span><br><span class="line">      appendInfo.firstOffset = duplicate.firstOffset</span><br><span class="line">      appendInfo.lastOffset = duplicate.lastOffset</span><br><span class="line">      appendInfo.logAppendTime = duplicate.timestamp</span><br><span class="line">      appendInfo.logStartOffset = logStartOffset</span><br><span class="line">      <span class="keyword">return</span> appendInfo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果必要, 执行日志回滚策略, 将当前日志文件备份, 并创建空文件作为当前日志文件</span></span><br><span class="line">    <span class="keyword">val</span> segment = maybeRoll(messagesSize = validRecords.sizeInBytes,</span><br><span class="line">      maxTimestampInMessages = appendInfo.maxTimestamp,</span><br><span class="line">      maxOffsetInMessages = appendInfo.lastOffset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> logOffsetMetadata = <span class="type">LogOffsetMetadata</span>(</span><br><span class="line">      messageOffset = appendInfo.firstOffset,</span><br><span class="line">      segmentBaseOffset = segment.baseOffset,</span><br><span class="line">      relativePositionInSegment = segment.size)</span><br><span class="line"></span><br><span class="line">    segment.append(firstOffset = appendInfo.firstOffset,</span><br><span class="line">      largestOffset = appendInfo.lastOffset,</span><br><span class="line">      largestTimestamp = appendInfo.maxTimestamp,</span><br><span class="line">      shallowOffsetOfMaxTimestamp = appendInfo.offsetOfMaxTimestamp,</span><br><span class="line">      records = validRecords)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新生产者状态</span></span><br><span class="line">    <span class="keyword">for</span> ((producerId, producerAppendInfo) &lt;- updatedProducers) &#123;</span><br><span class="line">      producerAppendInfo.maybeCacheTxnFirstOffsetMetadata(logOffsetMetadata)</span><br><span class="line">      producerStateManager.update(producerAppendInfo)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update the transaction index with the true last stable offset. The last offset visible</span></span><br><span class="line">    <span class="comment">// to consumers using READ_COMMITTED will be limited by this value and the high watermark.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 用最新的稳定offset更新事务</span></span><br><span class="line">    <span class="keyword">for</span> (completedTxn &lt;- completedTxns) &#123;</span><br><span class="line">      <span class="keyword">val</span> lastStableOffset = producerStateManager.completeTxn(completedTxn)</span><br><span class="line">      segment.updateTxnIndex(completedTxn, lastStableOffset)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    producerStateManager.updateMapEndOffset(appendInfo.lastOffset + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 nextOffsetMetadata 为 lastOffset+1, 回顾之前if (assignOffsets)分支</span></span><br><span class="line">    <span class="comment">// 在下一批消息到达时, 该offset即新消息集的第1个消息的绝对offset</span></span><br><span class="line">    updateLogEndOffset(appendInfo.lastOffset + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> update the first unstable offset (which is used to compute LSO)</span></span><br><span class="line">    updateFirstUnstableOffset()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// trace日志(略)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若未冲刷的消息数量(利用LEO减去recoverPoint得到)达到了配置的&quot;flush.messages&quot;则冲刷消息</span></span><br><span class="line">    <span class="keyword">if</span> (unflushedMessages &gt;= config.flushInterval)</span><br><span class="line">      flush()</span><br><span class="line"></span><br><span class="line">    appendInfo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释中标出TODO的部分暂时还不了解原理，包括且不限于：</p>
<ul>
<li>leader epoch；</li>
<li>对事务的支持；</li>
<li>stable offset（似乎也是用于事务？）</li>
</ul>
<h2 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h2><p>首先是代码逻辑的大体流程：</p>
<ol>
<li><code>records.batches</code>为一组Record Batch，对每个batch都校验CRC是否合法，字节数是否超过配置<code>max.message.bytes</code>；</li>
<li>若存在不合法的batch，则会抛出异常最终被<code>ReplicaManager.appendToLocalLog</code>捕获（仅限于Produce请求处理的情况），生成包含错误的响应；</li>
<li>利用records计算出第1条消息和最后1条消息的offset，消息集的数量，合法batch的字节数之和，消息offset是否单调递增，以及消息集的编码方式，构造要返回的<code>LogAppendInfo</code>对象，记为<code>info</code>；</li>
<li>验证合法消息的数量，并截断不合法的字节数，得到<code>validRecords</code>；（<strong>TODO：此处实现似乎不合理，因为存在不合法的batch直接就抛异常了，但当前最新版本2.3的Kafka源码也是这么处理的</strong>）</li>
<li>检测内存映射缓存是否被关闭；</li>
<li>将LEO赋给<code>info.firstOffset</code>，并取得当前时间戳<code>now</code>；</li>
<li>更新<code>validRecords</code>的offset为绝对offset，若batch是压缩的则重新压缩，将最后1条消息的offset赋给<code>info.lastOffset</code>，并设置<code>info</code>的消息集最大时间戳及对应消息的offset；</li>
<li>若时间戳类型为<code>LOG_APPEND_TIME</code>，将<code>now</code>赋给<code>info.logAppendTime</code>（默认为-1）；</li>
<li>若重新压缩的<code>validRecords</code>字节数发生变化，重新检查每个<code>batch</code>的字节数是否超过配置<code>max.message.bytes</code>；</li>
<li>检查<code>validRecords</code>字节数是否超过配置<code>log.segments.bytes</code>；</li>
<li>取得当前的<code>LogSegment</code>对象，将<code>validRecords</code>添加进去；</li>
<li>更新LEO为<code>validRecords</code>最后1条消息的offset+1；</li>
<li>若未冲刷的消息数量超过了配置<code>flush.messages</code>，则将所有<code>LogSegments</code>写入本地磁盘。</li>
</ol>
<p>核心还是用绝对offset替换相对offset。生产者向服务端发送请求时，由于不知道消息集落盘时的offset，所以只能设置offsets为0,1,2,…n-1，也就是相对offset。而分区的leader broker则维护了其LEO，因此收到请求时，会将offsets修改为LEO,LEO+1,LEO+2,…LEO+n-1，最后将LEO更新为LEO+n。而更新的offsets会包含在响应里发送给生产者，这样客户端就可以通过消息送达的回调函数得到发送消息的绝对offset。</p>
<p>每个<code>Log</code>对应1个分区的消息日志，而消息日志是分为多个文件（日志片段，Log Segment）对应<code>LogSegment</code>对象，负责实际写入磁盘。</p>
<p>这里回顾用到的3个Kafka服务端配置：</p>
<ul>
<li><code>max.message.bytes</code>：每个消息集的最大字节数（这是0.11开始的含义，见<a target="_blank" rel="noopener" href="https://kafka.apache.org/11/documentation.html#upgrade_11_message_format">upgrade 0.11 message format</a>；</li>
<li><code>log.segment.bytes</code>：Log Segment的最大字节数（所以需要检测消息集字节数是否超过这个值，否则即使新建文件写入消息集，也无法容纳整个消息集）；</li>
<li><code>flush.messages</code>（Topic级别）：允许<code>LogSegment</code>对象缓存的消息数量，如果缓存消息数超过了该配置就会调用<code>fsync</code>写入磁盘。</li>
</ul>
<p>此外，<strong>Record Batch</strong>即<strong>消息集（Message Set）</strong>，Record（记录）即Message（消息）。之所以这里区分，是因为从Kafka 0.11版本开始，消息集的概念发生了变化。在此之前，消息集仅仅是一组消息之前加上Log Overhead（即offset和message size）。而Kafka 0.11版本新增了，V2版本的消息集，增加了独有的header，比如第1条消息和最后1条消息的offset可直接通过header计算得到，还有些其他字段是leader epoch以及实现事务相关的字段。而每条消息（记录）的key和value用varint而非固定4字节的int表示长度，并且消息本身也有header。</p>
<p>具体参考：<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets">https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/07/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB07-Produce%E8%AF%B7%E6%B1%82-2-%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/07/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB07-Produce%E8%AF%B7%E6%B1%82-2-%E5%8F%91%E9%80%81%E5%93%8D%E5%BA%94/" class="post-title-link" itemprop="url">Kafka源码阅读07: Produce请求(2): 发送响应</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-07 17:22:33" itemprop="dateCreated datePublished" datetime="2019-11-07T17:22:33+08:00">2019-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前文回顾"><a href="#前文回顾" class="headerlink" title="前文回顾"></a>前文回顾</h2><p>前一篇阅读了<code>appendToLocalLog</code>的部分，服务端在收到Produce请求时，会首先将消息写入本地消息日志：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sTime = time.milliseconds <span class="comment">// 取得当前毫秒级时间戳</span></span><br><span class="line"><span class="keyword">val</span> localProduceResults = appendToLocalLog(internalTopicsAllowed = internalTopicsAllowed,</span><br><span class="line">  isFromClient = isFromClient, entriesPerPartition, requiredAcks)</span><br><span class="line"><span class="comment">// 调试信息: 再次取得时间戳, 相减得到 appendToLocalLog 的用时</span></span><br><span class="line">debug(<span class="string">&quot;Produce to local log in %d ms&quot;</span>.format(time.milliseconds - sTime))</span><br></pre></td></tr></table></figure>

<p>返回的<code>localProduceResults</code>类型是<code>Map[TopicPartition, LogAppendResult]</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常结果: info有效，exception为None</span></span><br><span class="line"><span class="comment">// 错误结果: info各字段设为无效值，exception为某种异常，可通过error方法取得其错误信息</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAppendResult</span>(<span class="params">info: <span class="type">LogAppendInfo</span>, exception: <span class="type">Option</span>[<span class="type">Throwable</span>] = <span class="type">None</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">error</span></span>: <span class="type">Errors</span> = exception <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Errors</span>.<span class="type">NONE</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(e) =&gt; <span class="type">Errors</span>.forException(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>info</code>字段来自于<code>Log.appendAsLeader</code>的返回值，即实际添加到本地日志的消息，包含消息集的第1条消息和最后1条消息的offset（生产者在发送消息集时是不知道最后写入日志文件时消息的offset，只有在服务端写入日志时才会设置）。</p>
<p>接下来阅读<code>ReplicaManager.appendRecords</code>中的后续处理。</p>
<h2 id="ProducePartitionStatus的处理"><a href="#ProducePartitionStatus的处理" class="headerlink" title="ProducePartitionStatus的处理"></a>ProducePartitionStatus的处理</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分区对应的处理结果转换成 ProducePartitionStatus 对象</span></span><br><span class="line"><span class="keyword">val</span> produceStatus = localProduceResults.map &#123; <span class="keyword">case</span> (topicPartition, result) =&gt;</span><br><span class="line">  topicPartition -&gt;</span><br><span class="line">          <span class="type">ProducePartitionStatus</span>(</span><br><span class="line">            <span class="comment">// lastOffset + 1 代表下一批消息的第1条消息的 offset</span></span><br><span class="line">            result.info.lastOffset + <span class="number">1</span>, <span class="comment">// required offset</span></span><br><span class="line">            <span class="comment">// 利用 LogAppendInfo 的各字段构造 PartitionResponse</span></span><br><span class="line">            <span class="keyword">new</span> <span class="type">PartitionResponse</span>(result.error, result.info.firstOffset, result.info.logAppendTime, result.info.logStartOffset)) <span class="comment">// response status</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 KafkaApis.handleProduceRequest 传入的回调更新 KafkaApis.brokerTopicStats</span></span><br><span class="line">processingStatsCallback(localProduceResults.mapValues(_.info.recordsProcessingStats))</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionResponse</span> </span>&#123;</span><br><span class="line">    public <span class="type">Errors</span> error; <span class="comment">// 错误信息</span></span><br><span class="line">    public long baseOffset; <span class="comment">// 消息集中第1条消息的offset</span></span><br><span class="line">    public long logAppendTime; <span class="comment">// 消息集写入日志文件时的时间戳</span></span><br><span class="line">    public long logStartOffset; <span class="comment">// 消息集写入日志文件时，日志文件的起始offset</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回顾一下，在使用Kafka客户端时，生产者可以通过回调取得消息的元数据，像主题和分区，是在生产者发送前就已知的，但offset和时间戳则是由服务端在此处设置的。见<a target="_blank" rel="noopener" href="https://kafka.apache.org/11/javadoc/index.html?org/apache/kafka/clients/producer/KafkaProducer.html">Kafka 1.1 Producer API</a>的<code>RecordMetadata</code>。</p>
<p>接下来是一个if-else分支</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (delayedProduceRequestRequired(requiredAcks, entriesPerPartition, localProduceResults)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// we can respond immediately</span></span><br><span class="line">  <span class="comment">// 取得 PartitionStatus 作为新的value传进 responseCallback, 即忽略了 offset 字段</span></span><br><span class="line">  <span class="keyword">val</span> produceResponseStatus = produceStatus.mapValues(status =&gt; status.responseStatus)</span><br><span class="line">  responseCallback(produceResponseStatus)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>delayedProduceRequestRequired</code>返回<code>false</code>，则可以立刻发送响应，而且忽略了offset字段，因为该字段代表了下一批消息的第1个offset，而<code>PartitionStatus</code>本身就包含当前消息集的<code>baseOffset</code>。</p>
<p>那么为何else分支就意味着可以立刻发送响应呢？</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">delayedProduceRequestRequired</span></span>(requiredAcks: <span class="type">Short</span>,</span><br><span class="line">                                          entriesPerPartition: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">MemoryRecords</span>],</span><br><span class="line">                                          localProduceResults: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">LogAppendResult</span>]): <span class="type">Boolean</span> = &#123;</span><br><span class="line">  requiredAcks == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">  entriesPerPartition.nonEmpty &amp;&amp;</span><br><span class="line">  <span class="comment">// exception字段为Option类型，若不为None则isDefined返回true</span></span><br><span class="line">  localProduceResults.values.count(_.exception.isDefined) &lt; entriesPerPartition.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，if分支意味着以下条件满足：</p>
<ol>
<li><code>requiredAcks</code>为-1，即生产者要等待分区的所有ISR收到消息后才会返回；</li>
<li><code>entriesPerPartition</code>不为空，即存在需要添加消息的分区；</li>
<li><code>localProduceResults</code>中至少存在1条成功的结果。</li>
</ol>
<p>相应地，else分支对应的是：</p>
<ol>
<li><code>requiredAcks</code>为0或1，即客户端无需等待服务端的响应或者只需要等待leader收到消息；</li>
<li>没有消息需要写入（无论是没有可写入的分区还是全部消息写入出现异常），那么ISR也没必要去从leader复制数据，因此也可以直接返回响应。</li>
</ol>
<p>PS：第2个条件在处理Produce请求是是多余的判断，因为之前在<code>KafkaApis.handleProduceRequest</code>中已经判断过了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (authorizedRequestInfo.isEmpty)</span><br><span class="line">  sendResponseCallback(<span class="type">Map</span>.empty)</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="comment">// authorizedRequestInfo非空, 传入参数entriesPerPartition</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  replicaManager.appendRecords(</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    entriesPerPartition = authorizedRequestInfo,</span><br><span class="line">    <span class="comment">/* ... */</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说if分支里会等待所有ISR收到消息才会返回，查看if分支：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造 DelayedProduce 对象, 注意 timeout 仅在此处使用</span></span><br><span class="line"><span class="keyword">val</span> produceMetadata = <span class="type">ProduceMetadata</span>(requiredAcks, produceStatus)</span><br><span class="line"><span class="keyword">val</span> delayedProduce = <span class="keyword">new</span> <span class="type">DelayedProduce</span>(timeout, produceMetadata, <span class="keyword">this</span>, responseCallback, delayedProduceLock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 topic 和 partition 创建用于延迟生产操作的key</span></span><br><span class="line"><span class="keyword">val</span> producerRequestKeys = entriesPerPartition.keys.map(<span class="keyword">new</span> <span class="type">TopicPartitionOperationKey</span>(_)).toSeq</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试立刻完成请求, 否则会将请求放入 purgatory 中, 因为在创建 DelayedProduce 对象时,</span></span><br><span class="line"><span class="comment">// 新的请求可能会到达, 从而使得这个操作处于可完成状态</span></span><br><span class="line">delayedProducePurgatory.tryCompleteElseWatch(delayedProduce, producerRequestKeys)</span><br></pre></td></tr></table></figure>

<p>还是利用了purgatory，先不研究其实现细节，大致可以理解为，创建一个<code>DelayedProduce</code>对象，传入带offset和时间戳的消息集，设置timeout和响应回调，就能完成延迟生产。而purgatory只是用来确认是否完成，若没完成则将其扔进purgatory中。</p>
<p>也就是说，响应回调不再是像else分支（以及之前的错误处理分支）中一样由当前线程去调用，而是由<code>DelayedProduce</code>对象去调用，从而实现了异步的方式等待所有ISR收到最新的消息，避免leader的<code>Handler</code>线程阻塞在<code>KafkaApis</code>对请求的处理中。</p>
<p>另外，值得注意的是<code>timeout</code>是在构造这个<code>DelayedProduce</code>对象时才使用，也就是之前的写入本地日志的时间是不计算在内的，当然网络传输时间也是，可以回顾<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/11/06/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB06-Produce%E8%AF%B7%E6%B1%82-1-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97/">上一篇阅读笔记</a> 的<strong>2.1 请求格式</strong>中翻译的官网对<code>timeout</code>的说明。</p>
<h2 id="sendResponseCallback"><a href="#sendResponseCallback" class="headerlink" title="sendResponseCallback"></a>sendResponseCallback</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendResponseCallback</span></span>(responseStatus: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">PartitionResponse</span>]) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并 responseStatus 和之前认证失败或者主题不存在产生的错误响应</span></span><br><span class="line">  <span class="keyword">val</span> mergedResponseStatus = responseStatus ++ unauthorizedTopicResponses ++ nonExistingTopicResponses</span><br><span class="line">  <span class="keyword">var</span> errorInResponse = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查是否有错误响应, 若有则将 errorInResponse 置为 true, 并将错误写入debug日志</span></span><br><span class="line">  mergedResponseStatus.foreach &#123; <span class="keyword">case</span> (topicPartition, status) =&gt;</span><br><span class="line">    <span class="keyword">if</span> (status.error != <span class="type">Errors</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      errorInResponse = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 写入debug日志(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">produceResponseCallback</span></span>(bandwidthThrottleTimeMs: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (produceRequest.acks == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// acks为0意味着客户端无需等待服务端响应, 因此服务端无需操作</span></span><br><span class="line">      <span class="comment">// 但是如果请求存在错误, 服务端需要关闭socket来通知客户端有错误发生, 然后更新元数据</span></span><br><span class="line">      <span class="keyword">if</span> (errorInResponse) &#123; <span class="comment">// 存在错误响应</span></span><br><span class="line">        <span class="comment">// 首先转换成 Map[TopicPartition, String], 其value为异常的类型名称, 然后将其字符串表示写入日志</span></span><br><span class="line">        <span class="keyword">val</span> exceptionsSummary = mergedResponseStatus.map &#123; <span class="keyword">case</span> (topicPartition, status) =&gt;</span><br><span class="line">          topicPartition -&gt; status.error.exceptionName</span><br><span class="line">        &#125;.mkString(<span class="string">&quot;, &quot;</span>)</span><br><span class="line">        <span class="comment">// 写入info日志(略)</span></span><br><span class="line">        closeConnection(request, <span class="keyword">new</span> <span class="type">ProduceResponse</span>(mergedResponseStatus.asJava).errorCounts)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不存在错误响应</span></span><br><span class="line">        sendNoOpResponseExemptThrottle(request)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// acks为1或者-1</span></span><br><span class="line">      sendResponseMaybeThrottle(request, requestThrottleMs =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">ProduceResponse</span>(mergedResponseStatus.asJava, bandwidthThrottleTimeMs + requestThrottleMs))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// When this callback is triggered, the remote API call has completed</span></span><br><span class="line">  <span class="comment">// 无论是在哪个处理分支, 这个回调函数必定是在远程API调用结束后才触发</span></span><br><span class="line">  request.apiRemoteCompleteTimeNanos = time.nanoseconds</span><br><span class="line"></span><br><span class="line">  quotas.produce.maybeRecordAndThrottle(</span><br><span class="line">    request.session.sanitizedUser, <span class="comment">// session认证用户名(没配置SSL认证则是ANONYMOUS)</span></span><br><span class="line">    request.header.clientId,</span><br><span class="line">    numBytesAppended,</span><br><span class="line">    produceResponseCallback)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是接着之前的进行阅读，所以用到了一些之前创建的对象，见<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/11/06/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB06-Produce%E8%AF%B7%E6%B1%82-1-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97/">上一篇阅读笔记</a>的<strong>handleProduceRequest</strong>：</p>
<ul>
<li><code>unauthorizedTopicResponses</code>：对调用<code>KafkaApis.authorize</code>方法认证失败的请求生成的错误响应；</li>
<li><code>nonExistingTopicResponses</code>：对目标主题不在<code>KafkaApis.metadataCache</code>中的请求生产的错误响应；</li>
<li><code>numBytesAppended</code>：请求的总字节数，包含header部分。</li>
</ul>
<p>检测出是否有错误响应是为了传给<code>produceResponseCallback</code>，从而在acks为0时，关闭与客户端的socket连接来通知其更新元数据。而该回调被传入了<code>ClientQuotaManager.maybeRecordAndThrottle</code>方法，在未启用quotas的情况下会直接调用<code>produceResponseCallback</code>，分为以下3种情况：</p>
<ol>
<li><p>acks为0，且存在错误响应：关闭与客户端的连接，会引起客户端更新元数据；</p>
</li>
<li><p>acks为0，且不存在错误响应：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendNoOpResponseExemptThrottle(request)</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sendNoOpResponseExemptThrottle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  quotas.request.maybeRecordExempt(request)</span><br><span class="line">  sendResponse(request, <span class="type">None</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会进入<code>KafkaApis.sendResponse</code>的<code>None</code>分支：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">None</span>, <span class="type">NoOpAction</span>, <span class="type">None</span>))</span><br></pre></td></tr></table></figure>

<p>回顾<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/09/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB02-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BAcceptor%E5%92%8CProcessor/">网络层阅读的之Acceptor和Processor</a>的<strong>4.2 processNewResponses</strong>，如果响应的类型是<code>NoOpAction</code>，只会给<code>Processor</code>与客户端的连接<code>Channel</code>重新注册读事件，并不会发送响应给客户端。</p>
</li>
<li><p>acks不为0：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendResponseMaybeThrottle(request,</span><br><span class="line">  requestThrottleMs =&gt; <span class="keyword">new</span> <span class="type">ProduceResponse</span>(mergedResponseStatus.asJava, bandwidthThrottleTimeMs + requestThrottleMs))</span><br></pre></td></tr></table></figure>

<p>创建<code>ProduceResponse</code>的<code>throttleMs</code>为<code>bandwidthThrottleTimeMs</code>和<code>requestThrottleMs</code>之和，这两者都有各自对应的quotas对象，若未启用则为0。最终也会进入<code>KafkaApis.sendResponse</code>中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> responseSend = request.context.buildResponse(response)</span><br><span class="line"><span class="keyword">val</span> responseString =</span><br><span class="line">  <span class="keyword">if</span> (<span class="type">RequestChannel</span>.isRequestLoggingEnabled) <span class="type">Some</span>(response.toString(request.context.apiVersion))</span><br><span class="line">  <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">Some</span>(responseSend), <span class="type">SendAction</span>, responseString))</span><br></pre></td></tr></table></figure>

<p>将<code>SendAction</code>类型的响应通过<code>RequestChannel</code>交给<code>Processor</code>，进一步发送给客户端。</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇阅读了处理Produce请求的流程，接着写入本地日志后的代码继续阅读：</p>
<p>写入本地日志后会返回处理结果，包含了每个请求写入的分区的相关状态，新增了消息集的<code>baseOffset</code>和写入日志的时间戳。对于acks字段为-1的情况，将timeout字段&#x2F;消息集以及发送响应的回调丢给<code>DelayedOperation</code>对象进行异步的延迟操作，并通过purgatory字段检查异步处理的结果。</p>
<p>无论是<code>KafkaApis</code>本身，还是<code>DelayedOperation</code>，处理完后都会调用<code>sendResponseCallback</code>，acks不为0则根据Produce响应协议构造响应发送给客户端，acks为0则根据是否有错误响应而有不同的行为，若不包含错误响应则不进行操作，否则关闭socket，触发客户端重新获取元数据。</p>
<p>至此，完成了服务端对Produce请求的阅读，但是有不少细节没有深入，有待进一步阅读：</p>
<ul>
<li><code>DelayedOperation</code>与<code>DelayedOperationPurgatory</code>：延迟操作的实现；</li>
<li><code>Log</code>类，对本地日志目录和日志片段（segment）文件直接操作；</li>
<li><code>Partition</code>类，管理了分区的副本broker，还有leader epoch等。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/06/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB06-Produce%E8%AF%B7%E6%B1%82-1-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/06/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB06-Produce%E8%AF%B7%E6%B1%82-1-%E5%86%99%E5%85%A5%E6%9C%AC%E5%9C%B0%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">Kafka源码阅读06: Produce请求(1): 写入本地日志</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-06 18:43:19" itemprop="dateCreated datePublished" datetime="2019-11-06T18:43:19+08:00">2019-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前一节介绍了<code>Message</code>的格式及其实现，本来是继续阅读<code>MessageSet</code>，但后来发现在Kafka 0.11.0之后<code>Message</code>和<code>MessageSet</code>（消息集）发生了较大改变，详细参考<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets">Kafka Protocol - Messagesets</a>，实际和生产者消费者交互的是<code>RecordBatch</code>而非<code>MessageSet</code>，原来的<code>MessageSet</code>只是简单地在若干<code>Message</code>之前加入offset字段和消息数量字段，现在的<code>RecordBatch</code>多了不少字段，比如<code>ProducerId</code>&#x2F;<code>ProducerEpoch</code>等。目前脱离了对API协议的实际处理过程去看这些数据结构的实现很难明白其实际意义，因此先阅读API请求。</p>
<p>本文就先阅读生产者的请求，其类型为<strong>Produce</strong>，对应<code>KafkaApis.handle()</code>中的下列分支：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProduceRequest(request)</span><br></pre></td></tr></table></figure>

<h2 id="Produce协议"><a href="#Produce协议" class="headerlink" title="Produce协议"></a>Produce协议</h2><p>本节参考<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ProduceAPI">Produce API</a>。Produce API使用通用的消息集格式，由于在发送时无法确定消息的offset，因此生产者可以随意填充该字段。</p>
<h3 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h3><p>Kafka 1.1使用的Produce请求是v2（实际上和v0及v1相同）：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ProduceRequest</span> =&gt; RequiredAcks Timeout [TopicName [Partition MessageSetSize MessageSet]]</span><br><span class="line">  <span class="attr">RequiredAcks</span> =&gt; int16</span><br><span class="line">  <span class="attr">Timeout</span> =&gt; int32</span><br><span class="line">  <span class="attr">Partition</span> =&gt; int32</span><br><span class="line">  <span class="attr">MessageSetSize</span> =&gt; int32</span><br></pre></td></tr></table></figure>

<p>这种描述格式是Kafka wiki的标准请求格式，<code>field =&gt; type</code>代表字段<code>field</code>是<code>type</code>类型，<code>field =&gt; [type]</code>代表<code>field</code>字段包含若干个<code>type</code>类型，也就是<code>[]</code>代表数组。</p>
<p>因此这里的消息请求的格式，可以看作包含1个2字节整型<code>RequiredAcks</code>，1个4字节整型<code>Timeout</code>，接下来是N个结构，每个结构都有1个<code>TopicName</code>，以及若干个子结构，每个子结构由1个<code>Partition</code>&#x2F;<code>MessageSetSize</code>&#x2F;<code>MessageSet</code>组成。</p>
<p>然后介绍官方对上述参数的定义：</p>
<ul>
<li><p><code>RequiredAcks</code>（下文简称acks）</p>
<p>指定服务端在响应请求之前应该受到多少确认（ack）:</p>
<ul>
<li>0：服务器不发送任何响应（这是服务器不回复请求的唯一情况）；</li>
<li>1：服务器在等待数据写入本地日志后才会发送响应；</li>
<li>-1：服务器在等待所有同步副本提交消息之后才发送响应。</li>
</ul>
<p>0和1很好理解，0就是生产者发完就不管了，1就是等待消息被写入本地日志之后再返回，这里涉及到<strong>同步副本（isr，in-sync replicas）</strong>这个概念。这里简单介绍下。用Kafka自带脚本创建topic时会指定<code>--replication-factor</code>，也就是消息日志的复制数量，此时会创建多个<strong>副本（replicas）</strong>来保存消息日志，在<strong>Leader</strong>写入消息日志到本地时，副本也会从Leader取得消息，写入到自己的消息日志。暂且不提其同步过程，可以认为目前存活且消息写入跟上Leader的副本就是同步副本。</p>
</li>
<li><p><code>Timeout</code></p>
<p>服务器可以等待<code>RequiredAcks</code>指定数量的确认所用的最长时间，单位：ms。这个参数并不是请求时间的确切限制，因为：</p>
<ol>
<li>网络传输延迟不包含在内；</li>
<li>计时器在处理请求时才开始，因此如果很多请求正在排队等待处理，那么这个等待时间不包含在内；</li>
<li>我们不会终止本地写操作，因此如果本地写入时间超时，将不予考虑，要获得这种类型的超时，客户端应该使用socket的超时。</li>
</ol>
</li>
<li><p><code>TopicName</code>：发布数据的目标主题；</p>
</li>
<li><p><code>Partition</code>：发布数据的目标分区；</p>
</li>
<li><p><code>MessageSetSize</code>：紧接着的<code>MessageSet</code>字段的字节数；</p>
</li>
<li><p><code>MessageSet</code>：消息集的标准格式，参考<a target="_blank" rel="noopener" href="https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets">Protocol - Messagesets</a>，注意Kafka 1.1使用的是v2版本的RecordBatch。</p>
</li>
</ul>
<h3 id="响应格式"><a href="#响应格式" class="headerlink" title="响应格式"></a>响应格式</h3><p>Kafka 1.1使用的是0.10.0后支持的v2版本，因此v0版本和0.9.0后支持的v1版本就先无视了。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ProduceResponse</span> =&gt; [TopicName [Partition ErrorCode <span class="literal">Off</span>set Timestamp]] ThrottleTime</span><br><span class="line">  <span class="attr">TopicName</span> =&gt; string</span><br><span class="line">  <span class="attr">Partition</span> =&gt; int32</span><br><span class="line">  <span class="attr">ErrorCode</span> =&gt; int16</span><br><span class="line">  <span class="attr">Offset</span> =&gt; int64</span><br><span class="line">  <span class="attr">Timestamp</span> =&gt; int64</span><br><span class="line">  <span class="attr">ThrottleTime</span> =&gt; int32</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Topic</code>：响应对应的主题；</p>
</li>
<li><p><code>Partition</code>：响应对应的分区；</p>
</li>
<li><p><code>ErrorCode</code>：当前分区的错误码；</p>
<p>错误码是基于分区的，因为指定分区可能不可用或者无法在其他主机上维护而其他分区可能成功接受了Produce请求；</p>
</li>
<li><p><code>Offset</code>：赋值给消息集中第1条消息的offset；</p>
</li>
<li><p><code>Timestamp</code>：从UTC epoch至今的毫秒数，根据时间戳类型有不同的设定：</p>
<ul>
<li>时间戳类型为<code>LogAppendTime</code>，则为broker赋值给该消息集的时间戳，消息集内的所有内部消息都拥有同一个时间戳；</li>
<li>时间戳类型为<code>CreateTime</code>，则该字段总是-1。</li>
</ul>
<p>如果没有错误码返回，那么生产者可以认为Produce请求的时间戳已被broker接受。</p>
</li>
<li><p><code>ThrottleTime</code>：由于超过了quota（限额）而导致请求被限流的时间间隔，单位：毫秒。</p>
</li>
</ul>
<h2 id="handleProduceRequest"><a href="#handleProduceRequest" class="headerlink" title="handleProduceRequest"></a>handleProduceRequest</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleProduceRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 ByteBuffer 类型的请求解析成 ProduceRequest 类型</span></span><br><span class="line">  <span class="keyword">val</span> produceRequest = request.body[<span class="type">ProduceRequest</span>]</span><br><span class="line">  <span class="comment">// 取得请求的总字节数, 包含 header 和 body</span></span><br><span class="line">  <span class="keyword">val</span> numBytesAppended = request.header.toStruct.sizeOf + request.sizeOfBodyInBytes</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>header</code>和<code>sizeofBodyInBytes</code>在<code>network.RequestChannel</code>类中定义</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span>(<span class="params">/* ... */</span></span></span><br><span class="line"><span class="params"><span class="class">              val context: <span class="type">RequestContext</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">              /* ... */</span></span></span><br><span class="line"><span class="params"><span class="class">              @volatile private var buffer: <span class="type">ByteBuffer</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">              /* ... */</span>) <span class="keyword">extends</span> <span class="title">BaseRequest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> bodyAndSize: <span class="type">RequestAndSize</span> = context.parseRequest(buffer)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">header</span></span>: <span class="type">RequestHeader</span> = context.header</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sizeOfBodyInBytes</span></span>: <span class="type">Int</span> = bodyAndSize.size</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求头之前在<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/09/23/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB03-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BRequestChannel/">网络层阅读之RequestChannel</a>中提过，这里简单回顾下。<code>RequestHeader</code>为Java类，定义在<code>org.apache.kafka.common.requests</code>包中，包含以下字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApiKeys apiKey;    <span class="comment">// 请求类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">short</span> apiVersion;  <span class="comment">// API版本</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String clientId;   <span class="comment">// 用户指定的客户端ID</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> correlationId; <span class="comment">// 用户提供的整数值，将和响应一起返回</span></span><br></pre></td></tr></table></figure>

<p>对应<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html#protocol_messages">消息协议</a>的Headers：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Header <span class="operator">=</span>&gt; api_key api_version correlation_id client_id </span><br><span class="line">  api_key <span class="operator">=</span>&gt; INT16</span><br><span class="line">  api_version <span class="operator">=</span>&gt; INT16</span><br><span class="line">  correlation_id <span class="operator">=</span>&gt; INT32</span><br><span class="line">  client_id <span class="operator">=</span>&gt; NULLABLE_STRING</span><br></pre></td></tr></table></figure>

<p>在<code>Processor</code>处理客户端的请求字节序列时，会调用<code>RequestHeader.parse</code>方法构造请求头，然后和字节序列<code>buffer</code>一起发送给<code>RequestChannel</code>，<code>Handler</code>线程从中取得请求发送给<code>KafkaApis</code>处理。</p>
<p>后面是一些认证相关的代码，调用了<code>authorize</code>方法，由于不影响主要流程，所以暂且跳过，最后会进入以下分支：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> internalTopicsAllowed = request.header.clientId == <span class="type">AdminUtils</span>.<span class="type">AdminClientId</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call the replica manager to append messages to the replicas</span></span><br><span class="line"><span class="comment">// 传入replicaManager来添加消息到副本上</span></span><br><span class="line">replicaManager.appendRecords(</span><br><span class="line">  timeout = produceRequest.timeout.toLong, <span class="comment">// Produce请求的timeout字段</span></span><br><span class="line">  requiredAcks = produceRequest.acks, <span class="comment">// Produce请求的acks字段</span></span><br><span class="line">  internalTopicsAllowed = internalTopicsAllowed, <span class="comment">// client id是否为__admin_client</span></span><br><span class="line">  isFromClient = <span class="literal">true</span>, <span class="comment">// 这里是处理客户端的Produce请求，所以为true</span></span><br><span class="line">  entriesPerPartition = authorizedRequestInfo, <span class="comment">// 通过认证的请求信息</span></span><br><span class="line">  responseCallback = sendResponseCallback, <span class="comment">// 发送响应的回调函数</span></span><br><span class="line">  processingStatsCallback = processingStatsCallback) <span class="comment">// 处理stats的回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// if the request is put into the purgatory, it will have a held reference and hence cannot be garbage collected;</span></span><br><span class="line"><span class="comment">// hence we clear its data here in order to let GC reclaim its memory since it is already appended to log</span></span><br><span class="line">produceRequest.clearPartitionRecords() <span class="comment">// 简单将Produce请求的partitionRecords置为null</span></span><br></pre></td></tr></table></figure>

<p>留意最后的操作，提到了<strong>purgatory</strong>这个概念：如果请求被放入purgatory，那么就会被（purgatory）持有引用，因此将其置为<code>null</code>防止被垃圾收集。也是之后涉及再看。</p>
<p>其中，<code>entriesPerPartition</code>是之前认证过程得到的信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> authorizedRequestInfo = mutable.<span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">MemoryRecords</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 produceRequest.partitionRecords 取得所有 TopicPartiton 和 MemoryRecords</span></span><br><span class="line"><span class="comment">// ***OrFail 方法仅仅检查 partitionRecords 字段是否为 null, 若为 null 则抛出异常</span></span><br><span class="line"><span class="keyword">for</span> ((topicPartition, memoryRecords) &lt;- produceRequest.partitionRecordsOrFail.asScala) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!authorize(request.session, <span class="type">Write</span>, <span class="keyword">new</span> <span class="type">Resource</span>(<span class="type">Topic</span>, topicPartition.topic)))</span><br><span class="line">    unauthorizedTopicResponses += topicPartition -&gt; <span class="keyword">new</span> <span class="type">PartitionResponse</span>(<span class="type">Errors</span>.<span class="type">TOPIC_AUTHORIZATION_FAILED</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!metadataCache.contains(topicPartition.topic))</span><br><span class="line">    nonExistingTopicResponses += topicPartition -&gt; <span class="keyword">new</span> <span class="type">PartitionResponse</span>(<span class="type">Errors</span>.<span class="type">UNKNOWN_TOPIC_OR_PARTITION</span>)</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 通过了 authorize 方法认证, 并且 metadataCache 包含该 topic</span></span><br><span class="line">    authorizedRequestInfo += (topicPartition -&gt; memoryRecords)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Idea调试"><a href="#Idea调试" class="headerlink" title="Idea调试"></a>Idea调试</h3><p>追根刨底去看<code>metadataCache</code>的构造和读取略麻烦，而且偏离了我们这篇文章的核心目的（了解Kafka怎么处理Produce请求）这里就利用Intellij Idea调试先看看里面到底是什么，也是阅读源码以来第1次调试。</p>
<p>首先<code>zkServer</code>命令启动Zookeeper服务端，然后在Idea中在定义<code>authorizedRequestInfo</code>处设断点，调试模式启动Kafka的core模块（即Kafka服务端），然后启动Kafka客户端，向<code>test</code>主题发送字符串<code>hello</code>，此时可以看到<code>metadataCache</code>的结构：</p>
<ul>
<li><code>brokerId</code> &#x3D; 0</li>
<li><code>cache</code> &#x3D; “HashMap” size &#x3D; 2<ul>
<li>0 &#x3D; …<ul>
<li>_1 &#x3D; “__consumer_offsets”<ul>
<li><code>value</code> &#x3D; {char[18]@5303}</li>
<li><code>hash</code> &#x3D; -970371369</li>
</ul>
</li>
<li>_2 &#x3D; “HashMap” size &#x3D; 50</li>
</ul>
</li>
<li>1 &#x3D; …<ul>
<li>_1 &#x3D; “test”<ul>
<li><code>value</code> &#x3D; {char[4]@5410}</li>
<li><code>hash</code> &#x3D; 3556498</li>
</ul>
</li>
<li>_2 &#x3D; “HashMap” size &#x3D; 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>可见其<code>cache</code>字段为<code>HashMap</code>类型，包含了所有的topic，一个是我们创建的<code>test</code>主题，一个是用来管理消费者提交的offset的<code>__consumer_offsets</code>。</p>
<p>因此保证了<code>authorizedRequestInfo</code>，也就是传入<code>appendRecords</code>的<code>entriesPerPartition</code>参数，它的topic都是目前现有的。</p>
<h2 id="ReplicaManager-appendRecords"><a href="#ReplicaManager-appendRecords" class="headerlink" title="ReplicaManager.appendRecords"></a>ReplicaManager.appendRecords</h2><blockquote>
<p>将消息添加到分区的首领副本，等待它们被复制到其他副本。无论是timeout或者acks的条件被满足，都会触发回调函数。如果回调函数本身已经在某个对象上被同步，那么传递这个对象来避免死锁。</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendRecords</span></span>(timeout: <span class="type">Long</span>,</span><br><span class="line">                  requiredAcks: <span class="type">Short</span>,</span><br><span class="line">                  internalTopicsAllowed: <span class="type">Boolean</span>,</span><br><span class="line">                  isFromClient: <span class="type">Boolean</span>,</span><br><span class="line">                  entriesPerPartition: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">MemoryRecords</span>],</span><br><span class="line">                  responseCallback: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">PartitionResponse</span>] =&gt; <span class="type">Unit</span>,</span><br><span class="line">                  delayedProduceLock: <span class="type">Option</span>[<span class="type">Lock</span>] = <span class="type">None</span>,</span><br><span class="line">                  processingStatsCallback: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">RecordsProcessingStats</span>] =&gt; <span class="type">Unit</span> = _ =&gt; ()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isValidRequiredAcks(requiredAcks)) &#123; <span class="comment">// acks只能为-1，0，1</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// acks 在可接受的范围外, 则客户端肯定出错了, 仅仅返回错误, 而不用处理请求</span></span><br><span class="line">    <span class="comment">// 具体处理: 对每个 TopicPartition 对象, 构造相应的 PartitionResponse 对象组成新的 Map</span></span><br><span class="line">    <span class="comment">//  其中包含 error, baseOffset, logAppendTime, logStartOffset 等字段,</span></span><br><span class="line">    <span class="comment">//  除了 error 字段标明为 acks不合法 外, 其余字段都随意设置</span></span><br><span class="line">    <span class="keyword">val</span> responseStatus = entriesPerPartition.map &#123; <span class="keyword">case</span> (topicPartition, _) =&gt;</span><br><span class="line">      topicPartition -&gt; <span class="keyword">new</span> <span class="type">PartitionResponse</span>(<span class="type">Errors</span>.<span class="type">INVALID_REQUIRED_ACKS</span>,</span><br><span class="line">        <span class="type">LogAppendInfo</span>.<span class="type">UnknownLogAppendInfo</span>.firstOffset, <span class="type">RecordBatch</span>.<span class="type">NO_TIMESTAMP</span>, <span class="type">LogAppendInfo</span>.<span class="type">UnknownLogAppendInfo</span>.logStartOffset)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用传入的回调 responseCallback 将返回值发送回去</span></span><br><span class="line">    responseCallback(responseStatus)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看else分支，可以得知，传入的<code>entriesPerPartition</code>为<code>TopicPartition</code>到<code>MemoryRecords</code>（消息）的<code>Map</code>而传入的<code>responseCallback</code>为发送响应给客户端的回调函数，响应类型也是<code>Map</code>，key也是<code>TopicPartition</code>，只不过value变成了<code>PartitionResponse</code>。也就是说，无论是请求还是响应，都是以分区为单位的，对于错误的响应，只有<code>error</code>字段起作用，而正确的响应是包含<code>baseOffset</code>，<code>logAppendTime</code>和<code>logStartOffset</code>等字段，前2个字段在上一篇<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/10/14/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB05-%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB%E4%B9%8BMessage/">消息协议阅读</a>中简单提过，分别是消息日志中第1个offset以及发送的消息被写入消息日志的时间戳，现在具体阅读acks合法时的处理流程。</p>
<h3 id="time字段"><a href="#time字段" class="headerlink" title="time字段"></a>time字段</h3><p>首先取得毫秒级的<code>time</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sTime = time.milliseconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中<code>time</code>为<code>replicaManager</code>的构造参数，而<code>replicaManager</code>也是<code>KafkaApis</code>的构造参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplicaManager</span>(<span class="params">val config: <span class="type">KafkaConfig</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                     metrics: <span class="type">Metrics</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                     time: <span class="type">Time</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"></span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaApis</span>(<span class="params">val requestChannel: <span class="type">RequestChannel</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                val replicaManager: <span class="type">ReplicaManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"></span></span></span><br></pre></td></tr></table></figure>

<p><code>KafkaApis</code>对象是在<code>KafkaServer</code>的<code>startup</code>方法中创建的，层层追溯如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apis = <span class="keyword">new</span> <span class="type">KafkaApis</span>(socketServer.requestChannel, replicaManager, <span class="comment">/* ... */</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaManager = createReplicaManager(isShuttingDown)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">createReplicaManager</span></span>(isShuttingDown: <span class="type">AtomicBoolean</span>): <span class="type">ReplicaManager</span> =</span><br><span class="line">  <span class="keyword">new</span> <span class="type">ReplicaManager</span>(config, metrics, time, <span class="comment">/* ... */</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaServer</span>(<span class="params">val config: <span class="type">KafkaConfig</span>, time: <span class="type">Time</span> = <span class="type">Time</span>.<span class="type">SYSTEM</span>,</span></span></span><br><span class="line"><span class="params"><span class="class"></span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Time</span> &#123;</span><br><span class="line">    <span class="type">Time</span> <span class="variable">SYSTEM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SystemTime</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见<code>time</code>的<code>SystemTime</code>对象，作为计时器，包含以下常用方法：</p>
<ul>
<li><code>milliseconds</code>：取得毫秒级时间戳；</li>
<li><code>nanoseconds</code>：取得纳秒级时间戳；</li>
<li><code>sleep(long ms)</code>：当前线程休眠指定毫秒数。</li>
</ul>
<p>因此Kafka中一切用到计时器的类都会使用该对象，回过头看<code>appendRecords</code>代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sTime = time.milliseconds <span class="comment">// 取得当前毫秒级时间戳</span></span><br><span class="line"><span class="keyword">val</span> localProduceResults = appendToLocalLog(internalTopicsAllowed = internalTopicsAllowed,</span><br><span class="line">  isFromClient = isFromClient, entriesPerPartition, requiredAcks)</span><br><span class="line"><span class="comment">// 调试信息: 再次取得时间戳, 相减得到 appendToLocalLog 的用时</span></span><br><span class="line">debug(<span class="string">&quot;Produce to local log in %d ms&quot;</span>.format(time.milliseconds - sTime))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说首先会调用<code>appendToLocalLog</code>方法</p>
<h3 id="appendToLocalLog"><a href="#appendToLocalLog" class="headerlink" title="appendToLocalLog"></a>appendToLocalLog</h3><blockquote>
<p>将消息添加到本地副本日志中</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">appendToLocalLog</span></span>(internalTopicsAllowed: <span class="type">Boolean</span>,</span><br><span class="line">                             isFromClient: <span class="type">Boolean</span>,</span><br><span class="line">                             entriesPerPartition: <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">MemoryRecords</span>],</span><br><span class="line">                             requiredAcks: <span class="type">Short</span>): <span class="type">Map</span>[<span class="type">TopicPartition</span>, <span class="type">LogAppendResult</span>] = &#123;</span><br><span class="line">  trace(<span class="string">s&quot;Append [<span class="subst">$entriesPerPartition</span>] to local log&quot;</span>)</span><br><span class="line">  <span class="comment">// 遍历所有客户端请求写入的 topicPartition 以及对应消息 records</span></span><br><span class="line">  entriesPerPartition.map &#123; <span class="keyword">case</span> (topicPartition, records) =&gt;</span><br><span class="line">    <span class="comment">// 更新topicStats，暂时略去不看</span></span><br><span class="line">    brokerTopicStats.topicStats(topicPartition.topic).totalProduceRequestRate.mark()</span><br><span class="line">    brokerTopicStats.allTopicsStats.totalProduceRequestRate.mark()</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">Topic</span>.isInternal(topicPartition.topic) &amp;&amp; !internalTopicsAllowed) &#123;</span><br><span class="line">      <span class="comment">// topic是内部主题: __consumer_offsets 或 __transaction_state, 且 internalTopicsAllowed 为 false</span></span><br><span class="line">      <span class="comment">//  (在 KafkaApis.handleProduceRequest 中, 只有请求的 clientId 为 AdminClientId 时才为 true)</span></span><br><span class="line">      <span class="comment">// 也就是如果不是 Admin 客户端, 尝试写入内部主题则会返回 写入不合法 的 LogAppendResult</span></span><br><span class="line">      (topicPartition, <span class="type">LogAppendResult</span>(</span><br><span class="line">        <span class="type">LogAppendInfo</span>.<span class="type">UnknownLogAppendInfo</span>,</span><br><span class="line">        <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">InvalidTopicException</span>(<span class="string">s&quot;Cannot append to internal topic <span class="subst">$&#123;topicPartition.topic&#125;</span>&quot;</span>))))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 非内部主题, 可以写入</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// 异常处理(略)，会将处理客户端请求的异常信息写入返回结果中</span></span><br><span class="line">        <span class="comment">// 注意，对于用于流程控制的Throwable异常，会单独处理，这里后面再看</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先是区分了消费主题是否为内部主题，比如<code>__consumer_offsets</code>，这种主题并不是存储生产&#x2F;消费的消息的，因此只允许Admin客户端读写。至于<code>brokerTopicStats</code>也是度量指标相关的，暂且略过。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从内部的 allPartitions 中找到 topicPartition, PS: allPartitions 是从本地消息日志中读取的</span></span><br><span class="line"><span class="keyword">val</span> partitionOpt = getPartition(topicPartition)</span><br><span class="line"><span class="keyword">val</span> info = partitionOpt <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(partition) =&gt;</span><br><span class="line">    <span class="comment">// 找到的是 OfflinePartition (当前broker不在分区的ISR列表上) 则会(通过异常处理)返回错误信息</span></span><br><span class="line">    <span class="comment">// https://issues.apache.org/jira/browse/KAFKA-6796 在 Kafka 2.0 中对这种行为进行了修复</span></span><br><span class="line">    <span class="comment">// 比如在分区重分配期间, 客户的Produce请求在本地副本被删除后到达, 此时不应该返回分区不存在的错误</span></span><br><span class="line">    <span class="comment">// 因此2.0中抛出的是 NotLeaderForPartitionException, 会强制让客户端更新元数据来找到新的分区位置</span></span><br><span class="line">    <span class="keyword">if</span> (partition eq <span class="type">ReplicaManager</span>.<span class="type">OfflinePartition</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">KafkaStorageException</span>(<span class="string">s&quot;Partition <span class="subst">$topicPartition</span> is in an offline log directory on broker <span class="subst">$localBrokerId</span>&quot;</span>)</span><br><span class="line">    <span class="comment">// 添加记录到leader副本上</span></span><br><span class="line">    partition.appendRecordsToLeader(records, isFromClient, requiredAcks)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若找不到目标 topicPartition, 则代表生产者向一个未知的分区生产消息, 返回表示分区不存在的结果</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnknownTopicOrPartitionException</span>(<span class="string">&quot;Partition %s doesn&#x27;t exist on %d&quot;</span></span><br><span class="line">    .format(topicPartition, localBrokerId))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 略去更新brokerTopicStats的代码</span></span><br><span class="line"></span><br><span class="line">(topicPartition, <span class="type">LogAppendResult</span>(info))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>处理了2种错误：分区是离线的（Offline）和分区是未知，而对于已知分区，则是将<code>appendRecordsToLeader</code>方法返回的<code>info</code>来构造该分区对应的<code>LogAppendResult</code>作为返回结果。</p>
<p>这里通过<code>getPartition</code>返回的<code>partition</code>类型是<code>Partition</code>，位于<code>cluster</code>包中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Partition</span>(<span class="params">val topic: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                val partitionId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                time: <span class="type">Time</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                replicaManager: <span class="type">ReplicaManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">                val isOffline: <span class="type">Boolean</span> = false</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了主题名<code>topic</code>和分区号<code>partitionId</code>外，还会引用<code>replicaManager</code>用于将信息写入副本中。还通过<code>isOffline</code>来区分分区是否在副本broker上。</p>
<h3 id="Partition-appendRecordsToLeader"><a href="#Partition-appendRecordsToLeader" class="headerlink" title="Partition.appendRecordsToLeader"></a>Partition.appendRecordsToLeader</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">appendRecordsToLeader</span></span>(records: <span class="type">MemoryRecords</span>, isFromClient: <span class="type">Boolean</span>, requiredAcks: <span class="type">Int</span> = <span class="number">0</span>): <span class="type">LogAppendInfo</span> = &#123;</span><br><span class="line">  <span class="comment">// 用读锁保护, 可以多线程添加记录到 leader副本 上, 但是如果ISR更新过程会获取写锁, 此时要等待ISR更新完毕</span></span><br><span class="line">  <span class="keyword">val</span> (info, leaderHWIncremented) = inReadLock(leaderIsrUpdateLock) &#123;</span><br><span class="line">    <span class="comment">// 若leader副本的id为本地的broker id, 则返回对应的 Replica对象</span></span><br><span class="line">    leaderReplicaIfLocal <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(leaderReplica) =&gt; <span class="comment">// leader副本</span></span><br><span class="line">        <span class="keyword">val</span> log = leaderReplica.log.get <span class="comment">// append-only的Log对象</span></span><br><span class="line">        <span class="keyword">val</span> minIsr = log.config.minInSyncReplicas <span class="comment">// min.insync.replicas 配置</span></span><br><span class="line">        <span class="keyword">val</span> inSyncSize = inSyncReplicas.size <span class="comment">// ISR数量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// acks为-1时, 客户端会等待所有ISR确认收到消息时才返回, 此时配置 min.insync.replicas</span></span><br><span class="line">        <span class="comment">// 指定了这个ISR的最小数量, 因此ISR数量不够时会抛出ISR副本太少的异常</span></span><br><span class="line">        <span class="keyword">if</span> (inSyncSize &lt; minIsr &amp;&amp; requiredAcks == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NotEnoughReplicasException</span>(<span class="string">&quot;Number of insync replicas for partition %s is [%d], below required minimum [%d]&quot;</span></span><br><span class="line">            .format(topicPartition, inSyncSize, minIsr))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将消息集写入日志, 分配 offsets 和 分区leader的epoch</span></span><br><span class="line">        <span class="keyword">val</span> info = log.appendAsLeader(records, leaderEpoch = <span class="keyword">this</span>.leaderEpoch, isFromClient)</span><br><span class="line">        <span class="comment">// probably unblock some follower fetch requests since log end offset has been updated</span></span><br><span class="line">        <span class="comment">// 因为 LEO(log end offset) 已经更新了, 所以某些 follower 的 fetch请求可能解除阻塞了, 于是</span></span><br><span class="line">        <span class="comment">// replicaManager.delayedFetchPurgatory 尝试完成该分区的延迟的fetch请求, 因为 LEO(log end offset)已经跟新</span></span><br><span class="line">        replicaManager.tryCompleteDelayedFetch(<span class="type">TopicPartitionOperationKey</span>(<span class="keyword">this</span>.topic, <span class="keyword">this</span>.partitionId))</span><br><span class="line">        <span class="comment">// 因为 ISR 可能只剩1个, 因此可能需要增加HW (high watermark)</span></span><br><span class="line">        (info, maybeIncrementLeaderHW(leaderReplica))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="comment">// 非leader副本</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NotLeaderForPartitionException</span>(<span class="string">&quot;Leader not local for partition %s on broker %d&quot;</span></span><br><span class="line">          .format(topicPartition, localBrokerId))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// some delayed operations may be unblocked after HW changed</span></span><br><span class="line">  <span class="comment">// 一些延迟操作可能因为 HW 的改变而解除阻塞, 因此尝试完成这些延迟请求</span></span><br><span class="line">  <span class="keyword">if</span> (leaderHWIncremented)</span><br><span class="line">    tryCompleteDelayedRequests()</span><br><span class="line"></span><br><span class="line">  info <span class="comment">// log.AppendAsLeader返回的结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有几个方法暂时没看细节，将其列出（对于<code>server</code>包之外的标注包名），之后有可能的话单独阅读：</p>
<ul>
<li><code>log.Log.appendAsLeader</code>：将消息集，分配的offset，leader副本的epoch写入本地消息日志；</li>
<li><code>DelayedOperation.checkAndComplete(key: Any)</code>：检查某些**延迟操作(delayed operations)**用给定的key能否完成，若能则完成；</li>
<li><code>cluster.Partition.maybeIncrementLeaderHW</code>：检查并且可能增加分区的HW，仅当分区ISR改变或者任意副本的LEO改变时才更新。</li>
</ul>
<p>由于本小节涉及到分区的操作，来回顾一些基本概念，每个分区都有多个broker来保存，实现消息的冗余备份，这些broker称为该分区的<strong>副本（replica）</strong>。对每个分区，存在唯一的<strong>leader副本</strong>（通过选举产生），与客户端进行直接读写，而其他副本为<strong>follower</strong>，不断地从leader复制最新的消息。与leader保持同步的follower被称为**ISR(in-sync replica)**，而某些follower会因为某些原因复制速度较慢或者和leader断开连接（通过某种规则判断），此时会从ISR中移除，直到重新跟上进度会重新加入ISR。</p>
<p><strong>HW(high watermark, 高水位)<strong>即最新</strong>已提交的（committed）</strong>消息的offset，即所有ISR的分区日志上都写入了该消息，消费者无法拉取比HW更大的offset，从而保证leader一旦不可用，消费者之前消费的消息存在于任意ISR的消息日志中。</p>
<p>**LEO(log end offset)**是所有副本都会维护的offset，即当前副本最后一个消息的offset+1，也就是如果有新的消息写入，那么它的offset即之前的LEO，而副本将消息写入消息日志后，LEO会递增。</p>
<p>至于<strong>epoch</strong>这个概念是Kafka 0.11引入的，暂时还不清楚具体功能，之后再提。</p>
<h2 id="appendToLocalLog总结"><a href="#appendToLocalLog总结" class="headerlink" title="appendToLocalLog总结"></a>appendToLocalLog总结</h2><p>在之前将客户端发送的请求解析成了<strong>分区</strong>到<strong>消息集</strong>的映射，而返回值是<strong>分区</strong>到<code>LogAppendResult</code>的映射，因此只对遍历整个<code>Map</code>，对每对分区消息集进行处理得到<code>LogAppendResult</code>即可：</p>
<ol>
<li>对<code>__consumer_offsets</code>这样的内部主题，验证请求头的client id是否为管理员（admin）的id，否则返回<em>Cannot append to internal topic</em>的错误；</li>
<li>在<code>ReplicaManager</code>维护的当前broker上的分区列表中找到对应的分区；</li>
<li>若查找失败则返回*Partition … doesn’t exist on …*的错误；</li>
<li>若分区不可用，则返回*Partition … is in an offline log directory on broker …*的错误；</li>
<li>若当前broker不是分区的leader，则返回*Leader not local for partition … on broker …*的错误；</li>
<li>若acks字段为-1，且ISR数量小于<code>min.insync.replicas</code>配置的数量，则返回<em>Number of insync replicas for partition … is … below required minimum</em>的错误；</li>
<li>将消息集写入本地日志，并给当前分区分配offsets和leader epoch；</li>
<li>处理延后处理的Fetch请求，可能更新HW；</li>
<li>若更新HW，则处理延后处理的请求。</li>
</ol>
<p>前面的流程都是一些合法性判断，主要是7~9这几步，待深入阅读的内容：</p>
<ol>
<li>对指定分区，写入日志后如何分配offsets和leader epoch？</li>
<li>延后处理是怎么实现的？</li>
</ol>
<p>关于延后处理，主要是<code>ReplicaManager</code>的以下字段</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> delayedProducePurgatory: <span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedProduce</span>],</span><br><span class="line"><span class="keyword">val</span> delayedFetchPurgatory: <span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedFetch</span>],</span><br><span class="line"><span class="keyword">val</span> delayedDeleteRecordsPurgatory: <span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedDeleteRecords</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>都是<code>Purgatory</code>（炼狱），在辅助构造器中进行默认构造：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedProduce</span>](</span><br><span class="line">  purgatoryName = <span class="string">&quot;Produce&quot;</span>, brokerId = config.brokerId,</span><br><span class="line">  purgeInterval = config.producerPurgatoryPurgeIntervalRequests),</span><br><span class="line"><span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedFetch</span>](</span><br><span class="line">  purgatoryName = <span class="string">&quot;Fetch&quot;</span>, brokerId = config.brokerId,</span><br><span class="line">  purgeInterval = config.fetchPurgatoryPurgeIntervalRequests),</span><br><span class="line"><span class="type">DelayedOperationPurgatory</span>[<span class="type">DelayedDeleteRecords</span>](</span><br><span class="line">  purgatoryName = <span class="string">&quot;DeleteRecords&quot;</span>, brokerId = config.brokerId,</span><br><span class="line">  purgeInterval = config.deleteRecordsPurgatoryPurgeIntervalRequests),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>都是泛型类<code>DelayedOperationPurgatory</code>，类型参数不同。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇开始阅读Produce请求的处理，首先从官网阅读了Kafka 1.1对应的Produce请求和响应协议，然后阅读<code>KafkaApis</code>类的处理方法<code>handleProduceRequest</code>。</p>
<p>跳过了加密&#x2F;认证的部分，实际上是由<code>ReplicaManager</code>来处理，调用<code>appendRecords</code>方法，接受了客户端Produce请求中的acks和timeout两个关键字段。</p>
<p>首先验证acks是否合法（-1, 0 or 1），对不合法acks发送<code>INVALID_REQUIRED_ACKS</code>响应。</p>
<p>然后调用<code>appendToLocalLog</code>方法，也是本篇主要阅读的部分。</p>
<p>之后的处理，以及<code>appendRecords</code>接收的回调函数（比如如何发送响应）的实现，日志的写入，分区的offsets和leader epoch的更新，以及如何延迟处理将在之后进行阅读。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XYZ, aka BewareMyPower</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYZ, aka BewareMyPower</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
