<!DOCTYPE html>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BewareMyPower的博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="BewareMyPower的博客">
<meta property="og:locale">
<meta property="article:author" content="XYZ, aka BewareMyPower">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BewareMyPower的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BewareMyPower的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/14/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB05-%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB%E4%B9%8BMessage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/14/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB05-%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE%E9%98%85%E8%AF%BB%E4%B9%8BMessage/" class="post-title-link" itemprop="url">Kafka源码阅读05-消息协议阅读之Message</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-14 12:42:36" itemprop="dateCreated datePublished" datetime="2019-10-14T12:42:36+08:00">2019-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前阅读了网络层和API层，在阅读API层支持的Kafka协议之前，首先得明确Kafka的消息概念。Kafka服务器被称为<strong>broker</strong>，与其交互的是客户端，分为<strong>生产者（Producer）</strong>和<strong>消费者（Consumer）</strong>，客户端与服务端通过消息进行交互。</p>
<p>Kafka使用日志文件（下文称为<strong>消息日志</strong>）来保存消息，通过<code>log.dirs</code>配置指定日志文件的存放目录。注意这里的日志文件不同于Kafka本身的日志（记录运行时的一些信息）。而对于每个分区，都会在<code>log.dirs</code>下创建一个子目录来存放消息日志，其命名为<code>&lt;topic&gt;-&lt;partition&gt;</code>，在该目录下会有像这样的文件：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line"><span class="number">00000000000000000020.</span><span class="keyword">index</span>  <span class="number">00000000000000000020.</span><span class="keyword">log</span>  <span class="number">00000000000000000020.</span>timeindex  leader-epoch-<span class="keyword">checkpoint</span></span><br></pre></td></tr></table></figure>

<p>同一分区的不同消息是通过offset来唯一标识的，注意它并不是消息在消息日志中实际存储位置的偏移量，而是类似id一样的概念，从0开始递增，表示分区内第offset条消息。</p>
<p>消息日志的命名规则是<code>[baseOffset].log</code>，比如这里的20就是该日志的第<strong>baseOffset</strong>，即消息日志中的第1条消息的offset。相应地，有同名的<code>.index</code>文件，为消息建立了索引方便查询消息，但并没有对每条消息都建立了索引。</p>
<p>因此首先看看Kafka的消息实现，即<code>message</code>包，本文主要讲<code>Message</code>类。</p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p><code>Message</code>类的注释给出了格式说明，如下图所示：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字节数 |<span class="string">   4   </span>|<span class="string">   1   </span>|<span class="string">     1     </span>|<span class="string">     8     </span>|<span class="string">   4    </span>|<span class="string">  K  </span>|<span class="string">  4  </span>|<span class="string">    V    </span>|</span><br><span class="line">字段名 |<span class="string"> CRC32 </span>|<span class="string"> magic </span>|<span class="string"> attribute </span>|<span class="string"> timestamp </span>|<span class="string"> keylen </span>|<span class="string"> key </span>|<span class="string"> len </span>|<span class="string"> payload </span>|</span><br><span class="line">                         /     \</span><br><span class="line">             |<span class="string"> 7 </span>|<span class="string"> 6 </span>|<span class="string"> 5 </span>|<span class="string"> 4 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 1 </span>|<span class="string"> 0 </span>|</span><br><span class="line">                0~2: 压缩类型；3: 时间戳类型 </span><br></pre></td></tr></table></figure>

<p>补充说明：</p>
<ul>
<li><code>magic</code>代表消息格式，其值为0代表v0，为1代表v1；</li>
<li>v0版本的消息使用绝对offset，且不包含<code>timestamp</code>字段，<code>attribute</code>第3位不使用；</li>
<li>v1版本的消息使用相对offset，且包含<code>timestamp</code>字段，<code>attribute</code>第3位为时间戳类型；</li>
<li><code>K</code>是字段<code>keylen</code>的值，<code>V</code>是字段<code>len</code>的值。</li>
</ul>
<h2 id="外部消息和内部消息"><a href="#外部消息和内部消息" class="headerlink" title="外部消息和内部消息"></a>外部消息和内部消息</h2><p>看看消息的主构造器</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>(<span class="params">val buffer: <span class="type">ByteBuffer</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">              private val wrapperMessageTimestamp: <span class="type">Option</span>[<span class="type">Long</span>] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">              private val wrapperMessageTimestampType: <span class="type">Option</span>[<span class="type">TimestampType</span>] = <span class="type">None</span></span>)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>buffer</code>：消息的字节缓冲区；</li>
<li><code>wrapperMessageTimestamp</code>：外部消息的时间戳；</li>
<li><code>wrapperMessageTimestampType</code>：外部消息的时间戳类型；</li>
</ul>
<p>这里的<code>wrapperMessage</code>指的是外部消息，因为Kafka会对多个消息一起进行压缩提高压缩率，所以将N个消息压缩后的消息称为<strong>外部消息</strong>，而这N个消息则称为<strong>内部消息</strong>。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">外部消息offset |<span class="string"> 100 </span>|<span class="string">     105    </span>|<span class="string"> 106 </span>|<span class="string"> 107 </span>|<span class="string"> ...</span></span><br><span class="line"><span class="string">                         /   \ </span></span><br><span class="line"><span class="string">内部消息offset    </span>|<span class="string"> 0 </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|</span><br></pre></td></tr></table></figure>

<p>这样做是因为生产者对一批消息压缩时，它是不知道消息的offset时（因为offset是由broker指定的），所以就简单地将offset字段从0开始依次递增来设置。</p>
<p>而broker在收到这批消息时，它知道前1个消息的offset（比如在这里就是100），也知道生产者发送过来的这批消息的数量（5），那么下一个外部消息的offset就被设置为100+5&#x3D;105。</p>
<p>消费者取得的是外部消息，当消费者通过解压得到每个消息时，可以用外部offset和内部offset计算出内部消息的绝对offset（101~105）。</p>
<h2 id="getter方法"><a href="#getter方法" class="headerlink" title="getter方法"></a>getter方法</h2><p>对这种基于字节的消息协议的实现很简单，利用<code>ByteBuffer</code>对象存储字节序列，然后用伴生对象的常量来指定某个字段的长度（length）和偏移量（offset），从而通过其字节区间[offset, offset + length)访问该字段。</p>
<p>再次注意：这里提到的偏移量指的是字节在缓冲区中的位置，不同于消息的offset。</p>
<p>在<code>Message</code>伴生对象中定义一系列常量来记录各字段的offset和length：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">CrcOffset</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">CrcLength</span> = <span class="number">4</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MagicOffset</span> = <span class="type">CrcOffset</span> + <span class="type">CrcLength</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MagicLength</span> = <span class="number">1</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">AttributesOffset</span> = <span class="type">MagicOffset</span> + <span class="type">MagicLength</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后对于<code>crc</code>和<code>magic</code>这种整型字段的getter方法直接调用<code>ByteBuffer.getInt(index)</code>方法即可（注意不能用<code>getInt()</code>方法，因为它是从内部position开始读的）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checksum</span></span>: <span class="type">Long</span> = <span class="type">ByteUtils</span>.readUnsignedInt(buffer, <span class="type">CrcOffset</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">magic</span></span>: <span class="type">Byte</span> = buffer.get(<span class="type">MagicOffset</span>)</span><br></pre></td></tr></table></figure>

<p>对于多字节的字段<code>crc</code>，使用的是Java类<code>ByteUtils</code>的相关方法，将多个字节转换成目标整型，实际上还是首先调用<code>ByteBuffer</code>的<code>getXXX(index)</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">readUnsignedInt</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> buffer.getInt(index) &amp; <span class="number">0xffffffffL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>key</code>和<code>payload</code>这种运行期才确定长度的字段，其编码方式是用户自定义的，所以只需要返回一个<code>ByteBuffer</code>即可，具体编解码应该在客户端进行：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payload</span></span>: <span class="type">ByteBuffer</span> = sliceDelimited(payloadSizeOffset)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">key</span></span>: <span class="type">ByteBuffer</span> = sliceDelimited(keySizeOffset)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于key字段长度是动态的，所以无法在object中定义payloadSizeOffset常量，而需要在类中取得key的长度后计算而出</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">payloadSizeOffset</span> </span>= &#123;</span><br><span class="line">  <span class="keyword">if</span> (magic == <span class="type">MagicValue_V0</span>) <span class="type">KeyOffset_V0</span> + max(<span class="number">0</span>, keySize)</span><br><span class="line">  <span class="keyword">else</span> <span class="type">KeyOffset_V1</span> + max(<span class="number">0</span>, keySize)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sliceDelimited</span></span>(start: <span class="type">Int</span>): <span class="type">ByteBuffer</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> size = buffer.getInt(start) <span class="comment">// 取得前4个字节表示的长度</span></span><br><span class="line">  <span class="keyword">if</span>(size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="literal">null</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 拷贝一份，防止影响buffer的position，注意这里的拷贝并没拷贝内部的字节序列</span></span><br><span class="line">    <span class="keyword">var</span> b = buffer.duplicate()</span><br><span class="line">    <span class="comment">// 跳过表示长度的4个字节，回顾协议，key和payload之前都有4个字节表示长度</span></span><br><span class="line">    b.position(start + <span class="number">4</span>)</span><br><span class="line">    <span class="comment">// 取得buffer从position开始的子序列，并重置长度和position</span></span><br><span class="line">    <span class="comment">// 之后b就是指向key或payload字段并且长度合适的ByteBuffer了</span></span><br><span class="line">    b = b.slice()</span><br><span class="line">    b.limit(size)</span><br><span class="line">    b.rewind</span><br><span class="line">    b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>Kafka的消息格式在0.10.0的一个重要变化是加入了时间戳字段，见<a target="_blank" rel="noopener" href="https://kafka.apache.org/11/documentation.html#upgrade_10_performance_impact">upgrade to 0.10.0.0</a>，为了保持旧消息的兼容，才有了<code>magic</code>标识是否使用时间戳，并且支持对API版本的请求：<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html#api_versions">Retrieving Supported API versions</a>。值得一看的是<code>timestamp</code>的getter：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timestamp</span></span>: <span class="type">Long</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (magic == <span class="type">MagicValue_V0</span>) <span class="comment">// v0版本的消息不使用时间戳</span></span><br><span class="line">    <span class="type">Message</span>.<span class="type">NoTimestamp</span></span><br><span class="line">  <span class="comment">// 对v1版本的消息，有以下3种Case：</span></span><br><span class="line">  <span class="comment">// 1. 外部消息的时间戳及其类型都为None；</span></span><br><span class="line">  <span class="comment">// 2. 外部消息的时间戳类型为LogAppendTime且时间戳非None；</span></span><br><span class="line">  <span class="comment">// 3. 外部消息的时间戳类型为CreateTime且时间戳非None。</span></span><br><span class="line">  <span class="comment">// Case 2</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (wrapperMessageTimestampType.exists(_ == <span class="type">TimestampType</span>.<span class="type">LOG_APPEND_TIME</span>) &amp;&amp; wrapperMessageTimestamp.isDefined)</span><br><span class="line">    wrapperMessageTimestamp.get</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// Case 1, 3</span></span><br><span class="line">    buffer.getLong(<span class="type">Message</span>.<span class="type">TimestampOffset</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后2种Case都代表当前消息是内部消息，也就是说和其他内部消息一起被压缩了，只有时间戳类型为<code>LogAppendTime</code>时才使用外部消息的时间戳。</p>
<h2 id="辅助构造器"><a href="#辅助构造器" class="headerlink" title="辅助构造器"></a>辅助构造器</h2><p>一般不会直接传入<code>ByteBuffer</code>，而是传入消息协议的各个字段来构造，也就是辅助构造器</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(bytes: <span class="type">Array</span>[<span class="type">Byte</span>], </span><br><span class="line">         key: <span class="type">Array</span>[<span class="type">Byte</span>],</span><br><span class="line">         timestamp: <span class="type">Long</span>,</span><br><span class="line">         timestampType: <span class="type">TimestampType</span>,</span><br><span class="line">         codec: <span class="type">CompressionCodec</span>, </span><br><span class="line">         payloadOffset: <span class="type">Int</span>, </span><br><span class="line">         payloadSize: <span class="type">Int</span>,</span><br><span class="line">         magicValue: <span class="type">Byte</span>) = &#123;</span><br><span class="line">  <span class="comment">// 计算总长度，分配对应大小的ByteBuffer</span></span><br><span class="line">  <span class="keyword">this</span>(<span class="type">ByteBuffer</span>.allocate(<span class="type">Message</span>.<span class="type">CrcLength</span> +</span><br><span class="line">                           <span class="type">Message</span>.<span class="type">MagicLength</span> +</span><br><span class="line">                           <span class="type">Message</span>.<span class="type">AttributesLength</span> +</span><br><span class="line">                           (<span class="keyword">if</span> (magicValue == <span class="type">Message</span>.<span class="type">MagicValue_V0</span>) <span class="number">0</span></span><br><span class="line">                            <span class="keyword">else</span> <span class="type">Message</span>.<span class="type">TimestampLength</span>) +</span><br><span class="line">                           <span class="type">Message</span>.<span class="type">KeySizeLength</span> + </span><br><span class="line">                           (<span class="keyword">if</span>(key == <span class="literal">null</span>) <span class="number">0</span> <span class="keyword">else</span> key.length) + </span><br><span class="line">                           <span class="type">Message</span>.<span class="type">ValueSizeLength</span> + </span><br><span class="line">                           (<span class="keyword">if</span>(bytes == <span class="literal">null</span>) <span class="number">0</span> </span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(payloadSize &gt;= <span class="number">0</span>) payloadSize </span><br><span class="line">                            <span class="keyword">else</span> bytes.length - payloadOffset)))</span><br><span class="line">  <span class="comment">// 验证magic和timestamp是否对应：</span></span><br><span class="line">  <span class="comment">// 1. magic只能为0或1；</span></span><br><span class="line">  <span class="comment">// 2. 时间戳必须为非负数或-1（代表不使用时间戳）；</span></span><br><span class="line">  <span class="comment">// 3. magic为0时timestamp必须为-1，因为v0版本不支持时间戳；</span></span><br><span class="line">  validateTimestampAndMagicValue(timestamp, magicValue)</span><br><span class="line">  <span class="comment">// skip crc, we will fill that in at the end</span></span><br><span class="line">  <span class="comment">// 跳过CRC字段，先填充后面的部分</span></span><br><span class="line">  buffer.position(<span class="type">MagicOffset</span>)</span><br><span class="line">  buffer.put(magicValue) <span class="comment">// 填充 magic</span></span><br><span class="line">  <span class="comment">// 根据压缩类型和时间戳类型计算 attribute 并填充</span></span><br><span class="line">  <span class="keyword">val</span> attributes: <span class="type">Byte</span> = <span class="type">LegacyRecord</span>.computeAttributes(magicValue, <span class="type">CompressionType</span>.forId(codec.codec), timestampType)</span><br><span class="line">  buffer.put(attributes)</span><br><span class="line">  <span class="comment">// Only put timestamp when &quot;magic&quot; value is greater than 0</span></span><br><span class="line">  <span class="keyword">if</span> (magic &gt; <span class="type">MagicValue_V0</span>) <span class="comment">// 仅当magic大于0才可以填充时间戳</span></span><br><span class="line">    buffer.putLong(timestamp)</span><br><span class="line">  <span class="keyword">if</span>(key == <span class="literal">null</span>) &#123; <span class="comment">// key为空则将keylen填充为-1，代表key不存在</span></span><br><span class="line">    buffer.putInt(<span class="number">-1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则填充 keylen 和 key</span></span><br><span class="line">    buffer.putInt(key.length)</span><br><span class="line">    buffer.put(key, <span class="number">0</span>, key.length)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类似key，若bytes为空，填充len为-1，否则填充 bytes 的指定部分</span></span><br><span class="line">  <span class="comment">// payloadOffset指定起始偏移量，payloadSize指定填充字节数(若&lt;0则填充偏移量之后的所有字节)</span></span><br><span class="line">  <span class="keyword">val</span> size = <span class="keyword">if</span>(bytes == <span class="literal">null</span>) <span class="number">-1</span></span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(payloadSize &gt;= <span class="number">0</span>) payloadSize </span><br><span class="line">             <span class="keyword">else</span> bytes.length - payloadOffset</span><br><span class="line">  buffer.putInt(size)</span><br><span class="line">  <span class="keyword">if</span>(bytes != <span class="literal">null</span>)</span><br><span class="line">    buffer.put(bytes, payloadOffset, size)</span><br><span class="line">  buffer.rewind() <span class="comment">// 重置position为初始，以便之后getXXX()读取</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// now compute the checksum and fill it in</span></span><br><span class="line">  <span class="comment">// 后面字段填充完了，计算CRC校验值并填充到前4个字节，完成后position为4，</span></span><br><span class="line">  <span class="comment">// 也就是对内部buffer调用slice()方法返回的是magic字段至末尾的部分而不包含CRC字段</span></span><br><span class="line">  <span class="type">ByteUtils</span>.writeUnsignedInt(buffer, <span class="type">CrcOffset</span>, computeChecksum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他辅助构造器都是基于这个辅助构造器构造的，代码就不一一贴出。</p>
<h2 id="Record类"><a href="#Record类" class="headerlink" title="Record类"></a>Record类</h2><p><code>class Message</code>的<code>asRecord()</code>方法和<code>object Message</code>的<code>fromRecord()</code>方法提供了<code>Message</code>类和Java的<code>LegacyRecord</code>类的互相转化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// object Message</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fromRecord</span></span>(record: <span class="type">LegacyRecord</span>): <span class="type">Message</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> wrapperTimestamp: <span class="type">Option</span>[<span class="type">Long</span>] = <span class="keyword">if</span> (record.wrapperRecordTimestamp == <span class="literal">null</span>) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(record.wrapperRecordTimestamp)</span><br><span class="line">  <span class="keyword">val</span> wrapperTimestampType = <span class="type">Option</span>(record.wrapperRecordTimestampType)</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Message</span>(record.buffer, wrapperTimestamp, wrapperTimestampType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Message</span></span><br><span class="line"><span class="keyword">private</span>[message] <span class="function"><span class="keyword">def</span> <span class="title">asRecord</span></span>: <span class="type">LegacyRecord</span> = wrapperMessageTimestamp <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">new</span> <span class="type">LegacyRecord</span>(buffer)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(timestamp) =&gt; <span class="keyword">new</span> <span class="type">LegacyRecord</span>(buffer, timestamp, wrapperMessageTimestampType.orNull)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见两者的构造器完全一致，其实去看实现的话大多数方法也是一致的。只不过<code>Record</code>提供了一系列<code>write()</code>方法可以将内部存储的字节写入到<code>DataOutputStream</code>类中，而<code>Message</code>本身没有，因此要将<code>Message</code>写入数据流时需要调用<code>asRecord</code>转换成Record对象再调用<code>write()</code>方法。</p>
<p>此外<code>LegacyRecord</code>还提供了<code>writeCompressedRecordHeader()</code>方法在创建消息集（Message Set）时会使用，到时候再去阅读。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文内容比较简单，主要是阅读Kafka的消息格式的实现，Java&#x2F;Scala使用<code>ByteBuffer</code>来实现基于字节的消息协议。Kafka在0.10.0中做出了较大改变，添加了时间戳字段，因此使用了<code>magic</code>字段来区分不同版本的消息。最后，Scala类<code>Message</code>也提供了与Java类<code>LegacyRecord</code>的转换方法，从而实现向数据流的写入。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/08/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB04-API%E5%B1%82%E4%B9%8BHandler%E5%92%8CApis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/08/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB04-API%E5%B1%82%E4%B9%8BHandler%E5%92%8CApis/" class="post-title-link" itemprop="url">Kafka源码阅读04-API层之Handler和Apis</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-08 12:14:48" itemprop="dateCreated datePublished" datetime="2019-10-08T12:14:48+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前通过网络层的阅读，我们知道了和客户端直接进行读写的是<code>Processor</code>，但是它会将请求通过<code>RequestChannel</code>发送给<code>KafkaRequestHandler</code>，同时也会接收<code>KafkaApis</code>通过<code>RequestChannel</code>回复的响应。因此从本篇开始阅读API层，也就是Handler和Apis，它们都是位于<code>server</code>包内。</p>
<h2 id="Handler线程的创建"><a href="#Handler线程的创建" class="headerlink" title="Handler线程的创建"></a>Handler线程的创建</h2><p>回顾请求的调用链</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Processor</span>.</span></span>processCompleteReceives</span><br><span class="line">  \-- requestChannel.send<span class="constructor">Request(<span class="params">request</span>)</span></span><br><span class="line">    \-- requestQueue.put(request)</span><br></pre></td></tr></table></figure>

<p><code>Processor</code>的<code>requestChannel</code>字段调用<code>sendRequest()</code>方法，该方法将请求放入其<code>requestQueue</code>字段中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">BaseRequest</span>](queueSize)</span><br></pre></td></tr></table></figure>

<p>既然有入队，就肯定有出队，找到其<code>poll()</code>方法的调用处：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得下一个请求，或者阻塞直到超时  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveRequest</span></span>(timeout: <span class="type">Long</span>): <span class="type">RequestChannel</span>.<span class="type">BaseRequest</span> =</span><br><span class="line">  requestQueue.poll(timeout, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br></pre></td></tr></table></figure>

<p>继续找到该方法的调用处，在<code>KafkaRequestHandler.run()</code>方法中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> req = requestChannel.receiveRequest(<span class="number">300</span>) <span class="comment">// 300ms超时</span></span><br></pre></td></tr></table></figure>

<p><code>KafkaRequestHandler</code>实现了<code>Runnable</code>接口，也就是说，它在调用<code>start()</code>方法时就会启动线程，执行<code>run()</code>方法，查找使用它的地方，为<code>KafkaRequestHandlerPool</code>的字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> runnables = <span class="keyword">new</span> mutable.<span class="type">ArrayBuffer</span>[<span class="type">KafkaRequestHandler</span>](numThreads)</span><br></pre></td></tr></table></figure>

<p>Poll类管理了Handler线程，它默认创建了<code>numThreads</code>个Handler线程。</p>
<p>PS：这里使用了<code>ArrayBuffer</code>而非固定大小的<code>Array</code>，和之前提到的<code>Processor</code>和<code>Acceptor</code>使用<code>ConcurrentHashMap</code>保存一样，都是为了支持<code>resize</code>操作。</p>
<p>再看看<code>Pool</code>类的使用处，它是<code>KafkaServer</code>的字段</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestHandlerPool: <span class="type">KafkaRequestHandlerPool</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p><code>KafkaServer</code>才是真正的Kafka服务器的类，而之前介绍的<code>SocketServer</code>类只是它用来管理网络的部分，也是其中的一个字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> socketServer: <span class="type">SocketServer</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>再看看<code>requestHandlerPool</code>的使用处，位于<code>KafkaServer</code>的<code>startup()</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requestHandlerPool = <span class="keyword">new</span> <span class="type">KafkaRequestHandlerPool</span>(config.brokerId,</span><br><span class="line">                                                 socketServer.requestChannel,</span><br><span class="line">                                                 apis, time, config.numIoThreads)</span><br></pre></td></tr></table></figure>

<p>第1个参数为配置的<code>broker.id</code>，第2个参数为<code>RequestChannel</code>对象，第3个参数为<code>KafkaApis</code>对象，第4个参数为<code>KafkaServer</code>的构造参数，为<code>SystemTime</code>对象，位于<code>common.util</code>包内。</p>
<p>第5个参数为Handler线程的数量，为<code>config.numIoThreads</code>，对应配置文件的<code>num.io.threads</code>，默认值为8（见<code>KafkaConfig.scala</code>的<code>Defaults</code>伴生对象）。</p>
<p>而Pool类中创建Handler线程代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i &lt;- <span class="number">0</span> until numThreads) &#123;</span><br><span class="line">  createHandler(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createHandler</span></span>(id: <span class="type">Int</span>): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">  runnables += <span class="keyword">new</span> <span class="type">KafkaRequestHandler</span>(id, brokerId, aggregateIdleMeter, threadPoolSize, requestChannel, apis, time)</span><br><span class="line">  <span class="type">KafkaThread</span>.daemon(<span class="string">&quot;kafka-request-handler-&quot;</span> + id, runnables(id)).start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>id</code>为Handler线程的编号（从0开始），<code>aggregateIdleMeter</code>为度量指标相关（配合<code>time</code>字段计算Handler线程闲置的时间，我们依旧忽略之），<code>threadPoolSize</code>为线程池大小（即线程数量）。剩余参数都是Pool类的构造参数。</p>
<p>至此，我们知道了<code>KafkaServer</code>管理了Handler线程池，会根据配置的<code>num.io.threads</code>创建对应数量的Handler线程，并且多个Handler线程共享了<code>KafkaApis</code>对象和<code>RequestChannel</code>对象。</p>
<h2 id="Handler线程实现"><a href="#Handler线程实现" class="headerlink" title="Handler线程实现"></a>Handler线程实现</h2><p>忽略了日志和度量指标的部分：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">    <span class="comment">// 从requestChannel中取得请求，timeout为300ms</span></span><br><span class="line">    <span class="keyword">val</span> req = requestChannel.receiveRequest(<span class="number">300</span>)</span><br><span class="line"></span><br><span class="line">    req <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="comment">// Shutdown类型的请求，直接退出Handler线程</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">ShutdownRequest</span> =&gt;</span><br><span class="line">        debug(<span class="string">s&quot;Kafka request handler <span class="subst">$id</span> on broker <span class="subst">$brokerId</span> received shut down command&quot;</span>)</span><br><span class="line">        shutdownComplete.countDown()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 正常请求</span></span><br><span class="line">      <span class="keyword">case</span> request: <span class="type">RequestChannel</span>.<span class="type">Request</span> =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          request.requestDequeueTimeNanos = endTime</span><br><span class="line">          <span class="comment">// 交给apis处理</span></span><br><span class="line">          apis.handle(request)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;  <span class="comment">// 处理api.handle()可能抛出的异常</span></span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">FatalExitError</span> =&gt;</span><br><span class="line">            shutdownComplete.countDown()</span><br><span class="line">            <span class="type">Exit</span>.exit(e.statusCode)</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">&quot;Exception when handling request&quot;</span>, e)</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          request.releaseBuffer()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  shutdownComplete.countDown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，Handler线程反复地从<code>requestChannel</code>中取得请求，交由<code>apis</code>进行处理，如果处理出错会捕获异常，并以异常中包含的错误码退出当前线程。这也解释了前一篇的疑问：为何请求的发送对象是Handler线程，而响应却来自于Apis。</p>
<p>值得注意的地方是，这里还有个<code>ShutdownRequest</code>，是用来退出Handler线程的，找到它的调用处：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendShutdownRequest</span></span>(): <span class="type">Unit</span> = requestQueue.put(<span class="type">ShutdownRequest</span>)</span><br></pre></td></tr></table></figure>

<p><code>RequestChannel</code>对象调用该方法将Shutdown请求加入队列中，而该方法的调用处位于<code>KafkaRequestHandler</code>内：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initiateShutdown</span></span>(): <span class="type">Unit</span> = requestChannel.sendShutdownRequest()</span><br></pre></td></tr></table></figure>

<p>进一步往上找，会发现位于<code>KafkaRequestHandler</code>的<code>shutdown()</code>方法内，用于Handler线程的正常退出（相对而言，<code>apis.handle()</code>抛出异常则是异常退出，退出码不为0）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>(): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">  info(<span class="string">&quot;shutting down&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (handler &lt;- runnables)</span><br><span class="line">    handler.initiateShutdown()</span><br><span class="line">  <span class="keyword">for</span> (handler &lt;- runnables)</span><br><span class="line">    handler.awaitShutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于<code>awaitShutdown()</code>方法，则是Java线程退出的惯用法，即调用了<code>CountDownLatch</code>对象的<code>await()</code>方法，等待计数归0，可以看到<code>run()</code>方法中不同的退出分支都会调用<code>shutdownComplete.countDown()</code>方法，即将<code>CountDownLatch</code>对象<code>shutdownComplete</code>的计数减1，而其初始计数为1：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> shutdownComplete = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Apis"><a href="#Apis" class="headerlink" title="Apis"></a>Apis</h2><p><code>KafkaApis</code>对象的创建在<code>KafkaRequestHandlerPool</code>创建之前，其构造参数有18个，因此暂时不详细列出，最为关键的还是<code>requestChannel</code>。看看关键的<code>handle()</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    request.header.apiKey <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">PRODUCE</span> =&gt; handleProduceRequest(request)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ApiKeys</span>.<span class="type">FETCH</span> =&gt; handleFetchRequest(request)</span><br><span class="line">      <span class="comment">// 其他类型的的ApiKeys...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">FatalExitError</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; handleError(request, e)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    request.apiLocalCompleteTimeNanos = time.nanoseconds</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取得请求头的<code>apiKey</code>（见前一篇的<strong>请求头的解析</strong>一节），根据类型调用不同的<code>handle*()</code>方法进行处理，这里看一个比较简单的例子，是对<code>LIST_OFFSETS</code>请求的处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handleListOffsetRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  <span class="keyword">val</span> version = request.header.apiVersion()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据请求头的API版本进行不同的处理</span></span><br><span class="line">  <span class="keyword">val</span> mergedResponseMap = <span class="keyword">if</span> (version == <span class="number">0</span>)</span><br><span class="line">    handleListOffsetRequestV0(request)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    handleListOffsetRequestV1AndAbove(request)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 参数2为将requestThrottleMs作为输入的函数，会根据该输入创建ListOffsetResponse对象</span></span><br><span class="line">  <span class="comment">// 并且在sendResponseMaybeThrottle类根据requestThrottleMs判断是否创建该对象并发送</span></span><br><span class="line">  sendResponseMaybeThrottle(request, requestThrottleMs =&gt; <span class="keyword">new</span> <span class="type">ListOffsetResponse</span>(requestThrottleMs, mergedResponseMap.asJava))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的分析略过，总之Apis在处理完请求后，如果判断需要发送，则会创建响应的响应（<code>*Response</code>）类型，并调用<code>sendResponse()</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sendResponse</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>, responseOpt: <span class="type">Option</span>[<span class="type">AbstractResponse</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// 对响应的每个非0错误码更新度量指标</span></span><br><span class="line">  responseOpt.foreach(response =&gt; requestChannel.updateErrorMetrics(request.header.apiKey, response.errorCounts.asScala))</span><br><span class="line"></span><br><span class="line">  responseOpt <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(response) =&gt;</span><br><span class="line">      <span class="comment">// 若响应存在，则构造响应的Send，并调用requestChannel的sendResponse()方法发送</span></span><br><span class="line">      <span class="keyword">val</span> responseSend = request.context.buildResponse(response)</span><br><span class="line">      <span class="comment">// 如果RequestChannel伴生对象的isRequestloggingEnabled则构造该字符串</span></span><br><span class="line">      <span class="keyword">val</span> responseString =</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">RequestChannel</span>.isRequestLoggingEnabled) <span class="type">Some</span>(response.toString(request.context.apiVersion))</span><br><span class="line">        <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">Some</span>(responseSend), <span class="type">SendAction</span>, responseString))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">None</span>, <span class="type">NoOpAction</span>, <span class="type">None</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见实际上，还是利用<code>requestChannel.sendResponse()</code>方法发送响应（参见前一篇的<strong>处理响应</strong>一节，会将响应加入<code>Processor</code>的响应队列中）。这里的<code>Send</code>接口表示的是待发送的数据，而<code>String</code>则是用于调试的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">RequestChannel</span> <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> requestLogger = <span class="type">Logger</span>(<span class="string">&quot;kafka.request.logger&quot;</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isRequestLoggingEnabled</span></span>: <span class="type">Boolean</span> = requestLogger.underlying.isDebugEnabled</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要额外说明下，Kafka的日志系统使用的是<code>SLF4J</code>，它本身只是日志的抽象层，而没有具体的实现，因此在编译运行Kafka时会提示警告：</p>
<blockquote>
<p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”. SLF4J: Defaulting to no-operation (NOP) logger implementation SLF4J: See <a target="_blank" rel="noopener" href="http://www.slf4j.org/codes.html#StaticLoggerBinder">http://www.slf4j.org/codes.html#StaticLoggerBinder</a> for further details.</p>
</blockquote>
<p>只有将具体的日志jar包放入classpath中，才会成功打印日志，因此从Kafka源码中是无法确定<code>isRequestLoggingEnabled</code>在哪里设置为<code>true</code>，取决于实际日志包的配置。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>API层其实还是很简单的，创建<code>num.io.threads</code>个Handler线程，从共享的<code>RequestChannel</code>中取出请求（使用<code>ArrayBlockingQueue</code>请求队列保证线程安全并且限制最大请求数），如果不是Handler调用<code>shutdown()</code>方法加入的关闭请求，则将其交给Apis对象进行处理，处理完请求后会构造响应对象，通过<code>RequestChannel</code>加入到<code>Processor</code>内部的响应队列（使用<code>LinkedBlockingQueue</code>响应队列保证线程安全，并且不限制最大响应数量）。</p>
<p>实际的请求的解析和响应的构造则集中于<code>KafkaApis</code>类中，接下来则是通过不同的<code>ApiKey</code>类依次看看Kafka支持哪些请求，并且内部是怎样处理这些请求。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/23/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB03-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BRequestChannel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/23/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB03-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BRequestChannel/" class="post-title-link" itemprop="url">Kafka源码阅读03: 网络层阅读之RequestChannel</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-23 20:01:56" itemprop="dateCreated datePublished" datetime="2019-09-23T20:01:56+08:00">2019-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>前2篇分析了<code>SocketServer</code>的启动以及<code>Acceptor</code>&#x2F;<code>Processor</code>，对配置<code>listener</code>的网络地址，都会创建1个<code>Acceptor</code>和N个<code>Processor</code>，其中N为配置<code>num.network.thread</code>。每个<code>Acceptor</code>会创建1个默认的NIO <code>Selector</code>，每个<code>Processor</code>则都会创建1个Kafka自行实现<code>Selector</code>接口的<code>KSelector</code>。</p>
<p>socket都会被封装成<code>Channel</code>，即通道，代表socket两端的连接。<code>Acceptor</code>会创建一个<code>Channel</code>监听网络地址，并在其<code>Selector</code>注册读事件，然后负责将所有客户端的连接转换成<code>Channel</code>均衡地发送给<code>Processor</code>。</p>
<p><code>Processor</code>则在其<code>Selector</code>上注册从<code>Acceptor</code>收到的<code>Channel</code>的读&#x2F;写&#x2F;关闭连接等事件，并分别处理。但是<code>Processor</code>只负责读取请求(Request)和写入响应(Response)，对于已完成的请求，会将其作为参数传给<code>requestChannel</code>调用<code>sendRequest()</code>。另一方面，<code>Processor</code>内部的响应队列，则是由<code>requestChannel</code>调用<code>sendResponse()</code>得到的。</p>
<p>而<code>RequestChannel</code>包含<code>requestQueue</code>字段缓存请求，另外它也和<code>SocketServer</code>一样保存了所有<code>Processor</code>的id和自身组成的<code>ConcurrentHashMap</code>。</p>
<h2 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h2><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>在<code>Processor.processCompletedReceives()</code>方法中，会将封装了网络地址信息的请求传递给<code>sendRequest()</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> header = <span class="type">RequestHeader</span>.parse(receive.payload)</span><br><span class="line"><span class="keyword">val</span> context = <span class="keyword">new</span> <span class="type">RequestContext</span>(header, receive.source, channel.socketAddress,</span><br><span class="line">  channel.principal, listenerName, securityProtocol)</span><br><span class="line"><span class="keyword">val</span> req = <span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Request</span>(processor = id, context = context,</span><br><span class="line">  startTimeNanos = time.nanoseconds, memoryPool, receive.payload, requestChannel.metrics)</span><br><span class="line">requestChannel.sendRequest(req)</span><br></pre></td></tr></table></figure>

<p><code>sendRequest()</code>方法的实现：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送待处理的请求, requestQueue 有容量上限, 由 queue.max.requests 配置, 若达到了上限则会阻塞。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendRequest</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>) &#123;</span><br><span class="line">  requestQueue.put(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“发送”只是将请求放到了内部的请求队列中，而出队方法是在<code>server.KafkaRequestHandler</code>中调用的，不属于网络层的事情，暂时不管。因此看看<code>Request</code>类型的构造，传入了<code>header</code>和<code>context</code>。</p>
<h3 id="请求头的解析"><a href="#请求头的解析" class="headerlink" title="请求头的解析"></a>请求头的解析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RequestHeader <span class="title function_">parse</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前2个字节为 Api Key, 代表请求的类型</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">apiKey</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        <span class="comment">// 后2个字节为 Api Version, 即客户端使用的API版本</span></span><br><span class="line">        <span class="type">short</span> <span class="variable">apiVersion</span> <span class="operator">=</span> buffer.getShort();</span><br><span class="line">        <span class="comment">// 通过上述字段创建 Schema 对象, 即完整的消息头</span></span><br><span class="line">        <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> schema(apiKey, apiVersion);</span><br><span class="line">        <span class="comment">// ByteBuffer.getXXX() 会修改内部偏移量, 因此需要将偏移量重置为最开始以便从头读取 buffer</span></span><br><span class="line">        <span class="comment">// 从头读取 buffer, 进而用 scheme.read() 构造请求头</span></span><br><span class="line">        buffer.rewind();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestHeader</span>(schema.read(buffer));</span><br><span class="line">    &#125;  <span class="comment">// 异常处理(略)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Api Key的类型参考<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html#protocol_api_keys">Api Key</a>，消息协议类型参考<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html#protocol_messages">消息协议</a>：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Request Header <span class="operator">=</span>&gt; api_key api_version correlation_id client_id </span><br><span class="line">  api_key <span class="operator">=</span>&gt; INT16</span><br><span class="line">  api_version <span class="operator">=</span>&gt; INT16</span><br><span class="line">  correlation_id <span class="operator">=</span>&gt; INT32</span><br><span class="line">  client_id <span class="operator">=</span>&gt; NULLABLE_STRING</span><br></pre></td></tr></table></figure>

<p>这个头部即<code>Schema</code>类，其<code>read()</code>方法会把后面的correlation id和client id给读入，构造消息头。</p>
<h3 id="请求上下文的构造"><a href="#请求上下文的构造" class="headerlink" title="请求上下文的构造"></a>请求上下文的构造</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> context = <span class="keyword">new</span> <span class="type">RequestContext</span>(header, receive.source, channel.socketAddress,  channel.principal,</span><br><span class="line">                                 listenerName, securityProtocol)</span><br></pre></td></tr></table></figure>

<p>其实就是简单地将对应参数赋值给内部字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> RequestHeader header;  <span class="comment">// 消息头</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String connectionId; <span class="comment">// 连接id，包含本地和远程的地址和表示连接的index</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> InetAddress clientAddress; <span class="comment">// 客户端地址</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> KafkaPrincipal principal; <span class="comment">// Channel的principal字段，用于信息认证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ListenerName listenerName; <span class="comment">// 配置 listeners 的名字部分(比如PLAINTEXT) </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> SecurityProtocol securityProtocol; <span class="comment">// 安全协议, 根据listenerName解析的</span></span><br></pre></td></tr></table></figure>

<p>消息头上一小节刚看完，连接id也是阅读源码至今一直见到的用于标识一条TCP连接的字符串，最后2个字段均为解析<code>listener</code>配置时解析出的<code>EndPoint</code>类的字段。</p>
<h3 id="请求对象的创建"><a href="#请求对象的创建" class="headerlink" title="请求对象的创建"></a>请求对象的创建</h3><p><code>RequestChannel.Request</code>字段比较多就不一一解释了（很多都是metric相关的），核心是请求body（0.10版本是字段现在是方法）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">body</span></span>[<span class="type">T</span> &lt;: <span class="type">AbstractRequest</span>](<span class="keyword">implicit</span> classTag: <span class="type">ClassTag</span>[<span class="type">T</span>], nn: <span class="type">NotNothing</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">  bodyAndSize.request <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r: <span class="type">T</span> =&gt; r</span><br><span class="line">    <span class="keyword">case</span> r =&gt;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassCastException</span>(<span class="string">s&quot;Expected request with type <span class="subst">$&#123;classTag.runtimeClass&#125;</span>, but found <span class="subst">$&#123;r.getClass&#125;</span>&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法仅仅是检查请求类型T是否合法，若不合法则抛出异常。</p>
<p>关键部分是<code>bodyAndSize</code>进行类型匹配，该字段初始化：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> bodyAndSize: <span class="type">RequestAndSize</span> = context.parseRequest(buffer)</span><br></pre></td></tr></table></figure>

<p><code>context</code>解析请求的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> RequestAndSize <span class="title function_">parseRequest</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnsupportedApiVersionsRequest()) &#123;</span><br><span class="line">        <span class="comment">// 未支持的 ApiVersion 被视为v0请求并且不被处理</span></span><br><span class="line">        <span class="type">ApiVersionsRequest</span> <span class="variable">apiVersionsRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiVersionsRequest</span>((<span class="type">short</span>) <span class="number">0</span>, header.apiVersion());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestAndSize</span>(apiVersionsRequest, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ApiKeys</span> <span class="variable">apiKey</span> <span class="operator">=</span> header.apiKey();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">short</span> <span class="variable">apiVersion</span> <span class="operator">=</span> header.apiVersion();</span><br><span class="line">            <span class="comment">// 根据API版本将字节缓存解析成Struct的各个字段</span></span><br><span class="line">            <span class="type">Struct</span> <span class="variable">struct</span> <span class="operator">=</span> apiKey.parseRequest(apiVersion, buffer);</span><br><span class="line">            <span class="comment">// 根据请求类型/API版本/Struct字段创建实际的请求类型</span></span><br><span class="line">            <span class="type">AbstractRequest</span> <span class="variable">body</span> <span class="operator">=</span> AbstractRequest.parseRequest(apiKey, apiVersion, struct);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestAndSize</span>(body, struct.sizeOf());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 异常处理(略)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 AbstractRequest 的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AbstractRequest <span class="title function_">parseRequest</span><span class="params">(ApiKeys apiKey, <span class="type">short</span> apiVersion, Struct struct)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (apiKey) &#123;</span><br><span class="line">        <span class="keyword">case</span> PRODUCE: </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProduceRequest</span>(struct, apiVersion);</span><br><span class="line">        <span class="keyword">case</span> FETCH:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FetchRequest</span>(struct, apiVersion);</span><br><span class="line">        <span class="comment">// 其他类型的请求...(略)</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 异常处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分代码都是Java实现的，为了能根据不同请求类型&#x2F;API版本得到对应的请求类型的示例，实现得较为复杂，细节也不深入去看，总之，在Kafka中可以像这样调用<code>body()</code>方法得到实际的请求对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将请求的 ByteBuffer 解析成 MetadataRequest 对象</span></span><br><span class="line"><span class="keyword">val</span> metadataRequest = request.body[<span class="type">MetadataRequest</span>]</span><br></pre></td></tr></table></figure>

<h3 id="取出请求"><a href="#取出请求" class="headerlink" title="取出请求"></a>取出请求</h3><p>之前介绍了<code>Processor</code>仅仅是将请求加入阻塞队列<code>requestQueue</code>中，那么何时取出呢？找到其<code>poll()</code>方法的调用处：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得下个请求, 或者阻塞直到超时</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receiveRequest</span></span>(timeout: <span class="type">Long</span>): <span class="type">RequestChannel</span>.<span class="type">BaseRequest</span> =</span><br><span class="line">  requestQueue.poll(timeout, <span class="type">TimeUnit</span>.<span class="type">MILLISECONDS</span>)</span><br></pre></td></tr></table></figure>

<p>再看看上述方法的调用处：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 KafkaRequestHandler 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">val</span> req = requestChannel.receiveRequest(<span class="number">300</span>) <span class="comment">// 300ms超时</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    req <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">ShutdownRequest</span> =&gt;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> request: <span class="type">RequestChannel</span>.<span class="type">Request</span> =&gt;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="comment">// continue</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是API层的代码，所以略去了其他代码，只保留了<code>req</code>相关的。可以看到请求<code>Handler</code>线程会反复地从请求队列中取出请求，然后根据请求地类型进行不同处理。</p>
<h3 id="多线程取出请求安全吗？"><a href="#多线程取出请求安全吗？" class="headerlink" title="多线程取出请求安全吗？"></a>多线程取出请求安全吗？</h3><p>由于<code>ArrayBlockingQueue</code>是线程安全的，所以多个<code>Handler</code>线程从中取出请求是线程安全的。另一方面，关于顺序性，即来自同一个客户端的多个请求，必须保证取出的顺序也一致。《Apache Kafka源码剖析》书上给出了解释：<code>Processor.run()</code>方法通过多处注册&#x2F;取消 读&#x2F;写事件 来保证每个连接上只有一个请求和一个对应的响应来实现的。</p>
<p>具体而言，可以回顾我上一篇源码分析中<code>Processor</code>的部分：</p>
<ol>
<li>在<code>processCompletedReceives()</code>中，一旦接收到完整的请求<code>req</code>，在调用<code>sendRequest(req)</code>后会取消监听该<code>Channel</code>的读事件；</li>
<li>在<code>processCompleteSends()</code>中，只有当响应成功返回客户端（将响应从缓存的<code>inflightResponses</code>移除）后，才会重新注册该<code>Channel</code>的读事件；</li>
<li>在<code>processNewResponses()</code>中判断请求类型是<code>SendAction</code>时，会注册<code>Channel</code>的写事件；</li>
<li>在<code>poll()</code>中向底层socket发送数据时，如果判断数据完毕，则会取消注册<code>Channel</code>的写事件。</li>
</ol>
<h2 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h2><p><code>Processor</code>自己维护了响应队列，并在<code>processNewResponses()</code>中调用<code>dequeueResponse()</code>方法依次出队， 那么，可以找到其对应方法<code>enqueueResponse()</code>的调用处：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendResponse</span></span>(response: <span class="type">RequestChannel</span>.<span class="type">Response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isTraceEnabled) &#123;</span><br><span class="line">    <span class="comment">// 判断响应类型并打印日志(略)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> processor = processors.get(response.processor)</span><br><span class="line">  <span class="comment">// 如果 processor 已经关闭了, 可能会被移出 processors (此时返回null), 因此直接丢掉响应</span></span><br><span class="line">  <span class="keyword">if</span> (processor != <span class="literal">null</span>) &#123;</span><br><span class="line">    processor.enqueueResponse(response)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是这里对<code>processor != null</code>的判断，Kafka 1.1.0的<code>SocketServer</code>支持<code>resizeThreadPoll()</code>方法来改变网络线程数量（也就是<code>Acceptor</code>对应<code>Processor</code>的数量），如果网络线程数减少的话，那么多出的<code>Processor</code>会调用<code>shutdown()</code>方法关闭，并通过<code>connectionId</code>将其从<code>Acceptor</code>和<code>RequestChannel</code>中的<code>processors</code>字段移除。</p>
<p>继续找到该方法的调用处，位于<code>KafkaApis</code>的<code>sendResponse()</code>方法中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sendResponse</span></span>(request: <span class="type">RequestChannel</span>.<span class="type">Request</span>, responseOpt: <span class="type">Option</span>[<span class="type">AbstractResponse</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// 更新metrics(略)</span></span><br><span class="line"></span><br><span class="line">  responseOpt <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(response) =&gt;</span><br><span class="line">      <span class="keyword">val</span> responseSend = request.context.buildResponse(response)</span><br><span class="line">      <span class="keyword">val</span> responseString =</span><br><span class="line">        <span class="keyword">if</span> (<span class="type">RequestChannel</span>.isRequestLoggingEnabled) <span class="type">Some</span>(response.toString(request.context.apiVersion))</span><br><span class="line">        <span class="keyword">else</span> <span class="type">None</span></span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">Some</span>(responseSend), <span class="type">SendAction</span>, responseString))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">      requestChannel.sendResponse(<span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Response</span>(request, <span class="type">None</span>, <span class="type">NoOpAction</span>, <span class="type">None</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时<code>RequestChannel</code>只是将响应转发给了<code>Processor</code>，它本身并不维护响应队列（在0.10.0.1版本中则是维护了多个响应队列），真正维护响应队列的是<code>Processor</code>本身。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Kafka网络层的阅读至此就告一段落，不得不说但作为Kafka的基础设施的Java NIO实现的部分更为复杂（<code>KafkaChannel</code>和<code>KafkaSelector</code>），但阅读源码不应太陷入细节（感觉我已经有些陷进去了……）。对于Kafka，最重要的还是它的业务层，也就是对<a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol.html">Kafka协议</a>的实现。</p>
<p><code>RequestChannel</code>的作用很简单：</p>
<ul>
<li>维护请求队列，接收来自<code>Processor</code>的请求，并转发给<code>KafkaRequestHandler</code>进行处理；</li>
<li>从<code>KafkaApis</code>获取响应，发送给<code>Processor</code>。</li>
</ul>
<p>加上文章开始总结的<code>Acceptor</code>&#x2F;<code>Processor</code>，以及统筹全局的<code>SocketServer</code>，构成了Kafka的网络层，简单描述：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string">             Network Layer                 </span>|<span class="string">       API Layer        </span>|</span><br><span class="line">|<span class="string"> Acceptor -&gt; Processors &lt;-&gt; RequestChannel </span>|<span class="string"> -&gt; KafkaRequestHandler </span>|</span><br><span class="line">|<span class="string">                                           </span>|<span class="string"> &lt;- KafkaApis           </span>|</span><br><span class="line">|<span class="string"> Client -&gt; SocketChannel -&gt; Acceptor       </span>|<span class="string">                        </span>|</span><br><span class="line">|<span class="string"> Client &lt;-&gt; KafkaChannel &lt;-&gt; Processor     </span>|<span class="string">                        </span>|</span><br></pre></td></tr></table></figure>

<p>可以发现不管是什么<code>Channel</code>，都是起到了连接的作用。<code>Acceptor</code>通过最简单的<code>SocketChannel</code>与监听套接字连接，监听连接事件，并将接受的连接转发给<code>Processor</code>，之后<code>Processor</code>通过比较复杂的<code>KafkaChannel</code>与客户端连接，监听读&#x2F;写事件并和客户端进行数据的交互。</p>
<p>数据分为来自客户端的请求和来自服务端的响应，<code>Processor</code>不负责这部分，而是通过<code>RequestChannel</code>将请求发送给<code>KafkaRequestHandler</code>，再从<code>RequestChannel</code>接收响应。</p>
<p>问题来了，而实际发送响应给<code>RequestChannel</code>的却是<code>KafkaApis</code>，因此<strong>请求</strong>&#x3D;&gt;<strong>响应</strong>的过程是由它们共同完成的，也就是接下来要阅读的API层。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB02-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BAcceptor%E5%92%8CProcessor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/20/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB02-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8BAcceptor%E5%92%8CProcessor/" class="post-title-link" itemprop="url">Kafka源码阅读02: 网络层阅读之Acceptor和Processor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-20 11:38:31" itemprop="dateCreated datePublished" datetime="2019-09-20T11:38:31+08:00">2019-09-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AbstractServerThread"><a href="#AbstractServerThread" class="headerlink" title="AbstractServerThread"></a>AbstractServerThread</h2><p><code>Acceptor</code>和<code>Processor</code>的抽象基类，封装了一些辅助的变量和方法（这里重新组织了下代码顺序）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> startupLatch = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@volatile</span> <span class="keyword">private</span> <span class="keyword">var</span> shutdownLatch = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> alive = <span class="keyword">new</span> <span class="type">AtomicBoolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">isRunning</span></span>: <span class="type">Boolean</span> = alive.get</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// 如果线程仍在运行, 则将 alive 置为true表示线程之后会关闭, 然后调用抽象方法 wakeup()</span></span><br><span class="line">  <span class="keyword">if</span> (alive.getAndSet(<span class="literal">false</span>))</span><br><span class="line">    wakeup()</span><br><span class="line">  shutdownLatch.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待线程完全启动</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">awaitStartup</span></span>(): <span class="type">Unit</span> = startupLatch.await</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识线程已经启动, 这样就可以等待停止操作了, 因此将 shutdownLatch 指向倒计时为1的对象</span></span><br><span class="line"><span class="comment">// 这样做是为了防止启动时抛出异常, 比如绑定正在使用的地址, 此时应该在处理异常之后仍然能 shutdown,</span></span><br><span class="line"><span class="comment">// 此时 shutdownComplete 的调用会因为异常而被跳过, 如果计数初始化为1会一直阻塞</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">startupComplete</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// Replace the open latch with </span></span><br><span class="line">  shutdownLatch = <span class="keyword">new</span> <span class="type">CountDownLatch</span>(<span class="number">1</span>)</span><br><span class="line">  startupLatch.countDown()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标识线程已经关闭</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">shutdownComplete</span></span>(): <span class="type">Unit</span> = shutdownLatch.countDown()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(channel: <span class="type">SocketChannel</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">    debug(<span class="string">&quot;Closing connection from &quot;</span> + channel.socket.getRemoteSocketAddress())</span><br><span class="line">    <span class="comment">// 减少 channel 对应地址的连接计数</span></span><br><span class="line">    connectionQuotas.dec(channel.socket.getInetAddress)</span><br><span class="line">    <span class="comment">// 关闭 socket 连接以及 channel 本身, 吞下异常, 也就是说关闭出错不是什么严重错误, 写入日志以供分析就行</span></span><br><span class="line">    <span class="type">CoreUtils</span>.swallow(channel.socket().close(), <span class="keyword">this</span>, <span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="type">CoreUtils</span>.swallow(channel.close(), <span class="keyword">this</span>, <span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Acceptor-run"><a href="#Acceptor-run" class="headerlink" title="Acceptor.run()"></a>Acceptor.run()</h2><p>由于循环嵌套还是有点深的，先忽略对Channels的处理部分</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  serverChannel.register(nioSelector, <span class="type">SelectionKey</span>.<span class="type">OP_ACCEPT</span>) <span class="comment">// 注册OP_ACCEPT事件</span></span><br><span class="line">  <span class="comment">// 标识启动完成, 之后 acceptor.awaitStartup() 才会返回, 回顾 createAcceptorAndProcessors()</span></span><br><span class="line">  <span class="comment">// 也就是说 Server 启动时, 必须等到 acceptor 注册 OP_ACCEPT 事件后才会执行后续步骤:</span></span><br><span class="line">  <span class="comment">//   将acceptor加入acceptors, addProcessors, 创建下个acceptor ...</span></span><br><span class="line">  startupComplete()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> currentProcessor = <span class="number">0</span> <span class="comment">// 记录当前processor的id</span></span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 轮询Selector直到有channels准备好I/O, 或者超时(500ms)</span></span><br><span class="line">        <span class="keyword">val</span> ready = nioSelector.select(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">if</span> (ready &gt; <span class="number">0</span>) &#123;  <span class="comment">// 有ready个channels准备好I/O</span></span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> 处理准备好I/O的channels</span></span><br><span class="line">        &#125;  <span class="comment">// else: ready &lt;= 0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// 假设有特定的channel在select时出错, 或者收到bad request, 我们不想要让其他channels受到影响</span></span><br><span class="line">        <span class="comment">// 因此遇到异常只需要打印错误即可。</span></span><br><span class="line">        <span class="comment">// 但是scala会通过ControlThrowable来进行流程控制, 所以此时需要继续将异常往上抛(这是安全的)</span></span><br><span class="line">        <span class="comment">// 在scala 2.13中可以用 case NonFatal(e) 来避免ControlThrowable被捕获</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">ControlThrowable</span> =&gt; <span class="keyword">throw</span> e</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">&quot;Error occurred&quot;</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Acceptor线程结束后的清理工作</span></span><br><span class="line">    debug(<span class="string">&quot;Closing server socket and selector.&quot;</span>)</span><br><span class="line">    <span class="type">CoreUtils</span>.swallow(serverChannel.close(), <span class="keyword">this</span>, <span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    <span class="type">CoreUtils</span>.swallow(nioSelector.close(), <span class="keyword">this</span>, <span class="type">Level</span>.<span class="type">ERROR</span>)</span><br><span class="line">    shutdownComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层<code>try-finally</code>块没有<code>catch</code>，也就是说一切异常都在<code>while</code>循环体内进行处理，循环体内则是一个大的<code>try-catch</code>，注意重抛<code>ControlThrowable</code>的手法，可以参考<a target="_blank" rel="noopener" href="https://www.scala-lang.org/api/current/scala/util/control/ControlThrowable.html">Scala 2.13 ControlThrowable</a>和<a target="_blank" rel="noopener" href="https://www.scala-lang.org/api/2.12.10/scala/util/control/ControlThrowable.html">Scala 2.12 ControlThrowable</a>。</p>
<p><code>Selector</code>的处理和Linux的<code>epoll_wait</code>如出一辙，所以这里还是很熟悉的，不同的是没有处理<code>ready &lt;= 0</code>的情况，接口文档里写的是</p>
<blockquote>
<p>@return  The number of keys, possibly zero, whose ready-operation sets were update</p>
</blockquote>
<p><code>select()</code>方法不会返回负值，像<code>epoll_wait</code>返回-1的情况，<code>Selector</code>是直接抛出异常了，文档里也写了3种异常：</p>
<ul>
<li><code>IOException</code>: If an I&#x2F;O error occurs;</li>
<li><code>ClosedSelectorException</code>: If this selector is closed;</li>
<li><code>IllegalArgumentException</code>: If the value of the timeout argument is negative.</li>
</ul>
<p>接下来看<code>ready &gt; 0</code>时的代码，也是核心的处理逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 遍历所有的key, 类型为SelectionKey</span></span><br><span class="line">  <span class="keyword">val</span> key = iter.next</span><br><span class="line">  iter.remove() <span class="comment">// 从集合中移除该key, 防止</span></span><br><span class="line">  <span class="keyword">if</span> (key.isAcceptable) &#123;  <span class="comment">// 该key的channel可以接受新的socket连接</span></span><br><span class="line">    <span class="comment">// round robin算法, 将连接均衡分配给计算出的下标对应的processor</span></span><br><span class="line">    <span class="comment">// 比如3个processors, 接收了7个连接, 则分配的processor下标依次为: 0,1,2,0,1,2,0,1</span></span><br><span class="line">    <span class="keyword">val</span> processor = synchronized &#123;</span><br><span class="line">      currentProcessor = currentProcessor % processors.size</span><br><span class="line">      processors(currentProcessor)</span><br><span class="line">    &#125;</span><br><span class="line">    accept(key, processor)</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">&quot;Unrecognized key state for acceptor thread.&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// round robin算法, 迭代</span></span><br><span class="line">  currentProcessor = currentProcessor + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123; <span class="comment">// 遍历keys及处理每个key时的异常在此打印</span></span><br><span class="line">  <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; error(<span class="string">&quot;Error while accepting connection&quot;</span>, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路很简单，就是用round robin算法简单做下负载均衡，调用<code>accept()</code>方法将key对应的连接分配给指定processor，因此核心其实是<code>accept()</code>方法。</p>
<p>PS：一个细节，外层<code>catch</code>处理了<code>ControlThrowable</code>，而内层<code>catch</code>并没处理，因为该异常是实现流程控制的，在迭代器到达末尾时才会抛出该异常，所以迭代循环中不会抛出该异常。另一个细节，这里每次迭代都把迭代器移除，这里大概是Java不会像C++一样，对象销毁的时候自动析构吧，而且Jave的<code>Set</code>移除迭代器之后不影响继续遍历。</p>
<p>看看<code>accept()</code>的实现（删掉了日志语句）：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(key: <span class="type">SelectionKey</span>, processor: <span class="type">Processor</span>) &#123;</span><br><span class="line">  <span class="comment">// key.channel()向下转型, 从抽象类 SelectableChannel 转型为派生类 ServerSocketChannel</span></span><br><span class="line">  <span class="keyword">val</span> serverSocketChannel = key.channel().asInstanceOf[<span class="type">ServerSocketChannel</span>]</span><br><span class="line">  <span class="keyword">val</span> socketChannel = serverSocketChannel.accept() <span class="comment">// socket accept, 返回表示连接的 SocketChannel</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将远程地址对应的连接数加1, 如果超过了配置的最大连接数限额, connectionQuotas会抛出 TooManyConnectionsException</span></span><br><span class="line">    connectionQuotas.inc(socketChannel.socket().getInetAddress)</span><br><span class="line">    socketChannel.configureBlocking(<span class="literal">false</span>) <span class="comment">// socket设为非阻塞模式</span></span><br><span class="line">    socketChannel.socket().setTcpNoDelay(<span class="literal">true</span>) <span class="comment">// socket设置TCP_NODELAY选项, 禁止Nagle算法</span></span><br><span class="line">    socketChannel.socket().setKeepAlive(<span class="literal">true</span>) <span class="comment">// socket设置保活模式, 长时间没有发送心跳则发出RST包重置连接</span></span><br><span class="line">    <span class="comment">// 配置的 socket.send.buffer.bytes 不为默认值, 则设置 SO_SNDBUF 选项重置发送缓冲区大小</span></span><br><span class="line">    <span class="keyword">if</span> (sendBufferSize != <span class="type">Selectable</span>.<span class="type">USE_DEFAULT_BUFFER_SIZE</span>)</span><br><span class="line">      socketChannel.socket().setSendBufferSize(sendBufferSize)</span><br><span class="line"></span><br><span class="line">    processor.accept(socketChannel)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e: <span class="type">TooManyConnectionsException</span> =&gt;</span><br><span class="line">      close(socketChannel)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟socket编程里一样的套路，只不过检查了同一个IP的最大连接数是否超限，并且给表示连接的socket设置了一些选项，然后实际上还是调用了<code>Processor.accept()</code>方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accept</span></span>(socketChannel: <span class="type">SocketChannel</span>) &#123;</span><br><span class="line">  newConnections.add(socketChannel)</span><br><span class="line">  wakeup()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就很简单了，把配置好的<code>SocketChannel</code>给加入<code>Processor</code>内部的并发队列<code>newConnections</code>中，其类型前一篇提过，是<code>ConcurrentLinkedQueue</code>。</p>
<h2 id="Acceptor-run-总结"><a href="#Acceptor-run-总结" class="headerlink" title="Acceptor.run()总结"></a>Acceptor.run()总结</h2><p>抛开一些程序设计上的细节性知识，其实<code>Acceptor</code>线程的逻辑就是：</p>
<ol>
<li>循环，从<code>Selector</code>中等待I&#x2F;O事件就绪；</li>
<li>遍历所有的I&#x2F;O事件，将<code>isAcceptable</code>的套接字取出，并调用socket的<code>accept()</code>取得新连接；</li>
<li>检查最大连接数，没超限的话进行一些socket选项配置；</li>
<li>将配置后的socket存入<code>Processor</code>的内部队列中。</li>
</ol>
<p>可以看到<code>Acceptor</code>仅仅做了中介的作用，它是直接和客户端的连接请求打交道的，将成功的连接处理后传递给<code>Processor</code>，这样<code>Processor</code>就可以专心去处理网络数据的读写。</p>
<p>另一方面，我们可以看到<code>Channel</code>（在这里是<code>SocketChannel</code>类）其实就是对socket句柄的封装。</p>
<h2 id="Processor-run"><a href="#Processor-run" class="headerlink" title="Processor.run()"></a>Processor.run()</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">  startupComplete()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isRunning) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        configureNewConnections() <span class="comment">// 处理缓存的新连接</span></span><br><span class="line">        processNewResponses() <span class="comment">// 处理缓存的响应</span></span><br><span class="line">        poll() <span class="comment">// 轮询, 从 Selector 中获取准备好I/O的事件</span></span><br><span class="line">        <span class="comment">// 处理已完成的接收/发送以及断开的channels</span></span><br><span class="line">        processCompletedReceives()</span><br><span class="line">        processCompletedSends()</span><br><span class="line">        processDisconnected()</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="comment">// 这里吞下了所有异常, 因为让 processor 退出对 broker 的影响可能会很大, 但值得商榷的是,</span></span><br><span class="line">        <span class="comment">// 是否存在需要让整个 broker 停止的异常。</span></span><br><span class="line">        <span class="comment">// 通常抛出的异常都是和特定socket或者bad request相关的, 这些异常被捕获, 然后会被独立的方法处理, 因此不会在这里</span></span><br><span class="line">        <span class="comment">// 被捕获, 所以可能这里只会看到 ControlThrowable (仅仅是可见, 没有地方会抛出)</span></span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt; processException(<span class="string">&quot;Processor got uncaught exception.&quot;</span>, e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 将异常信息写入日志(略)</span></span><br><span class="line">    shutdownComplete()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只用照着<code>try</code>作用域内的方法一个个地看下来就行。</p>
<h3 id="1-configureNewConnections"><a href="#1-configureNewConnections" class="headerlink" title="1. configureNewConnections"></a>1. configureNewConnections</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">configureNewConnections</span></span>() &#123;</span><br><span class="line">  <span class="keyword">while</span> (!newConnections.isEmpty) &#123;</span><br><span class="line">    <span class="comment">// newConnections的SocketChannel依次出队</span></span><br><span class="line">    <span class="keyword">val</span> channel = newConnections.poll()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用链: selector.registerChannel =&gt; selector.buildAndAttachKafkaChannel =&gt; channelBuilder.buildChannel()</span></span><br><span class="line">      <span class="comment">// channel 会注册 OP_READ 事件(返回 SelectionKey)到 selector 上, 然后和 connectionId, SelectionKey 一起构造</span></span><br><span class="line">      <span class="comment">// KafkaChannel 对象, 以 connectionId 作为key组成键值对加入 selector.channels 中</span></span><br><span class="line">      selector.register(connectionId(channel.socket), channel)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// 捕获所有异常, 关闭 对应的socket防止socket泄漏</span></span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        close(channel)</span><br><span class="line">        <span class="comment">// 将异常信息写入日志(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见<code>Acceptor</code>仅仅将表示连接的<code>SocketChannel</code>交给<code>Processor</code>，而<code>Processor</code>则会为其注册读事件，同时交给<code>selector</code>管理时会将其包装为<code>KafkaChannel</code>，这个包装过程是由<code>ChannelBuilder</code>接口完成的，而接口指向的实际对象是在<code>Processor.createSelector()</code>中<code>ChannelBuilders.serverChannelBuilder()</code>方法创建的，对<code>PLAINTEXT</code>协议，即<code>PlaintextChannelBuilder</code>，其<code>buildChannel()</code>方法的调用和实现依次为：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id: SocketChannel.connectionId</span></span><br><span class="line"><span class="comment">// key: SocketChannel.register() 返回的 SelectionKey</span></span><br><span class="line"><span class="comment">// maxReceiveSize: config.socketRequestMaxBytes, 即配置&quot;socket.request.max.bytes&quot;</span></span><br><span class="line"><span class="comment">// memoryPool: SocketServer.memoryPool</span></span><br><span class="line"><span class="type">KafkaChannel</span> channel = channelBuilder.buildChannel(id, key, maxReceiveSize, memoryPool);</span><br><span class="line">key.attach(channel);  <span class="comment">// key原本是attach之前的SocketChannel的, 现在改变attach的对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> KafkaChannel <span class="title function_">buildChannel</span><span class="params">(String id, SelectionKey key, <span class="type">int</span> maxReceiveSize, MemoryPool memoryPool)</span> <span class="keyword">throws</span> KafkaException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">PlaintextTransportLayer</span> <span class="variable">transportLayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaintextTransportLayer</span>(key);</span><br><span class="line">        <span class="type">PlaintextAuthenticator</span> <span class="variable">authenticator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlaintextAuthenticator</span>(configs, transportLayer);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">KafkaChannel</span>(id, transportLayer, authenticator, maxReceiveSize,</span><br><span class="line">                memoryPool != <span class="literal">null</span> ? memoryPool : MemoryPool.NONE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 异常处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">PlaintextTransportLayer</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.socketChannel = (SocketChannel) key.channel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现<code>key</code>和<code>channel: SocketChannel</code>被存到了<code>KafkaChannel.transportLayer</code>字段中，因此在后面的源码中，给<code>KafkaChannel</code>注册和取消读&#x2F;写事件到<code>Selector</code>上时是使用<code>transportLayer</code>的<code>addInterestOps()</code>和<code>removeInterestOps()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterestOps</span><span class="params">(<span class="type">int</span> ops)</span> &#123;</span><br><span class="line">    key.interestOps(key.interestOps() | ops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeInterestOps</span><span class="params">(<span class="type">int</span> ops)</span> &#123;</span><br><span class="line">    key.interestOps(key.interestOps() &amp; ~ops);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>其实也就是调用了<code>SelectionKey</code>的<code>interestOps()</code>方法，不过包装了位运算<code>|</code>和<code>&amp;~</code>来表示添加和移除。</p>
<h3 id="2-processNewResponses"><a href="#2-processNewResponses" class="headerlink" title="2. processNewResponses"></a>2. processNewResponses</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processNewResponses</span></span>() &#123;</span><br><span class="line">  <span class="keyword">var</span> curr: <span class="type">RequestChannel</span>.<span class="type">Response</span> = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">while</span> (&#123;curr = dequeueResponse(); curr != <span class="literal">null</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// 将响应从 responseQueue 中依次出队, 这里取得 connectionId 作为 channelId</span></span><br><span class="line">    <span class="keyword">val</span> channelId = curr.request.context.connectionId</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据响应的类型进行不同操作</span></span><br><span class="line">      curr.responseAction <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">NoOpAction</span> =&gt;</span><br><span class="line">          <span class="comment">// 无操作: 无需发送响应给客户端, 因此需要读取更多请求到服务端的socket buffer中</span></span><br><span class="line">          <span class="comment">// 调用链: selector.unmute() =&gt; channel.unmute()</span></span><br><span class="line">          <span class="comment">// 会将 channel 从 selector.explicitlyMutedChannels 中移除,</span></span><br><span class="line">          <span class="comment">// 如果该channel处于连接状态, 会在 channel.transportLayer 注册 OP_READ 事件。</span></span><br><span class="line">          updateRequestMetrics(curr)</span><br><span class="line">          trace(<span class="string">&quot;Socket server received empty response to send, registering for read: &quot;</span> + curr)</span><br><span class="line">          openOrClosingChannel(channelId).foreach(c =&gt; selector.unmute(c.id))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">SendAction</span> =&gt;</span><br><span class="line">          <span class="comment">// 发送: 调用链为 sendResponse() =&gt; selector.send() =&gt; channel.setSend()</span></span><br><span class="line">          <span class="comment">// 将响应加入 inflightResponses 中, 并在 channel.transportLayer 注册 OP_WRITE 事件</span></span><br><span class="line">          <span class="keyword">val</span> responseSend = curr.responseSend.getOrElse(</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s&quot;responseSend must be defined for SendAction, response: <span class="subst">$curr</span>&quot;</span>))</span><br><span class="line">          sendResponse(curr, responseSend)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">RequestChannel</span>.<span class="type">CloseConnectionAction</span> =&gt;</span><br><span class="line">          <span class="comment">// 关闭连接： 关闭channel</span></span><br><span class="line">          updateRequestMetrics(curr)</span><br><span class="line">          trace(<span class="string">&quot;Closing socket connection actively according to the response code.&quot;</span>)</span><br><span class="line">          close(channelId)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// 将异常信息写入日志(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Processor</code>仅仅是对缓存在<code>responseQueue</code>中的响应进行处理，但是从请求到响应的转换并不是它的工作，查找了<code>responseQueue</code>的使用地方，可以看到实际上响应是由<code>RequestChannel.sendResponse()</code>方法发送过来的，更上一层，是<code>KafkaApis.sendResponse()</code>方法调用该方法，因此实际上是<code>KafkaApis</code>（位于<code>kafka.server</code>包内）完成对请求的处理。</p>
<p>至于<code>updateRequestMetrics()</code>方法和异常处理的部分我们不再关心。</p>
<h3 id="3-poll"><a href="#3-poll" class="headerlink" title="3. poll"></a>3. poll</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">poll</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 轮询300ms, 会将读取的请求/发送的响应/断开的连接，放入 selector 的 completeReceives/completedSends/disconnected</span></span><br><span class="line">  <span class="keyword">try</span> selector.poll(<span class="number">300</span>)</span><br><span class="line">  <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e @ (_: <span class="type">IllegalStateException</span> | _: <span class="type">IOException</span>) =&gt;</span><br><span class="line">      <span class="comment">// 不会重抛异常, 这样这次轮询的所有完成的 sends/receives/connections/disconnections 事件都会被处理</span></span><br><span class="line">      error(<span class="string">s&quot;Processor <span class="subst">$id</span> poll failed due to illegal state or IO exception&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键是<code>selector.poll()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) <span class="comment">// 检查参数合法性</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout should be &gt;= 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">madeReadProgressLastCall</span> <span class="operator">=</span> madeReadProgressLastPoll;</span><br><span class="line">    clear(); <span class="comment">// 清理前1次 poll() 中设置的一些字段 (理应在此2次 poll() 之间对它们全部进行处理)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">dataInBuffers</span> <span class="operator">=</span> !keysWithBufferedRead.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在以下情形时将timeout置为0 (代表已经有一些Channel I/O就绪了, select()会立刻返回)</span></span><br><span class="line">    <span class="comment">// 1. 已经有一些接收数据的 Channel 在上一次 poll() 中读了一些数据;</span></span><br><span class="line">    <span class="comment">// 2. 有可连接但暂为完成连接的 Channels;</span></span><br><span class="line">    <span class="comment">// 3. 上次有 Channel 进行了 read() 操作, 并且 Channel 本身缓存了数据.</span></span><br><span class="line">    <span class="comment">// 最后一种情况比较特殊, 它发生的场景是某些 Channels 有数据在中间缓冲区中但却无法读取(比如因为内存不足)</span></span><br><span class="line">    <span class="keyword">if</span> (hasStagedReceives() || !immediatelyConnectedKeys.isEmpty() || (madeReadProgressLastCall &amp;&amp; dataInBuffers))</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若之前内存池内存耗尽, 而现在又可用了, 将一些因为内存压力而暂时取消读事件的 Channel 重新注册读事件</span></span><br><span class="line">    <span class="keyword">if</span> (!memoryPool.isOutOfMemory() &amp;&amp; outOfMemory) &#123;</span><br><span class="line">        log.trace(<span class="string">&quot;Broker no longer low on memory - unmuting incoming sockets&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (KafkaChannel channel : channels.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isInMutableState() &amp;&amp; !explicitlyMutedChannels.contains(channel)) &#123;</span><br><span class="line">                channel.unmute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        outOfMemory = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 I/O就绪 的keys, 记录 select() 用时</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startSelect</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numReadyKeys</span> <span class="operator">=</span> select(timeout);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endSelect</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="built_in">this</span>.sensors.selectTime.record(endSelect - startSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 存在 I/O就绪 的Channels; 2和3 参见之前将 timeout = 0 部分的注释</span></span><br><span class="line">    <span class="keyword">if</span> (numReadyKeys &gt; <span class="number">0</span> || !immediatelyConnectedKeys.isEmpty() || dataInBuffers) &#123;</span><br><span class="line">        Set&lt;SelectionKey&gt; readyKeys = <span class="built_in">this</span>.nioSelector.selectedKeys();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll 有缓存数据的 Channels (但不Poll底层socket有缓存数据的Channels)</span></span><br><span class="line">        <span class="keyword">if</span> (dataInBuffers) &#123;</span><br><span class="line">            keysWithBufferedRead.removeAll(readyKeys); <span class="comment">//so no channel gets polled twice</span></span><br><span class="line">            Set&lt;SelectionKey&gt; toPoll = keysWithBufferedRead;</span><br><span class="line">            keysWithBufferedRead = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(); <span class="comment">//poll() calls will repopulate if needed</span></span><br><span class="line">            pollSelectionKeys(toPoll, <span class="literal">false</span>, endSelect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll 底层 socket 有缓存数据的 Channels</span></span><br><span class="line">        pollSelectionKeys(readyKeys, <span class="literal">false</span>, endSelect);</span><br><span class="line">        readyKeys.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll 待连接的 Channels</span></span><br><span class="line">        pollSelectionKeys(immediatelyConnectedKeys, <span class="literal">true</span>, endSelect);</span><br><span class="line">        immediatelyConnectedKeys.clear();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        madeReadProgressLastPoll = <span class="literal">true</span>; <span class="comment">//no work is also &quot;progress&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">endIo</span> <span class="operator">=</span> time.nanoseconds();</span><br><span class="line">    <span class="built_in">this</span>.sensors.ioTime.record(endIo - endSelect, time.milliseconds());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用 select() 结束时刻保证我们不会关闭刚刚传进 pollSelectionKeys() 的连接 (避免将其识别未过期连接)</span></span><br><span class="line">    maybeCloseOldestConnection(endSelect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在关闭过期连接后, 将完成接收的 Channels 加入 completedReceives.</span></span><br><span class="line">    addToCompletedReceives();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分继续深究的话比较复杂，Kafka在这方面考虑了不少，上述分析中对一些字段也只是简单地提了下，到此为止。总之，最重要的是直到<code>poll()</code>会填充<code>Selector</code>内部维护的<strong>已完成接收</strong>&#x2F;<strong>已完成发送</strong>&#x2F;<strong>已断开</strong>的<code>Channel</code>，以便之后处理。</p>
<p>PS：在处理完成的发送时，在调用<code>send()</code>向socket写入数据的同时取消监听对应<code>Channel</code>的<code>OP_WRITE</code>事件：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 KafkaChannel</span></span><br><span class="line"><span class="comment">// 调用链: Selector.PollSelectionKeys() =&gt; write() =&gt; send()</span></span><br><span class="line"><span class="keyword">private</span> boolean send(<span class="type">Send</span> send) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">    send.writeTo(transportLayer);</span><br><span class="line">    <span class="keyword">if</span> (send.completed())</span><br><span class="line">        transportLayer.removeInterestOps(<span class="type">SelectionKey</span>.<span class="type">OP_WRITE</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> send.completed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-processCompletedReceives"><a href="#4-processCompletedReceives" class="headerlink" title="4.  processCompletedReceives"></a>4.  processCompletedReceives</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedReceives</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 遍历所有完成接收的 NetworkService, 具体实现在 selector.poll() 方法中, 最后会调用 addToCompletedReceives()</span></span><br><span class="line">  <span class="comment">// 如果 channel 不在 explicitlyMutedChannels 中 (即调用了unmute()方法), 则会将 channel 对应的 NetworkService 队列</span></span><br><span class="line">  <span class="comment">// 弹出队首并加入 completedReceives 中。</span></span><br><span class="line"> selector.completedReceives.asScala.foreach &#123; receive =&gt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// NetworkServer 的 source 字段记录了连接channel的 connectionId</span></span><br><span class="line">      openOrClosingChannel(receive.source) <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(channel) =&gt;</span><br><span class="line">          <span class="comment">// 解析 payload (接收到的ByteBuffer)的头部</span></span><br><span class="line">          <span class="keyword">val</span> header = <span class="type">RequestHeader</span>.parse(receive.payload)</span><br><span class="line">          <span class="comment">// 将其与 channel 的会话层信息封装成 RequestContext</span></span><br><span class="line">          <span class="keyword">val</span> context = <span class="keyword">new</span> <span class="type">RequestContext</span>(header, receive.source, channel.socketAddress,</span><br><span class="line">            channel.principal, listenerName, securityProtocol)</span><br><span class="line">          <span class="comment">// 进一步将上述信息封装成 Request 对象</span></span><br><span class="line">          <span class="keyword">val</span> req = <span class="keyword">new</span> <span class="type">RequestChannel</span>.<span class="type">Request</span>(processor = id, context = context,</span><br><span class="line">            startTimeNanos = time.nanoseconds, memoryPool, receive.payload, requestChannel.metrics)</span><br><span class="line">          <span class="comment">// 这里仅仅是将 req 放入 requestChannel 的内部队列 requestQueue</span></span><br><span class="line">          requestChannel.sendRequest(req)</span><br><span class="line">          <span class="comment">// 取消监听该channel的 OP_READ 事件, 并添加到 explicitlyMutedChannels</span></span><br><span class="line">          selector.mute(receive.source)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">          <span class="comment">// 抛出异常(略)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-processCompleteSends"><a href="#4-processCompleteSends" class="headerlink" title="4. processCompleteSends"></a>4. processCompleteSends</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processCompletedSends</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 遍历所有完成发送的 NetworkService, 具体实现在 selector.poll() 方法中</span></span><br><span class="line">  selector.completedSends.asScala.foreach &#123; send =&gt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 将该网络地址的响应从 inflightResponses 中移除</span></span><br><span class="line">      <span class="keyword">val</span> resp = inflightResponses.remove(send.destination).getOrElse &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s&quot;Send for <span class="subst">$&#123;send.destination&#125;</span> completed, but not in `inflightResponses`&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      updateRequestMetrics(resp)</span><br><span class="line">      <span class="comment">// 将对应的 channel 从 explicitlyMutedChannels 中移除, 并且如果未断开连接, 则注册 OP_READ 事件</span></span><br><span class="line">      selector.unmute(send.destination)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-processDisconnected"><a href="#5-processDisconnected" class="headerlink" title="5. processDisconnected"></a>5. processDisconnected</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">processDisconnected</span></span>() &#123;</span><br><span class="line">  <span class="comment">// 遍历所有断开连接的channel的 connectionId, 具体实现在 selector.poll() 方法中</span></span><br><span class="line">  selector.disconnected.keySet.asScala.foreach &#123; connectionId =&gt;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 从 connectionId 中取得网络地址信息</span></span><br><span class="line">      <span class="keyword">val</span> remoteHost = <span class="type">ConnectionId</span>.fromString(connectionId).getOrElse &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s&quot;connectionId has unexpected format: <span class="subst">$connectionId</span>&quot;</span>)</span><br><span class="line">      &#125;.remoteHost</span><br><span class="line">      <span class="comment">// 将断开连接的网络地址的响应从 inflightResponses 中移除</span></span><br><span class="line">      inflightResponses.remove(connectionId).foreach(updateRequestMetrics)</span><br><span class="line">      <span class="comment">// the channel has been closed by the selector but the quotas still need to be updated</span></span><br><span class="line">      <span class="comment">// 更新 quotas 的信息, 即将该网络地址上的连接数减1</span></span><br><span class="line">      connectionQuotas.dec(<span class="type">InetAddress</span>.getByName(remoteHost))</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理(略)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Processor-run-总结"><a href="#Processor-run-总结" class="headerlink" title="Processor.run()总结"></a>Processor.run()总结</h2><p><code>Processor</code>使用了Kafka自己实现的<code>Selector</code>（别名为<code>KSelector</code>），比<code>Acceptor</code>使用的NIO默认的<code>Selector</code>（别名为<code>NSelector</code>）有更多的功能，因为<code>Processor</code>要维护监听socket的读&#x2F;写事件状态，即<code>OP_READ</code>和<code>OP_WRITE</code>。</p>
<p>一些具体的实现在<code>org.apache.kafka.common</code>的<code>network</code>包和<code>request</code>包中（Java实现），这里暂时不细看。</p>
<p>归结其流程为：</p>
<ol>
<li>从将<code>Acceptor</code>收到的新连接全部注册<code>OP_READ</code>事件，因为Kafka服务端不主动向客户端发送请求，只被动响应客户端的请求；</li>
<li>根据响应类型处理缓存的响应：<code>NoOpAction</code>&#x3D;&gt;重新注册<code>Channel</code>的读事件，<code>SendAction</code>&#x3D;&gt;注册<code>Channel</code>的写事件，将响应缓存，并交由<code>RequestChannel</code>发送，<code>CloseConnectionAction</code>&#x3D;&gt;关闭<code>Channel</code>；</li>
<li>轮询<code>Selector</code>得到就绪的I&#x2F;O事件（可读&#x2F;可写&#x2F;断开）；</li>
<li>对所有完成接收的数据（请求），封装后给<code>RequestChannel</code>发送；</li>
<li>对所有完成发送的数据（响应），从缓存中移除，并重新监听对应<code>Channel</code>的读事件；</li>
<li>对所有断开的连接，更新<code>connectionQuotas</code>维护的网络地址&#x3D;&gt;连接数的映射。</li>
</ol>
<p><code>Processor</code>本身只是做完成读&#x2F;写&#x2F;断开三种事件的处理，发送和接收实际上都是通过<code>RequestChannel</code>。至于<code>Processor</code>是由<code>SocketServer.newProcessor()</code>方法创建的，其内部的<code>requestChannel</code>字段就是<code>SocketServer</code>的同名字段。</p>
<p>因此，接下来就是阅读<code>RequestChannel</code>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/18/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB01-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/18/Kafka%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB01-%E7%BD%91%E7%BB%9C%E5%B1%82%E9%98%85%E8%AF%BB%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8/" class="post-title-link" itemprop="url">Kafka源码阅读01: 网络层阅读之服务器的启动</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-18 19:47:06" itemprop="dateCreated datePublished" datetime="2019-09-18T19:47:06+08:00">2019-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天正式开始阅读Kafka源码，作为阅读笔记的第一篇，先简单地介绍下背景。</p>
<p>阅读的Kafka版本是1.1.0，服务端源码在<code>core.main.scala.kafka</code>目录下，该目录下的源码文件仅有<code>Kafka.scala</code>，也就是服务端的启动入口，其他的若干个模块都阻止在各子目录下，这里首先阅读的是网络层，也就是<code>network</code>子目录下的代码。</p>
<p>阅读思路是直接看公用方法，然后再给一些逻辑以及用到的字段作注释，否则单看某些字段不看语境也不知道做什么。注释里会给英文两边加空格，逗号也使用英文逗号，方便vim快捷键按词前进&#x2F;后退。</p>
<p>使用Intellij Idea阅读的，之前用得比较少，也很折腾了下配置过程，记录一些阅读源码的方法：</p>
<ul>
<li>光标选中+单击鼠标左键：跳转至变量&#x2F;函数定义处；</li>
<li>Navigate菜单栏的Back和Forward，快捷键是<code>Ctrl+Alt+Left/Right</code>：后退&#x2F;前进到前&#x2F;后一次阅读的地方，一般时配合跳转功能回退；</li>
<li>光标选中+鼠标右键，选择Find Usages，快捷键是<code>Alt+Shift+F7</code>：查看变量&#x2F;函数所有使用的地方；</li>
<li>快捷键<code>Alt+F7</code>：查看类的所有字段和方法。</li>
</ul>
<p>对应我阅读C&#x2F;C++源码时vim的<code>Ctrl+J</code>（<code>YCM</code>）&#x2F;<code>Ctrl+]</code>（<code>ctags</code>）跳转，<code>Ctrl+O</code>回退，<code>LeaderF</code>查看类的字段和方法。之前vim一直没配置查找所有调用处的功能，一直是手动写个简单脚本用<code>egrep</code>在当前目录下递归搜关键词的……</p>
<p>不过IDE优点就是功能更大更全，上手新语言时直接使用，不必每接触一门语言旧学习怎么定制功能。</p>
<h2 id="SocketServer"><a href="#SocketServer" class="headerlink" title="SocketServer"></a>SocketServer</h2><p>注释表明了它是一个NIO套接字服务器，其线程模型是：</p>
<ul>
<li>1个Acceptor线程处理新连接；</li>
<li>Acceptor有N个Processor线程，其中每个都有自己的Selector从套接字中读取请求；</li>
<li>M个Handler线程，处理请求，并将回应发给Processor线程用于写入。</li>
</ul>
<p><code>SocketServer</code>的主构造器有以下参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> config: <span class="type">KafkaConfig</span> <span class="comment">// 配置文件</span></span><br><span class="line"><span class="keyword">val</span> metric: <span class="type">Metrics</span> <span class="comment">// 度量指标</span></span><br><span class="line"><span class="keyword">val</span> time: <span class="type">Time</span> <span class="comment">// 对象创建时间</span></span><br><span class="line"><span class="keyword">val</span> credentialProvider: <span class="type">CredentialProvider</span> <span class="comment">// 证书提供者</span></span><br></pre></td></tr></table></figure>

<p>混入了<code>Logging</code>和<code>KafkaMetricsGroup</code>特质，后者继承自前者，但并没重写<code>info()</code>等日志方法，而是将不同类型的metric（度量指标）给组织起来，提供了各种metric的工厂方法。</p>
<p>对于日志，设置了类相关的前缀表明broker id：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> logContext = <span class="keyword">new</span> <span class="type">LogContext</span>(<span class="string">s&quot;[SocketServer brokerId=<span class="subst">$&#123;config.brokerId&#125;</span>] &quot;</span>)</span><br><span class="line"><span class="keyword">this</span>.logIdent = logContext.logPrefix</span><br></pre></td></tr></table></figure>

<p>涉及到的一些字段，我添上了注释并按相关度整合了下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个ip的最大连接数, 配置: max.connections.per.ip</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIp = config.maxConnectionsPerIp</span><br><span class="line"><span class="comment">// 指定ip的最大连接数, 会覆盖 maxConnectionsPerIp, 配置: max.connections.per.ip.overrides</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> maxConnectionsPerIpOverrides = config.maxConnectionsPerIpOverrides</span><br><span class="line"><span class="comment">// 由以上参数创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> connectionQuotas: <span class="type">ConnectionQuotas</span> = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求队列的最大容量, 配置: queued.max.requests</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> maxQueuedRequests = config.queuedMaxRequests</span><br><span class="line"><span class="comment">// 内部维护了一个请求队列</span></span><br><span class="line"><span class="keyword">val</span> requestChannel = <span class="keyword">new</span> <span class="type">RequestChannel</span>(maxQueuedRequests)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 Processor 拥有自己的 Selector, 用于从连接中读取请求和写回响应</span></span><br><span class="line"><span class="comment">// Processor 会将请求发送至 requestChannel, 会从 responseChannels 中读取响应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Int</span>, <span class="type">Processor</span>]() <span class="comment">// key: id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextProcessorId = <span class="number">0</span> <span class="comment">// 递增作为每个 processor 的id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// key: EndPoint, 即配置 listeners 指定的 ip/port 以及其 SecurityProtocol (默认PLAINTEXT)</span></span><br><span class="line"><span class="comment">// 对每个绑定的 ip/port 都创建唯一对应的 Acceptor, 用于创建连接 Channel</span></span><br><span class="line"><span class="comment">// PS: 该字段在 network包 内可访问，实际上目前也就这个类会访问。</span></span><br><span class="line"><span class="keyword">private</span>[network] <span class="keyword">val</span> acceptors = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">EndPoint</span>, <span class="type">Acceptor</span>]()</span><br></pre></td></tr></table></figure>

<h2 id="服务器启动源码分析"><a href="#服务器启动源码分析" class="headerlink" title="服务器启动源码分析"></a>服务器启动源码分析</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">startup</span></span>() &#123;</span><br><span class="line">  <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">    <span class="comment">// connectionQuotas 用于限制IP的最大连接数</span></span><br><span class="line">    connectionQuotas = <span class="keyword">new</span> <span class="type">ConnectionQuotas</span>(maxConnectionsPerIp, maxConnectionsPerIpOverrides)</span><br><span class="line">    <span class="comment">// 创建 Acceptors 和 Processors</span></span><br><span class="line">    createAcceptorAndProcessors(config.numNetworkThreads, config.listeners)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 忽略了剩下的代码, 都是调用 KafkaMetricsGroup.newGauge 创建 Gauge对象, </span></span><br><span class="line">  <span class="comment">// 用于测量某些指标, 比如Processor的平均闲置百分比/内存池可用大小/内存池占用大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 Acceptor 和 Processor 的创建：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createAcceptorAndProcessors</span></span>(processorsPerListener: <span class="type">Int</span>,</span><br><span class="line">                                        endpoints: <span class="type">Seq</span>[<span class="type">EndPoint</span>]): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// socket内部缓冲区大小，底层可用C函数 setsockopt 设置 SO_SNDBUF/SO_RCVBUF</span></span><br><span class="line">  <span class="keyword">val</span> sendBufferSize = config.socketSendBufferBytes <span class="comment">// socket.send.buffer.bytes</span></span><br><span class="line">  <span class="keyword">val</span> recvBufferSize = config.socketReceiveBufferBytes <span class="comment">// socket.receive.buffer.bytes</span></span><br><span class="line">  <span class="keyword">val</span> brokerId = config.brokerId <span class="comment">// broker.id</span></span><br><span class="line"></span><br><span class="line">  endpoints.foreach &#123; endpoint =&gt;</span><br><span class="line">    <span class="keyword">val</span> listenerName = endpoint.listenerName</span><br><span class="line">    <span class="keyword">val</span> securityProtocol = endpoint.securityProtocol</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> acceptor = <span class="keyword">new</span> <span class="type">Acceptor</span>(endpoint, sendBufferSize, recvBufferSize, brokerId, connectionQuotas)</span><br><span class="line">    <span class="type">KafkaThread</span>.nonDaemon(<span class="string">s&quot;kafka-socket-acceptor-<span class="subst">$listenerName</span>-<span class="subst">$securityProtocol</span>-<span class="subst">$&#123;endpoint.port&#125;</span>&quot;</span>, acceptor).start()</span><br><span class="line">    acceptor.awaitStartup() <span class="comment">// 等待acceptor线程完全启动</span></span><br><span class="line">    acceptors.put(endpoint, acceptor) <span class="comment">// 构建键值对 &lt;EndPoint, Acceptor&gt; 加入 acceptors</span></span><br><span class="line">    <span class="comment">// 单个 Acceptor 对应 processorsPerListener(即numNetworkThreads)个 Processors</span></span><br><span class="line">    addProcessors(acceptor, endpoint, processorsPerListener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对每个<code>Acceptor</code>，会创建多个<code>Processor</code>，类似地，也存入<code>ConcurrentHashMap</code>中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">addProcessors</span></span>(acceptor: <span class="type">Acceptor</span>, endpoint: <span class="type">EndPoint</span>, newProcessorsPerListener: <span class="type">Int</span>): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> listenerName = endpoint.listenerName</span><br><span class="line">  <span class="keyword">val</span> securityProtocol = endpoint.securityProtocol</span><br><span class="line">  <span class="keyword">val</span> listenerProcessors = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Processor</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (_ &lt;- <span class="number">0</span> until newProcessorsPerListener) &#123;</span><br><span class="line">    <span class="keyword">val</span> processor = newProcessor(nextProcessorId, connectionQuotas, listenerName, securityProtocol, memoryPool)</span><br><span class="line">    listenerProcessors += processor</span><br><span class="line">    <span class="comment">// 内部调用了 putIfAbsent() 方法将其加入了 requestChannel 内部维护的 ConcurrentHashMap[Int, Processor],</span></span><br><span class="line">    <span class="comment">// key为 processor.id, 使用 putIfAbsent() 方法是因为理论上 processer.id 是唯一的, 因此在插入重复的id时,</span></span><br><span class="line">    <span class="comment">// 不应插入新对象, 而是仅仅返回一个非空 Processor 并根据返回值打印日志</span></span><br><span class="line">    requestChannel.addProcessor(processor)</span><br><span class="line">    <span class="comment">// 仅在此递增 SocketServer 的 nextProcessId 字段，因此保证了对不同 Acceptor 的 Processors,</span></span><br><span class="line">    <span class="comment">// 其 id 是不同的，因此每个 Processor 在 processors 字段中都对应唯一的 key</span></span><br><span class="line">    nextProcessorId += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  listenerProcessors.foreach(p =&gt; processors.put(p.id, p))</span><br><span class="line">  <span class="comment">// 启动 listenerProcessors 的所有 Processor 线程, 并将其添加到内部维护的 processor: ArrayBuffer[Processor] 中</span></span><br><span class="line">  acceptor.addProcessors(listenerProcessors)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestChannel-x2F-Acceptor-x2F-Processor的字段"><a href="#RequestChannel-x2F-Acceptor-x2F-Processor的字段" class="headerlink" title="RequestChannel&#x2F;Acceptor&#x2F;Processor的字段"></a>RequestChannel&#x2F;Acceptor&#x2F;Processor的字段</h2><p>从上述代码可知，重点是<code>RequestChannel</code>&#x2F;<code>Acceptor</code>&#x2F;<code>Processor</code>这3个类型，于是现在看看它们创建时除去传入构造器的参数外初始化的其他字段（依然忽略metrics相关的）。</p>
<p>首先是<code>RequestChannel</code>的字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建了固定长度的请求队列，queueSize由 queued.max.requests 决定</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> requestQueue = <span class="keyword">new</span> <span class="type">ArrayBlockingQueue</span>[<span class="type">BaseRequest</span>](queueSize)</span><br><span class="line"><span class="comment">// 之前已经提过，创建 Processors 时添加进的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Int</span>, <span class="type">Processor</span>]()</span><br></pre></td></tr></table></figure>

<p>此外，配置是使用<code>kafka.server.KafkaConfig</code>类实现的，默认配置在伴生对象<code>kafka.server.Defaults</code>中（比如默认的<code>queueSize</code>为500），并在<code>KafkaConfig</code>的伴生对象的<code>configDef</code>字段创建时加载。</p>
<p>再就是<code>Acceptor</code>的字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NIO Selector, 用于注册 connect, read, write 等事件，并将事件分发给 Acceptor, Processors</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> nioSelector = <span class="type">NSelector</span>.open()</span><br><span class="line"><span class="comment">// 服务通道, 绑定 EndPoint, 用于接收客户端的连接, 类型为 ServerSocketChannel</span></span><br><span class="line"><span class="keyword">val</span> serverChannel = openServerSocket(endPoint.host, endPoint.port)</span><br><span class="line"><span class="comment">// 之前提过的，保存每个 Acceptor 对应的 Processors, 没有存为映射, 因为 Acceptor 要将</span></span><br><span class="line"><span class="comment">// 连接均衡地分配给 Processors, 不涉及查询操作, 更多地需要遍历, 比如round-robin算法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Processor</span>]()</span><br></pre></td></tr></table></figure>

<p>其中 <code>NSelector</code> 就是 <code>Selector</code> 的别名：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.channels.&#123;<span class="type">Selector</span> =&gt; <span class="type">NSelector</span>&#125;</span><br></pre></td></tr></table></figure>

<p>最后是<code>Processor</code>的字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SocketChannel 的并发队列, 用于管理 Acceptor 分配的socket连接</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> newConnections = <span class="keyword">new</span> <span class="type">ConcurrentLinkedQueue</span>[<span class="type">SocketChannel</span>]()</span><br><span class="line"><span class="comment">// ConnectionId 到 Response 的映射, 缓存待发送的响应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> inflightResponses = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br><span class="line"><span class="comment">// 缓存产生的响应</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> responseQueue = <span class="keyword">new</span> <span class="type">LinkedBlockingDeque</span>[<span class="type">RequestChannel</span>.<span class="type">Response</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建的是 kafka.common.network.Selector, 也就是自己实现的 Selector</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> selector = createSelector(</span><br><span class="line">  <span class="type">ChannelBuilders</span>.serverChannelBuilder(listenerName,</span><br><span class="line">    listenerName == config.interBrokerListenerName,</span><br><span class="line">    securityProtocol,</span><br><span class="line">    config,</span><br><span class="line">    credentialProvider.credentialCache,</span><br><span class="line">    credentialProvider.tokenCache))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于生成连接的 index, 类似 SocketServer 生成 Processor.id, 不过保证了 index 非负</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextConnectionIndex = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>不得不说这里为何要使用 <code>ConcurrentLinkedQueue</code> 和 <code>LinkedBlockingDeque</code> 还是不清楚，但还是先不要在意细节，注意这里保存了2份<code>Response</code>，一个只是临时缓存处理后的响应，另一个则是真正待发送的响应，因为用key记录了连接信息：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为 inflightResponses 的key, 记录了本地地址/远程地址, 以及连接对应的索引</span></span><br><span class="line"><span class="comment">// 该索引是通过 nextConnectionIndex 自增生成的, 而且非负</span></span><br><span class="line"><span class="keyword">private</span>[network] <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionId</span>(<span class="params">localHost: <span class="type">String</span>, localPort: <span class="type">Int</span>, remoteHost: <span class="type">String</span>, remotePort: <span class="type">Int</span>, index: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">s&quot;<span class="subst">$localHost</span>:<span class="subst">$localPort</span>-<span class="subst">$remoteHost</span>:<span class="subst">$remotePort</span>-<span class="subst">$index</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="服务器启动总结"><a href="#服务器启动总结" class="headerlink" title="服务器启动总结"></a>服务器启动总结</h2><p>总结下来，启动<code>SocketServer</code>时其实就是根据配置参数创建了1个<code>RequestChannel</code>，M个<code>Acceptor</code>，M*N个<code>Processor</code>。其中M是监听地址的数量，N是<code>num.network.thread</code>配置的Acceptor对应的Processors的数量。</p>
<p>每个监听地址除了ip和port外，还有协议类型和名称，这些共同组成了<code>EndPoint</code>类。</p>
<ul>
<li><code>SocketServer</code>保存<code>EndPoint</code>到<code>Acceptor</code>的映射和<code>Processor.id</code>到<code>Processor</code>的映射；</li>
<li><code>requestChannel</code>持有M*N个<code>Processor</code>的<code>id</code>到其自身的映射；</li>
<li>每个<code>Acceptor</code>持有1个<code>Selector</code>；</li>
<li>每个<code>Acceptor</code>持有1个监听<code>EndPoint</code>的<code>ServerSocketChannel</code>；</li>
<li>每个<code>Acceptor</code>持有N个<code>Processor</code>组成的数组；</li>
<li>每个 <code>Processor</code> 持有1个<code>Selector</code>（Kafka自己实现的<code>Selectable</code>接口）；</li>
<li>每个<code>Processor</code>持有一组socket连接；</li>
<li><code>acceptors</code>和<code>processors</code>都启动了线程（供<code>M*(N+1)</code>个）构成了整个网络层的处理。</li>
</ul>
<p>Kafka的网络层是使用Reactor模式的，使用了Java NIO，所有的socket读写都是非阻塞模式，具体框架可以参考《Apacha Kafka源码剖析》一书，我目前也是照着这本书的思路去看源码。</p>
<p>不过对Java NIO不熟悉，虽然看了眼核心还是分发事件的<code>Selector</code>（I&#x2F;O多路复用），但是封装得比较好。抽空去看看。</p>
<p>网络层运转的核心还是<code>Acceptor</code>和<code>Processor</code>的线程函数，也就是这2个类的<code>run()</code>方法，也是接下来要读的部分。</p>
<h2 id="为什么使用ConcurrentHashMap？"><a href="#为什么使用ConcurrentHashMap？" class="headerlink" title="为什么使用ConcurrentHashMap？"></a>为什么使用ConcurrentHashMap？</h2><p>《Apacha Kafka源码剖析》书中使用的是Kafka 0.10.0.1版本，其中<code>acceptors</code>和<code>processors</code>的类型是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> processors = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Processor</span>](totalProcessorThreads)</span><br><span class="line"><span class="keyword">private</span>[network] <span class="keyword">val</span> acceptors = mutable.<span class="type">Map</span>[<span class="type">EndPoint</span>, <span class="type">Acceptor</span>]()</span><br></pre></td></tr></table></figure>

<p>而1.1.0版本就都用<code>ConcurrentHashMap</code>来保存了，看源码时我也在想为什么不用数组去存processors，因为key就是从0到N-1。搜了下这个结构在Java 8用了不同于7的实现，抽空去看看。</p>
<p>然后看到了<code>addListeners</code>&#x2F;<code>removeListeners</code>方法，前者根据新的<code>Seq[EndPoint]</code>重新创建<code>acceptors</code>和<code>processors</code>，后者则将指定的<code>Seq[EndPoint]</code>对应的<code>Acceptor</code>从<code>acceptors</code>中删除。而这两个方法在0.10.0.1版本中没有，所以就能用固定长度的数组来保存<code>processors</code>，也能用不支持并发访问的<code>mutable.Map</code>来保存<code>acceptors</code>。</p>
<p>不过还有个不明白的地方，看到直接访问<code>acceptors</code>和<code>processors</code>的都是<code>SocketServer</code>内部，而除了<code>boundPort()</code>方法和<code>stopProcessingRequests()</code>外，所在访问它们的方法都直接用<code>synchronized</code>关键字保护了，而<code>boundPort()</code>方法仅在<code>xxxTest.scala</code>中被调用了，这样的话使用<code>ConcurrentHashMap</code>是否必要？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9RPATH%E4%BB%A5%E5%8F%8A%E5%9C%A8cmake%E5%92%8Cgcc%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/05/%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9RPATH%E4%BB%A5%E5%8F%8A%E5%9C%A8cmake%E5%92%8Cgcc%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">链接选项RPATH以及在cmake和gcc中的使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-05 01:12:42" itemprop="dateCreated datePublished" datetime="2019-09-05T01:12:42+08:00">2019-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>注：此文已作废，本文存在若干事实性错误以及误导，在<a target="_blank" rel="noopener" href="https://bewaremypower.github.io//2020/07/14/%E9%93%BE%E6%8E%A5%E9%80%89%E9%A1%B9-rpath-%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%8E%9F%E7%90%86/">最新一篇文章</a>中将重新说明。</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>毕业前帮师兄写框架程序时，以及最近折腾公司内部项目的编译，都遇到一些以前没有遇到的问题，这里简单地记一些。</p>
<p>本文要讲的也就是 <code>rpath</code> ，即 relative path 的缩写，最初遇到这个坑时是在写 <code>cmake</code> 时，直接 <code>make</code> 生成的程序能够链接到指定的动态库，但是 <code>make install</code> 之后发现就链接失效了。</p>
<h2 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h2><p>这里举个简单的例子来复现，目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ tree .</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── foo.c</span><br><span class="line">    └── foo.h</span><br></pre></td></tr></table></figure>

<p>代码组织方式是： <code>src</code> 目录为库目录，其源码会编译成动态库 <code>libfoo.so</code>，<code>example</code> 为示例目录，其源码会包含 <code>src</code> 目录的头文件，并链接到动态库 <code>libfoo.so</code> 。具体代码也不长，依次贴出：</p>
<p><code>./CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"><span class="keyword">project</span>(example C)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CFLAGS -g -Wall)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p><code>./src/CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(foo SHARED foo.c)</span><br><span class="line"><span class="keyword">install</span>(TARGETS foo LIBRARY DESTINATION lib)</span><br></pre></td></tr></table></figure>

<p><code>./src/foo.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FOO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FOO_H</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// FOO_H</span></span></span><br></pre></td></tr></table></figure>

<p><code>./src/foo.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;foo\n&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>

<p><code>./example/CMakeLists</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(main main.c)</span><br><span class="line"><span class="keyword">include_directories</span>(../src)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main foo)</span><br><span class="line"><span class="keyword">install</span>(TARGETS main RUNTIME DESTINATION bin)</span><br></pre></td></tr></table></figure>

<p><code>./example/main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  foo();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编译、安装及测试"><a href="#编译、安装及测试" class="headerlink" title="编译、安装及测试"></a>编译、安装及测试</h2><p>老方法，新建一个临时目录用来存放中间文件，以下命令在项目根目录下执行，将动态库和可执行程序安装到根目录下的 <code>lib</code> 和 <code>bin</code> 目录，然后回到根目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake .. -DCMAKE_INSTALL_PREFIX=..</span><br><span class="line">make &amp;&amp; make install &amp;&amp; <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<p>此时目录结构为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ tree . -I build</span><br><span class="line">.</span><br><span class="line">├── bin</span><br><span class="line">│   └── main</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.c</span><br><span class="line">├── lib</span><br><span class="line">│   └── libfoo.so</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── foo.c</span><br><span class="line">    └── foo.h</span><br></pre></td></tr></table></figure>

<p>首先我们运行 <code>build</code> 目录下的可执行文件，并查看其连接的 <code>libfoo.so</code> 路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./build/example/main </span><br><span class="line">foo</span><br><span class="line">$ ldd ./build/example/main | grep foo</span><br><span class="line">	libfoo.so =&gt; /home/xyz/RPATH/build/src/libfoo.so (0x00007f5d41c23000)</span><br></pre></td></tr></table></figure>

<p>这里 <code>/home/xyz/RPATH</code> 是我的项目根目录绝对路径，可以发现 <code>make</code> 生成的可执行文件，链接的是绝对路径，并且运行也没问题。但是再看看安装后的可执行文件和链接的库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/main </span><br><span class="line">./bin/main: error <span class="keyword">while</span> loading shared libraries: libfoo.so: cannot open shared object file: No such file or directory</span><br><span class="line">$ ldd ./bin/main | grep foo</span><br><span class="line">	libfoo.so =&gt; not found</span><br></pre></td></tr></table></figure>

<p>我们会发现可执行文件失去了链接，因此要运行 <code>main</code> ，必须手动将动态库添加到系统路径中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LD_LIBRARY_PATH=./lib ./bin/main </span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<h2 id="问题在哪"><a href="#问题在哪" class="headerlink" title="问题在哪"></a>问题在哪</h2><p>这个问题最初出现在我帮师兄写的框架当中，当时也找到了stackoverflow上的讨论帖：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/42695839/cmake-make-install-does-not-link-against-libraries-in-ubuntu">cmake: “make install” does not link against libraries in Ubuntu</a></p>
<p>简单翻译下：</p>
<p>系统首先会在 <code>/etc/ld.so.conf</code> 文件配置的路径中寻找动态库（在我的系统上该文件记录的是 <code>/etc/ld.so.conf.d</code> 目录下的所有 <code>*.conf</code> 文件），如果找不到，则有以下4个选项：</p>
<ol>
<li>将库安装到系统默认路径比如 <code>/lib</code> 和 <code>/usr/lib</code>（但可能因为没有权限而无法实施）；</li>
<li>编辑系统范围的搜索路径（同样可能因为没有权限而无法实施）；</li>
<li>设置 <code>LD_LIBRARY_PATH</code>（就像我们上节末尾所做的，但它会覆盖系统路径，也就是说可能会优先选择自己的库而不是系统路径的同名库）；</li>
<li>设置 <code>RPATH</code>，告诉可执行文件该到哪寻找它的库。</li>
</ol>
<p>OK，现在来看问题的产生原因：<code>RPATH</code> 在 <code>make install</code> 后会被自动地清除。为什么会这样呢？因为 <code>cmake</code> 安装的可执行文件和动态库的相对路径，可能和 <code>make</code> 生成的不一样，因此无法自动记住。</p>
<h2 id="cmake的解决方法"><a href="#cmake的解决方法" class="headerlink" title="cmake的解决方法"></a>cmake的解决方法</h2><p>当然，<code>cmake</code> 本身也提供了解决方法，参见：<a target="_blank" rel="noopener" href="https://gitlab.kitware.com/cmake/community/wikis/doc/cmake/RPATH-handling">RPATH handling</a>。</p>
<p>不想看官网的长篇大论的话，针对本文的示例，在项目根目录的 <code>CMakeLists.txt</code> 中添加：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH <span class="string">&quot;$&#123;CMAKE_INSTALL_PREFIX&#125;/lib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_RPATH_USE_LINK_PATH <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>

<p><code>make install</code> 安装时可以看到如下提示信息：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- Installing: <span class="regexp">/home/</span>xyz<span class="regexp">/RPATH/</span>bin/main</span><br><span class="line">-- Set <span class="keyword">runtime</span> path of <span class="string">&quot;/home/xyz/RPATH/bin/main&quot;</span> to <span class="string">&quot;/home/xyz/RPATH/lib&quot;</span></span><br></pre></td></tr></table></figure>

<p>这种方式还是设置的绝对路径，也就是 <code>cmake</code> 安装目录下的 <code>lib</code> 子目录，然后可以发现安装后的 <code>main</code> 成功链接到了 <code>libfoo.so</code>，并且改变 <code>main</code> 路径，仍然可以链接到 <code>libfoo.so</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldd bin/main | grep foo</span><br><span class="line">	libfoo.so =&gt; /home/xyz/RPATH/lib/libfoo.so (0x00007f60818c2000)</span><br><span class="line">$ <span class="built_in">mv</span> bin/main .</span><br><span class="line">$ ldd main | grep foo</span><br><span class="line">	libfoo.so =&gt; /home/xyz/RPATH/lib/libfoo.so (0x00007f6ff516f000)</span><br></pre></td></tr></table></figure>

<p>类似地，我们可以把 <code>CMAKE_INSTALL_RPATH</code> 指定为相对路径 <code>../lib</code>，但这样的话局限性比较大，也就是说必须保证动态库在 <code>$PWD/../lib</code> 下，比如按这种方式编译安装后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ldd ./bin/main | grep foo</span><br><span class="line">	libfoo.so =&gt; not found</span><br><span class="line">$ <span class="built_in">cd</span> bin</span><br><span class="line">$ ldd ./main | grep foo</span><br><span class="line">	libfoo.so =&gt; ../lib/libfoo.so (0x00007f12fe0c7000)</span><br></pre></td></tr></table></figure>

<p>但这种方式也有个优点，也就是说哦，只要动态库在当前工作目录的相对路径 <code>../lib</code> 下，就能链接到该动态库，此时可以写一个脚本，和 <code>main</code> 放在同一目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SHELL_DIR=$(<span class="built_in">cd</span> $(<span class="built_in">dirname</span> <span class="variable">$0</span>) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$PWD</span>)</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$SHELL_DIR</span> &amp;&amp; ./main</span><br></pre></td></tr></table></figure>

<p>第一行是取得脚本目录的绝对路径，第2行是进入该路径，这样只要动态库在可执行文件（以及运行脚本）的相对路径 <code>../lib</code> 下，无论从哪个目录调用该脚本，都能成功使可执行文件链接到该动态库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> bin/</span><br><span class="line">main  run.sh</span><br><span class="line">$ <span class="built_in">ls</span> lib/</span><br><span class="line">libfoo.so</span><br><span class="line">$ ./bin/run.sh </span><br><span class="line">foo</span><br><span class="line">$ <span class="built_in">cd</span> bin/ &amp;&amp; ./run.sh &amp;&amp; <span class="built_in">cd</span> -</span><br><span class="line">foo</span><br><span class="line">/home/xyz/RPATH</span><br><span class="line">$ <span class="built_in">mkdir</span> temp</span><br><span class="line">$ <span class="built_in">mv</span> bin/ lib/ temp/</span><br><span class="line">$ ./temp/bin/run.sh </span><br><span class="line">foo</span><br></pre></td></tr></table></figure>

<p>不过既然借助了辅助脚本了，实际上在脚本里手动设置 <code>LD_LIBRARY_PATH</code> 为相对路径看起来更简单一些。</p>
<h2 id="GCC的解决方法"><a href="#GCC的解决方法" class="headerlink" title="GCC的解决方法"></a>GCC的解决方法</h2><p>为什么说到这个呢？因为我最近在使用公司内部项目的时候，发现自己的测试代码一直出错，查看日志，竟然源码路径来自其他用户的个人目录。也就是说是其他用户编译了动态库，然后使用超级权限将其安装到了系统目录。</p>
<p>对于这种情况，可以用 <code>LD_LIBRARY_PATH</code> 覆盖，但是如果修改了目录后，每次都要重新设置 <code>LD_LIBRARY_PATH</code>，此时用 <code>gcc</code> 的链接选项就行了，还是对这个项目，手动用 <code>gcc</code> 进行编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> src/</span><br><span class="line">$ gcc -c -fPIC foo.c </span><br><span class="line">$ gcc -shared foo.o -o libfoo.so</span><br><span class="line">$ <span class="built_in">cd</span> ../example/</span><br><span class="line">$ gcc main.c -I../src -L../src -lfoo -Wl,-rpath=../src</span><br></pre></td></tr></table></figure>

<p>注意，<code>-Wl,-rpath</code> 这个选项必不可少，它指定了 <code>RPATH</code> 的相对路径，为此，我将原来的 <code>libfoo.so</code> 放在系统目录 <code>/lib64</code> 下，然后修改 <code>foo.c</code> （打印 <code>&quot;new foo&quot;</code> 而不是 <code>&quot;foo&quot;</code>）后编译成动态库放在 <code>src</code> 目录下，测试如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> example/</span><br><span class="line">$ gcc main.c -I../src -L../src -lfoo</span><br><span class="line">$ ./a.out </span><br><span class="line">foo</span><br><span class="line">$ gcc main.c -I../src -L../src -lfoo -Wl,-rpath=../src</span><br><span class="line">$ ./a.out </span><br><span class="line">new foo</span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">mkdir</span> temp &amp;&amp; <span class="built_in">mv</span> src/ example/ temp</span><br><span class="line">$ tree temp/</span><br><span class="line">temp/</span><br><span class="line">├── example</span><br><span class="line">│   ├── a.out</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   └── main.c</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── foo.c</span><br><span class="line">    ├── foo.h</span><br><span class="line">    ├── foo.o</span><br><span class="line">    └── libfoo.so</span><br><span class="line">$ ./temp/example/a.out </span><br><span class="line">foo</span><br><span class="line">$ <span class="built_in">cd</span> temp/example/ &amp;&amp; ./a.out</span><br><span class="line">new foo</span><br></pre></td></tr></table></figure>

<p>和刚才 <code>cmake</code> 设置 <code>RPATH</code> 的测试结果一样，只要当前工作目录满足和动态库所在目录的相对路径是 <code>RPATH</code>，那么运行可执行文件所链接到的动态库就是相对路径的动态库。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/26/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-4-GDB%E5%8D%87%E7%BA%A78-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/26/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-4-GDB%E5%8D%87%E7%BA%A78-0/" class="post-title-link" itemprop="url">我的vim开发环境搭建(4): GDB升级8.0</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-26 23:16:10" itemprop="dateCreated datePublished" datetime="2019-07-26T23:16:10+08:00">2019-07-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p>因为CentOS 6的GDB版本太老，所以在调试我自己安装的高版本GCC编译的程序时，很多时候打印不出变量来，所以需要升级GDB。</p>
<p>之前在CentOS 6上下载GDB源码编译总是出问题，网上也搜不到解决原因，不过最后自己折腾出来原因了。问题关键在于configure阶段，正确的宏没有检测出来，导致条件编译出错，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_XXX</span></span><br><span class="line"><span class="comment">// 某些类型的定义或相应头文件的包含...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果<code>HAVE_XXX</code>宏没有检测出来的话，本应该定义的类型就没有了。这既可能造成编译阶段找不到类型定义，也可能造成链接阶段找不到函数的定义(因为某些函数的参数是typedef别名或者宏)。</p>
<p>明白这一点后，只需要make时根据错误在对应代码中删除相应的<code>#ifdef</code>或者<code>#ifndef</code>块就行，这里以GDB 8.0的编译为例。</p>
<h2 id="1-工具和说明"><a href="#1-工具和说明" class="headerlink" title="1. 工具和说明"></a>1. 工具和说明</h2><p>有时候代码出错，提示某些类型或宏定义不存在。这时可以查找这些宏是在哪个文件中：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> . -name <span class="string">&quot;*.h&quot;</span> | xargs grep -<span class="built_in">n</span> <span class="string">&quot;XXX&quot;</span></span><br></pre></td></tr></table></figure>

<p>有时候不在GDB源码目录下，而是在系统头文件中，比如<code>B0</code>就是<code>termios.h</code>中的定义，此时可以利用搜索引擎搜索，并YouCompleteMe的代码跳转功能来确认，有些头文件是<code>sys/xxx.h</code>而非<code>xxx.h</code>（旧版本的系统），这些GDB源码通过条件编译判断到底是包含哪个。</p>
<p>此外，跳转功能还是要结合ctags，YCM好用在于它是基于语义的分析，但是得设置包含路径，默认包含路径只有当前目录，如果直接包含子目录头文件而不给出子目录名（编译时<code>-I</code>指定子目录路径即可）。ctags无脑找标签，所以有时候直接包含子目录的头文件，即使不做设置也可以跳转。ctags只需要在源码目录下<code>ctags -R .</code>生成tags文件，之后<code>Ctrl+]</code>就可以跳转了。</p>
<p>一般提示<code>xxx.c</code>出错，先仔细看看对应的<code>xxx.h</code>头文件，是否因为条件编译导致某些类型定义找不到。如果该头文件找不到，就可能通过上面的方法找到类型定义处，基本上一大堆宏都是在<code>config.h</code>中。</p>
<p>另外，错误提示的文件目录为GDB源码解压后的gdb子目录。</p>
<h2 id="2-出错解决"><a href="#2-出错解决" class="headerlink" title="2. 出错解决"></a>2. 出错解决</h2><h3 id="2-1-编译错误处理"><a href="#2-1-编译错误处理" class="headerlink" title="2.1. 编译错误处理"></a>2.1. 编译错误处理</h3><blockquote>
<p>In file included from inf-ptrace.c:27:0:<br>nat&#x2F;gdb_ptrace.h:150:19: error: ‘PTRACE_TYPE_ARG1’ was not declared in this scope<br>          ptrace ((PTRACE_TYPE_ARG1) request, pid, addr, data)</p>
</blockquote>
<p>仅给出其中一处代表性错误。进入<code>nat/gdb_ptrace.h</code>可以看到这样的语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_PTRACE_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(HAVE_SYS_PTRACE_H)</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>我的系统上是<code>sys/ptrace.h</code>，那么明显条件编译出问题了，删掉<code>#include &lt;sys/ptrace.h&gt;</code>的另外4行即可。</p>
<p>类似地，去掉<code>#ifndef HAVE_DECL_PTRACE</code>。然后包含<code>../config.h</code>头文件（因为在<code>gdb</code>目录下，而<code>gdb_ptrace.h</code>在<code>gdb/nat</code>目录下），这个头文件必须在<code>sys/ptrace.h</code>下方，因为相关地宏，因为其中定义地宏在后面地头文件中也可能用到。</p>
<p>修改后还有个错误</p>
<blockquote>
<p>inf-ptrace.c: In function ‘void inf_ptrace_interrupt(target_ops*, ptid_t)’:<br>inf-ptrace.c:304:34: error: ‘inferior_process_group’ was not declared in this scope<br>   kill (-inferior_process_group (), SIGINT);</p>
</blockquote>
<p>利用ctags找到该函数定义在<code>inflow.c</code>中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">93</span> <span class="meta">#<span class="keyword">ifdef</span> PROCESS_GROUP_TYPE</span></span><br><span class="line"> <span class="number">94</span> </span><br><span class="line"> <span class="number">95</span> <span class="comment">/* Return the process group of the current inferior.  */</span></span><br><span class="line"> <span class="number">96</span> </span><br><span class="line"> <span class="number">97</span> PROCESS_GROUP_TYPE</span><br><span class="line"> <span class="number">98</span> <span class="built_in">inferior_process_group</span> (<span class="type">void</span>)</span><br><span class="line"> <span class="number">99</span> &#123;</span><br><span class="line"><span class="number">100</span>   <span class="keyword">return</span> <span class="built_in">get_inflow_inferior_data</span> (<span class="built_in">current_inferior</span> ())-&gt;process_group;</span><br><span class="line"><span class="number">101</span> &#125;</span><br><span class="line"><span class="number">102</span> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>嗯估计又是<code>PROCESS_GROUP_TYPE</code>找不到，该类型在<code>inflow.h</code>中定义，用条件编译宏包括起来了：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">25 </span>#ifdef HAVE_TERMIOS</span><br><span class="line"><span class="symbol">26 </span># define PROCESS_GROUP_TYPE pid_t</span><br><span class="line"><span class="symbol">27 </span>#elif defined (HAVE_TERMIO) || defined (HAVE_SGTTY)</span><br><span class="line"><span class="symbol">28 </span># define PROCESS_GROUP_TYPE <span class="keyword">int</span></span><br><span class="line"><span class="symbol">29 </span>#endif </span><br></pre></td></tr></table></figure>

<p>原因是<code>HAVE_TERMIOS</code>没检测出来保。留第26行，其余4行删掉。可以看到上面包含了<code>gdb_termios.h</code>中（在<code>gdb/common</code>目录下），更根本的解决方法是在这个头文件中定义宏<code>HAVE_TERMIOS</code>。（也能解决后面其他和termios相关的问题）</p>
<p>下文就不详细给出错误信息和分析了，简单描述错误和给出解决方法。可能比较复杂，最简单的应该是在<code>def.h</code>中手动设置条件编译宏，不过反正能编译就行，我都是一个窗口make，另一个窗口根据make出错信息编辑代码。其实懂了出错原理后后自己应该也能找出更简单的解决方法。</p>
<h3 id="2-2-链接错误处理"><a href="#2-2-链接错误处理" class="headerlink" title="2.2. 链接错误处理"></a>2.2. 链接错误处理</h3><blockquote>
<p>value.c:3709: undefined reference to &#96;store_typed_floating(void*, type const*, double)’<br>collect2: error: ld returned 1 exit status</p>
</blockquote>
<p>打开<code>value.c</code>找到该函数，ctags跳转到<code>doublest.c</code>中，发现函数第3个参数是<code>DOUBLEST</code>，也就是没找到这个宏或者类型别名的定义。继续ctags跳转到<code>DOUBLEST</code>的定义位置，果然也被条件编译宏包含起来了。从错误信息看它应该是<code>double</code>的类型别名，因此保留<code>typedef double DOUBLEST;</code>的分支。</p>
<h3 id="2-3-其他编译错误处理"><a href="#2-3-其他编译错误处理" class="headerlink" title="2.3. 其他编译错误处理"></a>2.3. 其他编译错误处理</h3><p><code>ser-tcp.c</code>：</p>
<ul>
<li>去掉<code>HAVE_SYS_IOCTL_H</code>的<code>#ifdef</code>；</li>
<li>删除<code>typedef __socklen_t socklen_t</code>的代码。</li>
</ul>
<p><code>gregset.h</code>：</p>
<ul>
<li>去掉<code>#HAVE_SYS_PROCFS_H</code>的<code>#ifdef</code>块（使得<code>sys/procfs.h</code>被包含）；</li>
<li>第一处<code>grepset_t</code>改成<code>elf_gregset_t</code>；</li>
<li>第一处<code>fpregset_t</code>改成<code>elf_fpregset_t</code>（这两个类型都定义在<code>sys/procfs.h</code>中）；</li>
</ul>
<p><code>gdb_proc_service.h</code>：</p>
<ul>
<li>删除<code>lwpid_t</code>的定义；</li>
<li>包含<code>common/common-defs.h</code>；</li>
</ul>
<p><code>gdb/gdb_wait.h</code>：保留条件编译的<code>sys/wait.h</code>分支；</p>
<p><code>nat/amd64-linux-siginfo.c</code>：将<code>common-defs.h</code>作为第一个头文件；</p>
<p><code>gdb_curses.h</code>：保留条件编译的<code>curses.h</code>分支；</p>
<p>在下列C文件中包含<code>config.h</code>作为第一个头文件；</p>
<ul>
<li><code>auto-load.c</code></li>
<li><code>doublest.c</code></li>
<li><code>jit.c</code></li>
<li><code>main.c</code></li>
<li><code>top.c</code></li>
<li><code>utils.c</code></li>
</ul>
<p><code>common/signals.c</code>：</p>
<ul>
<li>去掉<code>HAVE_SIGNAL_H</code>的<code>#ifdef</code>块；</li>
<li>包含<code>sys/signal.h</code>；</li>
</ul>
<p><code>gdb-server/remote-utils.c</code>：把<code>USE_WIN32API</code>,<code>__QNX__</code>之外（其实都在它们前面定义了）的<code>#if</code>&#x2F;<code>#endif</code>块全部去掉。</p>
<p><code>gdb-server/linux-low.h</code>：</p>
<ul>
<li>删除<code>Elf_32_auxv_t</code>和<code>Elf64_auxv_t</code>的定义；</li>
<li>删除<code>HAVE_LINUX_REGSETS</code>的<code>#ifdef</code>块（有很多处）；</li>
<li>删除<code>USE_THREAD_DB</code>的<code>#ifdef</code>块；</li>
</ul>
<h2 id="3-安装后出错"><a href="#3-安装后出错" class="headerlink" title="3. 安装后出错"></a>3. 安装后出错</h2><blockquote>
<p>common&#x2F;filestuff.c:401: internal-error: int gdb_pipe_cloexec(int*): pipe not available on this host</p>
</blockquote>
<p>找到如下代码：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">385 </span>#ifdef HAVE_PIPE2</span><br><span class="line"><span class="symbol">386 </span>  result = pipe2 (filedes, O_CLOEXEC);</span><br><span class="line"><span class="symbol">387 </span>  <span class="keyword">if</span> (result != -<span class="number">1</span>)</span><br><span class="line"><span class="symbol">388 </span>    &#123;</span><br><span class="line"><span class="symbol">389 </span>      maybe_mark_cloexec (filedes[<span class="number">0</span>]);</span><br><span class="line"><span class="symbol">390 </span>      maybe_mark_cloexec (filedes[<span class="number">1</span>]);</span><br><span class="line"><span class="symbol">391 </span>    &#125;</span><br><span class="line"><span class="symbol">392 </span>#<span class="keyword">else</span></span><br><span class="line"><span class="symbol">393 </span>#ifdef HAVE_PIPE</span><br><span class="line"><span class="symbol">394 </span>  result = pipe (filedes);</span><br><span class="line"><span class="symbol">395 </span>  <span class="keyword">if</span> (result != -<span class="number">1</span>)</span><br><span class="line"><span class="symbol">396 </span>    &#123;</span><br><span class="line"><span class="symbol">397 </span>      mark_cloexec (filedes[<span class="number">0</span>]);</span><br><span class="line"><span class="symbol">398 </span>      mark_cloexec (filedes[<span class="number">1</span>]);</span><br><span class="line"><span class="symbol">399 </span>    &#125;</span><br><span class="line"><span class="symbol">400 </span>#<span class="keyword">else</span> /* HAVE_PIPE */</span><br><span class="line"><span class="symbol">401 </span>  gdb_assert_not_reached (_(<span class="string">&quot;pipe not available on this host&quot;</span>));</span><br><span class="line"><span class="symbol">402 </span>#endif /* HAVE_PIPE */</span><br><span class="line"><span class="symbol">403 </span>#endif /* HAVE_PIPE2 */</span><br></pre></td></tr></table></figure>

<p>还是条件编译宏的问题，触发了<code>gdb_assert_not_reached</code>，这里保留<code>HAVE_PIPE</code>分支就行了。重新编译安装就OK。</p>
<p>安装时会有个警告导致出错：</p>
<blockquote>
<p>gdb-8.0&#x2F;missing: line 81: makeinfo: command not found</p>
</blockquote>
<p>但是并不影响GDB的正常使用，也没必要特地安装<code>makeinfo</code>。至于环境变量和prefix这种东西，就不多讲了。</p>
<h2 id="4-启用termdebug"><a href="#4-启用termdebug" class="headerlink" title="4. 启用termdebug"></a>4. 启用termdebug</h2><p>要求vim 8.1和GDB 7.12以上，命令<code>:packadd termdebug</code>加载termdebug插件即可。然后在vim中就可启动termdebug调试程序：<code>:Termdebug &lt;your-program&gt;</code>。</p>
<p>但是默认是横向切分窗口，很不喜欢，vim中<code>:help termdebug</code>可以查看文档，默认会打开gdb窗口和程序窗口，搜索vertical就可以找到配置，只需要在<code>~/.vimrc</code>中设置如下属性即可：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g:<span class="attr">termdebug_wide</span> = <span class="number">163</span> <span class="comment"># 列宽，可调整</span></span><br></pre></td></tr></table></figure>

<p>运行效果如下：</p>
<p><img src="/2019/07/26/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-4-GDB%E5%8D%87%E7%BA%A78-0/termdebug%E7%A4%BA%E4%BE%8B.jpg" alt="termdebug示例"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/Linux-C-mktime%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%99%B7%E9%98%B1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/22/Linux-C-mktime%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%99%B7%E9%98%B1/" class="post-title-link" itemprop="url">Linux C mktime进行时间转换的陷阱</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-22 22:10:36" itemprop="dateCreated datePublished" datetime="2019-07-22T22:10:36+08:00">2019-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做的一个小程序，需要对时间戳和对应日期字符串进行相互转换，于是二话不说直接翻看<em>The Linux Programming Interface</em>(<em>TLPI</em>)查API。翻到了下面这张图：</p>
<p><img src="/2019/07/22/Linux-C-mktime%E8%BF%9B%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%99%B7%E9%98%B1/%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0.JPG" alt="时间格式转换函数"></p>
<p>我的时间戳是自epoch(UTC)以来的毫秒数表示，拟定转换的是年月日时分秒，外加个毫秒，思路就很简单：</p>
<ol>
<li>输入字符串：用<code>strptime</code>转换成<code>struct tm</code>类型，再用<code>sscanf</code>读取毫秒，最后用<code>mktime</code>将<code>tm</code>对象转换成<code>time_t</code>（自epoch(UTC)以来的秒数）乘以1000加上毫秒数；</li>
<li>输入时间戳：除以1000得到秒数，模1000得到毫秒数，然后用<code>strftime</code>将秒数格式化，再用<code>snprintf</code>将毫秒数格式化和’.’一起添加到末尾。</li>
</ol>
<p>当然，输入字符串的情况下，考虑健壮性的话需要对<code>tm</code>对象的各字段进行合法性检查，这里就不详述了。</p>
<h2 id="奇妙的BUG"><a href="#奇妙的BUG" class="headerlink" title="奇妙的BUG"></a>奇妙的BUG</h2><p>但是写完后进行测试，输入字符串，转换成时间戳，然后再转换回字符串。发现一个十分奇葩的错误，就是转换回去后比原来要少了1给小时，比如”2000-02-29 10:01:20.094”会变成”2000-02-29 09:01:20.094”，也就是说其他的功能都没错。</p>
<p>在此之前我已经考虑到了时区的问题，因此确认过<code>mktime</code>的输入参数是本地时区，因此<code>strftime</code>的输入参数需要用<code>localtime</code>而非<code>gmtime</code>。</p>
<p>为了复现这个BUG，以及描述问题的原因，可以编译运行下面这段代码（忽略了返回值检查）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;Usage: %s yyyy-mm-dd hh:mm:dd\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;before: %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">tm</span> tm_;</span><br><span class="line">  <span class="built_in">strptime</span>(argv[<span class="number">1</span>], <span class="string">&quot;%F %T&quot;</span>, &amp;tm_);</span><br><span class="line">  <span class="keyword">auto</span> dump_tm = [](<span class="type">const</span> <span class="keyword">struct</span> tm* tmp, <span class="type">const</span> <span class="type">char</span>* msg) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: %04d-%02d-%02d %02d:%02d:%02d\n&quot;</span>, msg, tmp-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">           tmp-&gt;tm_mon + <span class="number">1</span>, tmp-&gt;tm_mday, tmp-&gt;tm_hour, tmp-&gt;tm_min,</span><br><span class="line">           tmp-&gt;tm_sec);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">dump_tm</span>(&amp;tm_, <span class="string">&quot;before mktime&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> timestamp = <span class="built_in">mktime</span>(&amp;tm_);</span><br><span class="line">  <span class="built_in">dump_tm</span>(&amp;tm_, <span class="string">&quot;after mktime&quot;</span>);</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">  <span class="built_in">strftime</span>(buf, <span class="built_in">sizeof</span>(buf), <span class="string">&quot;%F %T&quot;</span>, <span class="built_in">localtime</span>(&amp;timestamp));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;after: %s\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置几个时间，运行结果如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ./a.out &quot;2001-02-28 01:00:00&quot;</span></span><br><span class="line"><span class="attribute">before</span>: <span class="number">2001</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">before</span> mktime: <span class="number">2001</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span> mktime: <span class="number">2001</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span>: <span class="number">2001</span>-<span class="number">02</span>-<span class="number">28</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># ./a.out &quot;2000-02-29 01:00:00&quot;</span></span><br><span class="line"><span class="attribute">before</span>: <span class="number">2000</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">before</span> mktime: <span class="number">2000</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span> mktime: <span class="number">2000</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span>: <span class="number">2000</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># ./a.out &quot;2004-02-29 01:00:00&quot;</span></span><br><span class="line"><span class="attribute">before</span>: <span class="number">2004</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">before</span> mktime: <span class="number">2004</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">01</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span> mktime: <span class="number">2004</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="attribute">after</span>: <span class="number">2004</span>-<span class="number">02</span>-<span class="number">29</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>可以发现中间的输入结果有误，一开始怀疑是闰年的缘故，但是2004年和2000年的结果并不相同，而它们都是闰年。此外实测发现”2000-01-29 01:00:00”也出错。</p>
<h2 id="原因及解决方法"><a href="#原因及解决方法" class="headerlink" title="原因及解决方法"></a>原因及解决方法</h2><p>其实问题的关键出在<code>struct tm</code>结构的<code>tm_idst</code>字段，可以发现无论结果是否转换错误，<code>mktime</code>始终把<code>tm_idst</code>重置为0，而调用之前<code>tm_idst</code>为非零值。</p>
<p>这个字段即DST，Daylight Saving Time。若大于0则将该时间视为夏令时，若为0则将该时间视为标准间(忽略夏令时)，若小于0则试图使用时区信息和系统数据库来确定设置。而mktime()在进行转换时会对时区进行设置，若DST未生效，则将<code>tm_idst</code>置为0，若DST生效，则会将其置为正值。</p>
<p>因此就是<strong>夏令时</strong>的问题，<a target="_blank" rel="noopener" href="https://blog.csdn.net/duyiwuer2009/article/details/42459677">struct tm中的tm_idst以及mktime</a>的测试中2001年以前的时间使用DST则会比其他情况晚1小时，当然，这个测试和我的略有出入，但我测试的2001年之后的确实也没出现这问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongzhiquan/archive/2011/11/05/2237075.html">mktime 夏令时</a>则使用了一种叫较为复杂的方法。</p>
<p>这个问题确实造成了不少人的困扰，最简单的方法就是在<code>mktime</code>之前将<code>tm_idst</code>设为-1，让系统为你解决这个问题。但实际上并非如此，比如<a target="_blank" rel="noopener" href="https://www.cnblogs.com/dongzhiquan/archive/2011/11/05/2237075.html">mktime 夏令时</a>文中就提到了：</p>
<blockquote>
<p>俄罗斯时间2008年10月26日2:30由于夏令时的跳变会经过2次，这2次所代表的日历时间明显不同。</p>
</blockquote>
<p>stackoverflow上也有讨论：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/8558919/mktime-and-tm-isdst">mktime-and-tm-isdst</a>，其中Rich Jahn也提到了即使设为-1也不代表能“自动推断是否使用夏令时：</p>
<blockquote>
<p>-1 is a possible input, but I would think of it as meaning “Unknown”. Don’t think of it as meaning “determine automatically”, because in general, mktime() can’t always determine it automatically.</p>
<p>The explicit DST status (0 or 1) should come from something external to the software, for example store it in the file or database, or prompt the user.</p>
</blockquote>
<p>最好的解决方法还是在时间后面加上UTC，比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> tm_;</span><br><span class="line"><span class="type">char</span>* p = <span class="built_in">strptime</span>(<span class="string">&quot;2004-02-29 01:00:00.039 UTC&quot;</span>, <span class="string">&quot;%F %T&quot;</span>, &amp;tm_);</span><br></pre></td></tr></table></figure>

<p>调用完毕后返回值<code>p</code>指向的是<code>&quot;.039 UTC&quot;</code>，后缀<code>UTC</code>并不影响返回值，因此仍然可以对<code>p</code>进行<code>sscanf</code>或者<code>strtol</code>操作获取毫秒数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/21/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-3-Go%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/21/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-3-Go%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/" class="post-title-link" itemprop="url">我的vim开发环境搭建(3): Go开发配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-21 00:00:49" itemprop="dateCreated datePublished" datetime="2019-06-21T00:00:49+08:00">2019-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Go的安装"><a href="#1-Go的安装" class="headerlink" title="1. Go的安装"></a>1. Go的安装</h2><p>嗯因为Go的官网被墙了所以需要自行准备梯子。Linux安装Go很简单，即使是CentOS 6，直接去<a target="_blank" rel="noopener" href="https://golang.org/dl/">golang下载页</a>下载二进制文件解压即可，比如我写这篇博客时的最新版本是1.12.6，下载解压即可：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>dl.google.com<span class="regexp">/go/g</span>o1.<span class="number">12.6</span>.linux-amd64.tar.gz</span><br><span class="line">tar zxvf go1.<span class="number">12.6</span>.linux-amd64.tar.gz -C ~<span class="regexp">/local/</span></span><br><span class="line">cd ~<span class="regexp">/local/g</span>o</span><br><span class="line">mkdir gopath</span><br></pre></td></tr></table></figure>

<p>我这里依旧是解压到<code>~/local</code>目录，另外新建了<code>gopath</code>目录。然后在<code>~/.bashrc</code>中添加环境变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$LOCAL</span>/go/bin:$PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">GOROOT</span>=<span class="variable">$LOCAL</span>/go</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">GOPATH</span>=<span class="variable">$GOROOT</span>/gopath</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">GOBIN</span>=<span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<p><code>GOROOT</code>指的是Go的安装目录，而<code>GOPATH</code>则是自定义路径，不一定要在<code>GOROOT</code>下，而且可以有多个路径，每个路径代表Go的一个工作区，一般的工作区由<code>src</code>、<code>pkg</code>、<code>bin</code>三个目录组成，比如<code>go get</code>远程下载的项目，而<code>GOBIN</code>则是安装的二进制文件的路径。</p>
<h2 id="2-重新编译YCM"><a href="#2-重新编译YCM" class="headerlink" title="2. 重新编译YCM"></a>2. 重新编译YCM</h2><p>之前安装的YCM能够对C&#x2F;C++进行补全，要对Go进行补全需要加上<code>--go-completer</code>选项重新编译，不过由于已经存放过编译的中间文件了，所以这次编译会很快。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">&quot;$LOCAL/gcc-5.4.0/bin/gcc&quot;</span> CXX=<span class="string">&quot;$LOCAL/gcc-5.4.0/bin/g++&quot;</span> <span class="string">./install.py</span>  \</span><br><span class="line">  <span class="params">--clang-completer</span> <span class="params">--system-libclang</span> <span class="params">--go-completer</span></span><br></pre></td></tr></table></figure>

<p>编译完毕后基本的补全功能已经有了，如下图所示：</p>
<p><img src="/2019/06/21/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-3-Go%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/YCM%E5%AF%B9Go%E7%9A%84%E8%A1%A5%E5%85%A8.jpg" alt="YCM对Go的补全"></p>
<p>Go的编码规范建议使用TAB而非空格表示缩进，因此之前的vim配置中<code>set expandtab</code>最好注释掉，防止把TAB扩展成空格。</p>
<p>YCM对Go的补全无需像C++一样通过<code>.ycm_extra.conf.py</code>脚本来指定头文件包含目录的，它是通过直接分析处于<code>$GOROOT/pkg</code>或<code>GOPATH/pkg</code>下的静态库<code>.a</code>文件来获取补全信息的。</p>
<p>由于Go标准库的静态库已经编译好，位于<code>$GOROOT/pkg/$GOOS_$GOARCH</code>目录下，环境变量可通过<code>go env</code>命令来查询。而对于<code>go get</code>或者<code>$GOPATH/src</code>下的项目，如果没有编译成静态库，YCM是无法补全的，因此要用到某些包时需要首先进入包所在目录<code>go install</code>。</p>
<p>如果使用了本地包比如<code>import &quot;./local&quot;</code>，那么需要把<code>local.a</code>文件拷贝到和当前<code>.go</code>文件同一目录。</p>
<h2 id="3-vim-go"><a href="#3-vim-go" class="headerlink" title="3. vim-go"></a>3. vim-go</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;fatih/vim-go&#x27;, &#123; &#x27;do&#x27;: &#x27;:GoUpdateBinaries&#x27; &#125;</span><br></pre></td></tr></table></figure>

<p>安装、使用可参考<a target="_blank" rel="noopener" href="https://github.com/fatih/vim-go">vim-go</a>的README，某些二进制文件地址被墙了，所以需要去镜像站下载。</p>
<p>然而打开.go文件时会提示</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim-go: could <span class="keyword">not</span> <span class="built_in">find</span> <span class="string">&#x27;gopls&#x27;</span>. <span class="built_in">Run</span> :GoInstallBinaries <span class="keyword">to</span> fix it</span><br></pre></td></tr></table></figure>

<p>然而用<code>:GoInstallBinaries</code>会失败，因为某些二进制文件被墙了，打开vim-go项目目录下的<code>plugin/go.vim</code>可以找到：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; these packages are used by vim-go and can be automatically installed if</span></span><br><span class="line"><span class="string">&quot;</span> needed <span class="keyword">by</span> the user <span class="keyword">with</span> GoInstallBinaries.</span><br><span class="line"><span class="keyword">let</span> s:packages = &#123;</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;asmfmt&#x27;</span>:        [<span class="string">&#x27;github.com/klauspost/asmfmt/cmd/asmfmt&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;dlv&#x27;</span>:           [<span class="string">&#x27;github.com/go-delve/delve/cmd/dlv&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;errcheck&#x27;</span>:      [<span class="string">&#x27;github.com/kisielk/errcheck&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;fillstruct&#x27;</span>:    [<span class="string">&#x27;github.com/davidrjenni/reftools/cmd/fillstruct&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gocode&#x27;</span>:        [<span class="string">&#x27;github.com/mdempsky/gocode&#x27;</span>, &#123;<span class="string">&#x27;windows&#x27;</span>: [<span class="string">&#x27;-ldflags&#x27;</span>, <span class="string">&#x27;-H=windowsgui&#x27;</span>]&#125;],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gocode-gomod&#x27;</span>:  [<span class="string">&#x27;github.com/stamblerre/gocode&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;godef&#x27;</span>:         [<span class="string">&#x27;github.com/rogpeppe/godef&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gogetdoc&#x27;</span>:      [<span class="string">&#x27;github.com/zmb3/gogetdoc&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;goimports&#x27;</span>:     [<span class="string">&#x27;golang.org/x/tools/cmd/goimports&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;golint&#x27;</span>:        [<span class="string">&#x27;golang.org/x/lint/golint&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gopls&#x27;</span>:         [<span class="string">&#x27;golang.org/x/tools/cmd/gopls&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gometalinter&#x27;</span>:  [<span class="string">&#x27;github.com/alecthomas/gometalinter&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;golangci-lint&#x27;</span>: [<span class="string">&#x27;github.com/golangci/golangci-lint/cmd/golangci-lint&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gomodifytags&#x27;</span>:  [<span class="string">&#x27;github.com/fatih/gomodifytags&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gorename&#x27;</span>:      [<span class="string">&#x27;golang.org/x/tools/cmd/gorename&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;gotags&#x27;</span>:        [<span class="string">&#x27;github.com/jstemmer/gotags&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;guru&#x27;</span>:          [<span class="string">&#x27;golang.org/x/tools/cmd/guru&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;impl&#x27;</span>:          [<span class="string">&#x27;github.com/josharian/impl&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;keyify&#x27;</span>:        [<span class="string">&#x27;honnef.co/go/tools/cmd/keyify&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;motion&#x27;</span>:        [<span class="string">&#x27;github.com/fatih/motion&#x27;</span>],</span><br><span class="line">      <span class="string">\</span> <span class="string">&#x27;iferr&#x27;</span>:         [<span class="string">&#x27;github.com/koron/iferr&#x27;</span>],</span><br><span class="line"><span class="string">\</span> &#125;</span><br></pre></td></tr></table></figure>

<p>如注释所言，<code>:GoInstallBinaries</code>实际上是把这些二进制文件安装到本地，由于<code>golang.org</code>被墙了，所以相关工具无法下载。即使是github上的项目，克隆速度也慢得感人，所以还是手动下载安装。</p>
<h3 id="3-1-手动安装二进制文件"><a href="#3-1-手动安装二进制文件" class="headerlink" title="3.1 手动安装二进制文件"></a>3.1 手动安装二进制文件</h3><p>以<code>fillstruct</code>为例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$GOPATH</span><span class="regexp">/src/gi</span>thub.com/davidrjenni</span><br><span class="line">cd <span class="variable">$GOPATH</span><span class="regexp">/src/gi</span>thub.com/davidrjenni</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/davidrjenni/</span>reftools.git </span><br><span class="line">cd reftools<span class="regexp">/cmd/</span>fillstruct</span><br><span class="line">go install</span><br></pre></td></tr></table></figure>

<p>注意<code>go.vim</code>中的<code>cmd/fillstruct</code>后缀指的是克隆的项目的子目录，因此流程是先克隆项目本身，再进入相应子目录安装。<code>go install</code>安装完后会发现<code>$GOPATH/bin</code>下多了二进制文件<code>fillstruct</code>。</p>
<p>实际上上述流程是手动进行了<code>go get</code>的流程，但是能够判断出错到底是<code>git clone</code>还是<code>go install</code>，前者出错可能就是访问太慢甚至无法访问，后者则是可能项目里引用了未安装的包。</p>
<h3 id="3-2-安装依赖包"><a href="#3-2-安装依赖包" class="headerlink" title="3.2 安装依赖包"></a>3.2 安装依赖包</h3><p>并非所有项目都像<code>fillstruct</code>那么顺利，比如在安装<code>errcheck</code>时就提示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go install</span><br><span class="line">internal<span class="regexp">/errcheck/</span>errcheck.go:<span class="number">19</span>:<span class="number">2</span>: cannot <span class="keyword">find</span> <span class="keyword">package</span> <span class="string">&quot;golang.org/x/tools/go/packages&quot;</span> in <span class="keyword">any</span> of:</span><br><span class="line">    <span class="regexp">/home/</span>xyz<span class="regexp">/local/g</span>o<span class="regexp">/src/g</span>olang.org<span class="regexp">/x/</span>tools<span class="regexp">/go/</span>packages (<span class="keyword">from</span> $GOROOT)</span><br><span class="line">    <span class="regexp">/home/</span>xyz<span class="regexp">/local/g</span>o<span class="regexp">/gopath/</span>src<span class="regexp">/golang.org/</span>x<span class="regexp">/tools/g</span>o/packages (<span class="keyword">from</span> $GOPATH)</span><br></pre></td></tr></table></figure>

<p>其中<code>/home/xyz</code>是我的HOME目录，出现这个错误就是因为<code>&quot;golang.org/x/tools/go/packages&quot;</code>包没有安装，而由于<code>golang.org</code>被墙了，<code>go get</code>安装会失败，不过好在可以从<a target="_blank" rel="noopener" href="https://github.com/golang">golang的github镜像站</a>去找到对应的项目，然后下载安装，以此为例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable">$GOPATH</span></span><br><span class="line">mkdir -p src<span class="regexp">/golang.org/</span>x</span><br><span class="line">cd src<span class="regexp">/golang.org/</span>x</span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/golang/</span>tools.git</span><br></pre></td></tr></table></figure>

<p>然后再重新在<code>errcheck</code>目录下<code>go install</code>即可。</p>
<h3 id="3-3-特别操作"><a href="#3-3-特别操作" class="headerlink" title="3.3 特别操作"></a>3.3 特别操作</h3><ol>
<li><code>stamblerre/gocode</code>，由于生成的是<code>gocode-gomod</code>而非默认的<code>gocode</code>，因此需要指定二进制名称（似乎<code>go install</code>无法做到）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -o gocode-gomod</span><br><span class="line"><span class="built_in">mv</span> gocode-gomod <span class="variable">$GOPATH</span>/bin</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>honnef.co/go/tools/cmd/keyify</code>，在github上有<a target="_blank" rel="noopener" href="https://github.com/dominikh/go-tools">镜像</a>：</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> $GOPATH/src</span><br><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> honnef.<span class="keyword">co</span>/<span class="keyword">go</span></span><br><span class="line">git clone https://github.<span class="keyword">com</span>/dominikh/<span class="keyword">go</span>-tools.git honnef.<span class="keyword">co</span>/<span class="keyword">go</span>/tools</span><br><span class="line"><span class="keyword">cd</span> honnef.<span class="keyword">co</span>/<span class="keyword">go</span>/tools/cmd/keyify</span><br><span class="line"><span class="keyword">go</span> install</span><br></pre></td></tr></table></figure>

<h3 id="3-4-最终安装结果"><a href="#3-4-最终安装结果" class="headerlink" title="3.4 最终安装结果"></a>3.4 最终安装结果</h3><p>安装的二进制文件如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">ls</span> <span class="variable">$GOBIN</span></span><br><span class="line">asmfmt    fillstruct    godef      golangci<span class="literal">-lint</span>  gomodifytags  gotags  impl</span><br><span class="line">dlv       gocode        gogetdoc   golint         gopls         guru    keyify</span><br><span class="line">errcheck  gocode<span class="literal">-gomod</span>  goimports  gometalinter   gorename      iferr   motion</span><br></pre></td></tr></table></figure>

<p>从golang的github镜像上分别克隆了3个项目：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> <span class="variable">$GOPATH</span>/src/golang.org/x</span><br><span class="line">lint  <span class="built_in">sync</span>  tools</span><br></pre></td></tr></table></figure>

<h3 id="3-5-其他说明"><a href="#3-5-其他说明" class="headerlink" title="3.5 其他说明"></a>3.5 其他说明</h3><p>vim-go的具体使用方式，参考<a target="_blank" rel="noopener" href="https://github.com/fatih/vim-go/wiki/Tutorial">vim-go Tutorial</a>。</p>
<p>打开go文件时会出现下列错误</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">vim</span><span class="literal">-</span><span class="comment">go: Features that rely on gopls will not work correctly in a null</span> <span class="comment">module</span><span class="string">.</span></span><br></pre></td></tr></table></figure>

<p>解决方法参考<a target="_blank" rel="noopener" href="https://github.com/fatih/vim-go/issues/2301">#2301</a>，在<code>.vimrc</code>中添加下列代码即可：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> g:<span class="attr">go_null_module_warning</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>此外<code>GoRename</code>命令只有在项目目录在<code>$GOPATH/src</code>下时才能使用，否则会出现<code>can&#39;t find package containing</code>错误。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>由于是在之前的基础上进行，所以Go开发环境的搭建较为简单，安装Go、重新编译YCM，Ultisnip已经有了，剩下的就是vim-go的安装了。其实最重要的还是YCM的补全功能。</p>
<p>虽然我vim-go用得也不多，主要就是用了下将gofmt集成进vim的<code>:GoFmt</code>命令，毕竟上手Go的时间也不长。话说才发现现在保存文件时就会自动格式化了，无需手动输入<code>:GoFmt</code>命令。</p>
<p>安装vim-go的主要难点在于各种远程包，在我的电脑上几乎是全程开代理下载，有时候git代理不太好使就直接在VPS上克隆完毕后，打包、FTP下载、FTP上传、解压。</p>
<p>之前实习时安装vim-go去解决各种<code>go get</code>的问题了，<code>go get</code>虽然方便，但是出错的话难以及时发现错误在哪，感觉在国内这个网络环境下，还不如手动克隆、安装。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/19/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2-%E5%B8%B8%E7%94%A8%E7%9A%84vim%E6%8F%92%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/19/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2-%E5%B8%B8%E7%94%A8%E7%9A%84vim%E6%8F%92%E4%BB%B6/" class="post-title-link" itemprop="url">我的vim开发环境搭建(2): 常用的vim插件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-19 16:19:34" itemprop="dateCreated datePublished" datetime="2019-06-19T16:19:34+08:00">2019-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-NERDTree"><a href="#1-NERDTree" class="headerlink" title="1. NERDTree"></a>1. NERDTree</h2><p>在<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/06/06/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">前文</a>中，我主要讲了一堆软件的升级，其主要原因是为了支持YouCompleteMe这个安装起来超级复杂的插件，其余的插件安装很简单，有了vim-plug后，只需要2步，以NERDTree（目录树）为例</p>
<p>第1步，在<code>.vimrc</code>中添加插件项目地址，然后在vim中执行<code>:PlugInstall</code>命令（也可以直接克隆到<code>plug#begin</code>指定的目录，这点前文已经讲过）：</p>
<figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call plug<span class="function"><span class="keyword">#</span><span class="title">begin</span><span class="params">(&#x27;~/.<span class="variable">vim</span>/<span class="variable">plugged</span>&#x27;)</span></span></span><br><span class="line"></span><br><span class="line">&quot; NERDTree插件的github网址（不包含前缀https://github.com/）</span><br><span class="line">Plug &#x27;scrooloose/nerdtree&#x27;</span><br><span class="line">&quot; 其他插件</span><br><span class="line">&quot; ...</span><br><span class="line"></span><br><span class="line">call plug<span class="function"><span class="keyword">#</span><span class="title">end</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>第2步，添加插件相关的配置脚本，可以参考插件项目的README：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;Leader&gt;</span><span class="symbol">&lt;Leader&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeWinSize=<span class="number">32</span>          <span class="comment">&quot; 设置NERDTree子窗口宽度</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeWinPos=<span class="string">&quot;right&quot;</span>      <span class="comment">&quot; 设置NERDTree子窗口位置</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeShowHidden=<span class="number">1</span>        <span class="comment">&quot; 显示隐藏文件</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeMinimalUI=<span class="number">1</span>         <span class="comment">&quot; NERDTree 子窗口中不显示冗余帮助信息</span></span><br></pre></td></tr></table></figure>

<p>前文配置过<code>&lt;Leader&gt;</code>即分号（;）的代码，<code>nmap</code>这句就是配置快捷键，也就是连按2个;就等价于执行<code>:NERDTreeToggle</code>命令，打开树形目录，如下图所示：</p>
<p><img src="/2019/06/19/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2-%E5%B8%B8%E7%94%A8%E7%9A%84vim%E6%8F%92%E4%BB%B6/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95.jpg" alt="树形目录"></p>
<p>后面的则是插件的配置，在注释中也给出了。使用方式可以参考项目的README，vim可以通过<code>Ctrl+W+上/下/左/右</code>在不同切分窗口中切换，当光标在树形目录中时可以用上下键移动：</p>
<table>
<thead>
<tr>
<th align="left">按键</th>
<th align="left">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Enter</td>
<td align="left">如果光标所在行是目录，展开当前目录，否则直接打开该文件</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">纵向切分窗口中打开光标所在行对应文件，等价于<code>:split &lt;filename&gt;</code></td>
</tr>
<tr>
<td align="left">i</td>
<td align="left">横向切分窗口中打开光标所在行对应文件，等价于<code>:vsplit &lt;filename&gt;</code></td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">更新树形目录</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">将根目录退回到上一层</td>
</tr>
<tr>
<td align="left">C</td>
<td align="left">将根目录变回光标所在行对应目录</td>
</tr>
</tbody></table>
<h2 id="2-YouCompleteMe"><a href="#2-YouCompleteMe" class="headerlink" title="2. YouCompleteMe"></a>2. YouCompleteMe</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;Valloric/YouCompleteMe&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Valloric/YouCompleteMe">YouCompleteMe</a>（简称YCM）可谓是vim环境下C&#x2F;C++补全的标配了，不同于其他插件，YCM非常重量级，200多M，而且它对vim版本要求比较高，还要求vim支持python，最后还需要用clang来编译，因此前文做的大量工作都是为这个插件准备的。对于较新的Linux系统，手动编译完高版本的vim后，直接调用<code>./install.sh --clang-completer</code>就行，它会自动下载新版本的clang，但是对CentOS 6.10行不通，因此之前我手动编译了高版本的clang。</p>
<p>虽然我也找过替代品，但亲自尝试的结果是，现阶段补全C&#x2F;C++确实没有比YCM体验更好的。</p>
<h3 id="2-1-YCM的安装"><a href="#2-1-YCM的安装" class="headerlink" title="2.1 YCM的安装"></a>2.1 YCM的安装</h3><p>之前说过YCM比较大，考虑到国内访问github速度之慢，使用vim-plug安装不如手动克隆，而且这个项目有不少子模块，因此需要<code>git submodule</code>，命令如下所示（注意要先进入<code>~/.vim/plugged</code>目录）：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/Valloric/</span>YouCompleteMe.git</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<p>可以借助代理来加速，不过我是直接下载完毕后将整个目录压缩打包保存起来，下次安装直接上传解压即可。</p>
<p>YCM的安装是利用python脚本完成的，不过安装时可能会提示python缺少某些模块。那是因为之前编译python时没有安装依赖项，参考<a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2019/06/06/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/">前文</a>的2.1节。安装依赖项后重新编译python即可。</p>
<p>进入YouCompleteMe目录，使用本地的gcc、g++、cmake、clang来安装：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CC</span>=<span class="string">&quot;<span class="variable">$LOCAL</span>/gcc-5.4.0/bin/gcc&quot;</span> <span class="attribute">CXX</span>=<span class="string">&quot;<span class="variable">$LOCAL</span>/gcc-5.4.0/bin/g++&quot;</span> ./install.py \</span><br><span class="line">  --clang-completer --system-libclang</span><br></pre></td></tr></table></figure>

<p>最终会在<code>third_party/ycmd</code>目录下生成<code>ycm_core.so</code>。</p>
<h3 id="2-2-YCM的配置"><a href="#2-2-YCM的配置" class="headerlink" title="2.2 YCM的配置"></a>2.2 YCM的配置</h3><p>在<code>.vimrc</code>文件中添加如下内容：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> YCM配置</span><br><span class="line"><span class="comment">&quot; 全局YCM配置文件路径</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_global_ycm_extra_conf</span> = <span class="string">&#x27;~/.ycm_extra_conf.py&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_confirm_extra_conf</span> = <span class="number">0</span>  <span class="comment">&quot; 不提示是否载入本地ycm_extra_conf文件</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_min_num_of_chars_for_completion</span> = <span class="number">2</span>  <span class="comment">&quot; 输入第2个字符就罗列匹配项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; Ctrl+J跳转至定义、声明或文件</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;c-j&gt;</span> :YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span>|</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 语法关键字、注释、字符串补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_seed_identifiers_with_syntax</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_comments</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_complete_in_strings</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; 从注释、字符串、tag文件中收集用于补全信息</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_comments_and_strings</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_collect_identifiers_from_tags_files</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 禁止快捷键触发补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_invoke_completion</span> = <span class="string">&#x27;&lt;c-z&gt;&#x27;</span>  <span class="comment">&quot; 主动补全(默认&lt;c-space&gt;)</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;c-z&gt;</span> <span class="symbol">&lt;NOP&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 输入2个字符就触发补全</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_semantic_triggers</span> = &#123;</span><br><span class="line">            \ <span class="string">&#x27;c,cpp,python,java,go,erlang,perl&#x27;</span>: [<span class="string">&#x27;re!\w&#123;2&#125;&#x27;</span>],</span><br><span class="line">            \ <span class="string">&#x27;cs,lua,javascript&#x27;</span>: [<span class="string">&#x27;re!\w&#123;2&#125;&#x27;</span>],</span><br><span class="line">            \ &#125;</span><br><span class="line">                                    </span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_show_diagnostics_ui</span> = <span class="number">0</span>  <span class="comment">&quot; 禁用YCM自带语法检查(使用ale)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 防止YCM和Ultisnips的TAB键冲突，禁止YCM的TAB</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_select_completion</span> = [<span class="string">&#x27;&lt;C-n&gt;&#x27;</span>, <span class="string">&#x27;&lt;Down&gt;&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_key_list_previous_completion</span> = [<span class="string">&#x27;&lt;C-p&gt;&#x27;</span>, <span class="string">&#x27;&lt;Up&gt;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>输入2个字符即可触发补全操作，对C++而言，输入<code>.</code>、<code>::</code>、<code>-&gt;</code>也会触发补全操作。</p>
<p>除了补全，YCM本身也含有跳转功能，这里设置快捷键为Ctrl+J。但是目前似乎还不太完善，比如有时候只能跳转到声明无法跳转到定义。这些功能可能还需要借助ctags、cscope来辅助。</p>
<p>YCM对C&#x2F;C++的补全、跳转是基于<code>.ycm_extra_conf.py</code>文件的，比如指定语言种类、标准、头文件目录、编译选项，其中编译选项是用来实现语法检查的，这里禁止了YCM自身的语法检查，使用后文将介绍的ALE插件来完成。其配置参考我的博客：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5aaae8f036c1">为YCM配置ycm_extra_conf脚本</a></p>
<p>CentOS配置比较简单，C头文件都在<code>/usr/include</code>下，C++头文件则在自己安装的gcc目录下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;-isystem&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;/usr/include&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-isystem&#x27;</span>,</span><br><span class="line">os<span class="selector-class">.environ</span><span class="selector-attr">[<span class="string">&#x27;HOME&#x27;</span>]</span> + <span class="string">&#x27;/local/gcc-5.4.0/include/c++/5.4.0&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;-isystem&#x27;</span>,</span><br><span class="line">os<span class="selector-class">.environ</span><span class="selector-attr">[<span class="string">&#x27;HOME&#x27;</span>]</span> + <span class="string">&#x27;/local/gcc-5.4.0/include/c++/5.4.0/x86_64-unknown-linux-gnu&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是<code>x86_64-unknown-linux-gnu</code>目录必须添加进去，否则会导致C++标准库无法补全，因为C++标准库头文件包含了该目录下的各种头文件，比如<code>thread</code>包含的3个头文件：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/functexcept.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/functional_hash.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/gthr.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>其中前2个都是出自<code>$GCC_DIR/include/c++/5.4.0/bits</code>目录，而第3个则是出自<code>$GCC_DIR/include/c++/5.4.0/x86_64-unknown-linux-gnu/bits</code>目录，因此必须把这个目录添加进去，否则头文件会解析失败。</p>
<h2 id="3-ale静态语法检查"><a href="#3-ale静态语法检查" class="headerlink" title="3 ale静态语法检查"></a>3 ale静态语法检查</h2><h3 id="3-1-ale的安装和配置"><a href="#3-1-ale的安装和配置" class="headerlink" title="3.1 ale的安装和配置"></a>3.1 ale的安装和配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;w0rp/ale&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其配置如下：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> ale</span><br><span class="line"><span class="keyword">let</span> g:ale_linters = &#123;</span><br><span class="line">            <span class="string">\</span> <span class="string">&#x27;c&#x27;</span>: [<span class="string">&#x27;gcc&#x27;</span>, <span class="string">&#x27;cppcheck&#x27;</span>],</span><br><span class="line">            <span class="string">\</span> <span class="string">&#x27;cpp&#x27;</span>: [<span class="string">&#x27;g++&#x27;</span>, <span class="string">&#x27;cppcheck&#x27;</span>],</span><br><span class="line">            <span class="string">\</span> &#125;</span><br><span class="line"><span class="keyword">let</span> g:ale_c_gcc_options = <span class="string">&#x27;-Wall -O2 -std=c99</span></span><br><span class="line"><span class="string">            \ -I .</span></span><br><span class="line"><span class="string">            \ -I /usr/include&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g:ale_cpp_gcc_options = <span class="string">&#x27;-Wall -O2 -std=c++11</span></span><br><span class="line"><span class="string">            \ -I .</span></span><br><span class="line"><span class="string">            \ -I /usr/include</span></span><br><span class="line"><span class="string">            \ -I $HOME/local/gcc-5.4.0/include/c++/5.4.0&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g:ale_c_cppcheck_options = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> g:ale_cpp_cppcheck_options = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g:ale_linters_explicit = <span class="number">1</span>  <span class="string">&quot; 只显示运行ale_linters的文件</span></span><br><span class="line"><span class="string">let g:ale_completion_delay = 500</span></span><br><span class="line"><span class="string">let g:ale_echo_delay = 20</span></span><br><span class="line"><span class="string">let g:ale_lint_delay = 500</span></span><br><span class="line"><span class="string">let g:ale_echo_msg_format = &#x27;[%linter%] %code: %%s&#x27;</span></span><br><span class="line"><span class="string">let g:ale_lint_on_text_changed = &#x27;normal&#x27;  &quot;</span> 防止YCM不停补全</span><br><span class="line"><span class="keyword">let</span> g:ale_lint_on_insert_leave = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>主要有用的是前面5个，后面照搬即可。<code>ale_c_gcc_options</code>和<code>ale_cpp_gcc_options</code>指定使用gcc&#x2F;g++进行静态语法检查时的选项，和编译时的选项相同，类似YCM的<code>.ycm_extra_conf.py</code>，但是必须在<code>.vimrc</code>中配置而不能作为项目独立的配置文件。</p>
<p>另外，除了gcc&#x2F;g++外，ale还使用了cppcheck进行语法检查，它能够检查出一些未定义的行为，比如没有<code>fclose</code>关闭打开的<code>FILE</code>指针。从源安装的cppcheck版本较老，不支持C++11的语法，因此去下载<a target="_blank" rel="noopener" href="http://cppcheck.sourceforge.net/">cppcheck源码</a>手动编译。</p>
<h3 id="3-2-安装cppcheck"><a href="#3-2-安装cppcheck" class="headerlink" title="3.2 安装cppcheck"></a>3.2 安装cppcheck</h3><p>要支持<code>HAVE_RULES</code>，需要安装<a target="_blank" rel="noopener" href="https://www.pcre.org/">pcre</a>，下载源码解压后，手动<code>./configure --prefix=&lt;dirname&gt;</code>、<code>make</code>、<code>make install</code>安装，然后在<code>~/.bashrc</code>中添加如下代码以指定gcc的包含路径和库路径：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">C_INCLUDE_PATH</span>=<span class="variable">$LOCAL</span>/pcre/include:$C_INCLUDE_PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">CPLUS_INCLUDE_PATH</span>=<span class="variable">$LOCAL</span>/pcre/include:$CPLUS_INCLUDE_PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">LD_LIBRARY_PATH</span>=<span class="variable">$LOCAL</span>/pcre/lib:$LD_LIBRARY_PATH</span><br><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$LOCAL</span>/pcre/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>然后进入cppcheck源码目录按照如下方式编译：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make <span class="attribute">SRCDIR</span>=build <span class="attribute">CFGDIR</span>=<span class="variable">$LOCAL</span>/bin/cfg <span class="attribute">HAVE_RULES</span>=<span class="literal">yes</span></span><br><span class="line">make install <span class="attribute">PREFIX</span>=<span class="variable">$LOCAL</span> <span class="attribute">CFGDIR</span>=<span class="variable">$LOCAL</span>/bin/cfg</span><br></pre></td></tr></table></figure>

<p>然后将<code>$LOCAL/bin</code>添加到<code>.bashrc</code>的环境变量中：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> <span class="attribute">PATH</span>=<span class="variable">$LOCAL</span>/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>之后ale便可使用cppcheck进行语法检查，比如C++11语法下的资源泄漏检查：</p>
<p><img src="/2019/06/19/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2-%E5%B8%B8%E7%94%A8%E7%9A%84vim%E6%8F%92%E4%BB%B6/ale%E6%A3%80%E6%9F%A5%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F.jpg" alt="ale检查资源泄漏"></p>
<p>除此之外还有其他功能，可参考<a target="_blank" rel="noopener" href="http://cppcheck.sourceforge.net/">cppcheck官网</a>的Undefined behaviour一栏。</p>
<h2 id="4-其他插件"><a href="#4-其他插件" class="headerlink" title="4. 其他插件"></a>4. 其他插件</h2><p>其实最重要的补全、跳转插件都有了，其余的插件我也没详细研究，但也都配置了，使用开箱即用的功能，没有特别定制。</p>
<h3 id="4-1-Ultisnips"><a href="#4-1-Ultisnips" class="headerlink" title="4.1 Ultisnips"></a>4.1 Ultisnips</h3><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;SirVer</span>/ultisnips&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;honza</span>/vim-snippets&#x27;</span><br></pre></td></tr></table></figure>

<p>很多IDE都有自动生成代码的功能，比如输入main然后按回车或TAB键会自动生成main函数的模板代码，输入for按回车生成可供选择的多种for循环的模板代码。这里第1个插件提供了代码生成的功能，第2个插件则提供了各自语言的模板代码。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; Do not use &lt;tab&gt; if you use YouCompleteMe</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsExpandTrigger</span>=<span class="string">&quot;&lt;tab&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpForwardTrigger</span>=<span class="string">&quot;&lt;c-b&gt;&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsJumpBackwardTrigger</span>=<span class="string">&quot;&lt;c-z&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; If you want :UltiSnipsEdit to split your window.</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:UltiSnipsEditSplit</span>=<span class="string">&quot;vertical&quot;</span></span><br></pre></td></tr></table></figure>

<p>暂时我还只停留在简单地使用现成模板上，比如<code>cl</code>生成类，<code>ns</code>生成命名空间，<code>main</code>生成main函数，当然，这些都会用TAB键触发，因此之前YCM的配置中禁止了TAB补全防止与其冲突。</p>
<p>C++的snippets在<code>~/.vim/plugged/vim-snippets/snippets/cpp.snippets</code>文件定义，可以照着修改该文件来修改代码生成模板。</p>
<h3 id="4-2-vim-clang-format"><a href="#4-2-vim-clang-format" class="headerlink" title="4.2 vim-clang-format"></a>4.2 vim-clang-format</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;rhysd/vim-clang-format&#x27;</span></span><br></pre></td></tr></table></figure>

<p>之前安装llvm中自带了<code>clang-format</code>，<code>vim-clang-format</code>是对它的集成。无需配置，安装好后，vim命令模式下<code>:ClangFormat</code>便可对当前文件自动格式化。当然也可以<code>nmap</code>设置快捷键，不过我也习惯了输入<code>:Cl</code>+TAB键格式化当前代码。</p>
<p>代码格式化首先需要<code>clang-format</code>路径在环境变量<code>PATH</code>中（之前安装clang时已经配置过），然后从当前目录往上寻找<code>.clang-format</code>文件，我是直接用谷歌开源代码风格，比如我生成该文件在HOME目录下，命令如下：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang-format <span class="params">--style=Google</span> <span class="params">--dump-config</span> &gt;~<span class="string">/.clang-format</span></span><br></pre></td></tr></table></figure>

<p>如果需要定制代码格式化文件，只需修改<code>.clang-format</code>即可，网上有各种资料。</p>
<h3 id="4-3-C-头文件、源文件切换"><a href="#4-3-C-头文件、源文件切换" class="headerlink" title="4.3 C++头文件、源文件切换"></a>4.3 C++头文件、源文件切换</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;vim-scripts/a.vim&#x27;</span></span><br></pre></td></tr></table></figure>

<p>开箱即用，据说是很早的插件了，<code>:A</code>命令切换头文件和源文件，比如<code>xxx.h</code>和<code>xxx.cc</code>。<code>:AV</code>和<code>:AS</code>命令则是打开竖直、水平切分窗口来切换头文件和源文件。</p>
<h3 id="4-4-asyncrun"><a href="#4-4-asyncrun" class="headerlink" title="4.4 asyncrun"></a>4.4 asyncrun</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;skywind<span class="number">3000</span>/asyncrun.vim&#x27;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.skywind.me/blog/">skywind</a>大佬（知乎账号为<em>韦易笑</em>，vim大神)写的插件，我的vim配置也大部分是参考他的<a target="_blank" rel="noopener" href="http://www.skywind.me/blog/archives/2084">Vim 8下C&#x2F;C++开发环境搭建</a>。这里也基本照搬配置了，使用说明可参考他的博客：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; 自动打开 quickfix window ，高度为 6</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:asyncrun_open</span> = <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 任务结束时候响铃提醒</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:asyncrun_bell</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 设置 F10 打开/关闭 Quickfix 窗口</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;F10&gt;</span> :<span class="keyword">call</span> asyncrun#quickfix_toggle(<span class="number">6</span>)<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 设置 F9 编译单个文件</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;F9&gt;</span> :AsyncRun g++ -std=<span class="keyword">c</span>++<span class="number">11</span> -Wall -O2 <span class="string">&quot;$(VIM_FILEPATH)&quot;</span> -<span class="keyword">o</span> <span class="string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span> <span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 递归查找包含该目录的目录作为根目录，若找不到则将文件所在目录作为当前目录</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:asyncrun_rootmarks</span> = [<span class="string">&#x27;.svn&#x27;</span>, <span class="string">&#x27;.git&#x27;</span>, <span class="string">&#x27;.root&#x27;</span>, <span class="string">&#x27;_darcs&#x27;</span>, <span class="string">&#x27;build.xml&#x27;</span>] </span><br><span class="line"><span class="comment">&quot; 设置 F7 编译项目</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;F7&gt;</span> :AsyncRun -cwd=<span class="symbol">&lt;root&gt;</span> <span class="keyword">make</span> <span class="symbol">&lt;cr&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 设置 F5 运行当前程序</span></span><br><span class="line"><span class="string">&quot;nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun -raw -cwd=$(VIM_FILEDIR) &quot;</span>$(VIM_FILEDIR)/$(VIM_FILENOEXT)<span class="comment">&quot; &lt;cr&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;F5&gt;</span> :AsyncRun g++ -std=<span class="keyword">c</span>++<span class="number">11</span> -Wall <span class="string">&quot;$(VIM_FILEPATH)&quot;</span> &amp;&amp; ./<span class="keyword">a</span>.out <span class="symbol">&lt;cr&gt;</span><span class="comment">&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于vim 8才支持了异步执行终端命令，因此该插件需要vim版本至少为8。我的vim版本为8.1，还可以直接在vim中横向打开终端窗口（命令为<code>terminal</code>，默认横向打开，<code>vert term</code>纵向打开）。</p>
<h3 id="4-5-LeaderF"><a href="#4-5-LeaderF" class="headerlink" title="4.5 LeaderF"></a>4.5 LeaderF</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;Yggdroot/LeaderF&#x27;</span></span><br></pre></td></tr></table></figure>

<p>其配置照抄了skywind的</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> LeaderF</span><br><span class="line"><span class="comment">&quot; Ctrl+P在当前项目目录打开文件搜索, Ctrl+N打开MRU搜索，搜索最近打开的文件</span></span><br><span class="line"><span class="comment">&quot; Alt+P打开函数搜索，Alt+N打开Buffer搜索</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutF</span> = <span class="string">&#x27;&lt;c-p&gt;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShortcutB</span> = <span class="string">&#x27;&lt;m-n&gt;&#x27;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;c-n&gt;</span> :LeaderfMru<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;m-p&gt;</span> :LeaderfFunction!<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;m-n&gt;</span> :LeaderfBuffer<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;m-m&gt;</span> :LeaderfTag<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_StlSeparator</span> = &#123; <span class="string">&#x27;left&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;right&#x27;</span>: <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;font&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_RootMarkers</span> = [<span class="string">&#x27;.project&#x27;</span>, <span class="string">&#x27;.root&#x27;</span>, <span class="string">&#x27;.svn&#x27;</span>, <span class="string">&#x27;.git&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WorkingDirectoryMode</span> = <span class="string">&#x27;Ac&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_WindowHeight</span> = <span class="number">0.30</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_CacheDirectory</span> = <span class="built_in">expand</span>(<span class="string">&#x27;~/.vim/cache&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_ShowRelativePath</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_HideHelp</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_StlColorscheme</span> = <span class="string">&#x27;powerline&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:Lf_PreviewResult</span> = &#123;<span class="string">&#x27;Function&#x27;</span>:<span class="number">0</span>, <span class="string">&#x27;BufTag&#x27;</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>各种<code>Leaderf</code>开头的命令，可以<code>:LeaderfFunction</code>查找函数、<code>:LeaderfFile</code>查找文件，等等。我用得不是很多，所以配置基本上也没用。</p>
<h3 id="4-6-vim-signify"><a href="#4-6-vim-signify" class="headerlink" title="4.6 vim-signify"></a>4.6 vim-signify</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Plug</span> <span class="string">&#x27;mhinz/vim-signify&#x27;</span></span><br></pre></td></tr></table></figure>

<p>配置仅需</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="attribute">signcolumn</span>=<span class="literal">yes</span>  <span class="string">&quot; 强制显示侧边栏，防止时有时无</span></span><br></pre></td></tr></table></figure>

<p>可以实时显示git项目的修改状态，如下图所示：</p>
<p><img src="/2019/06/19/%E6%88%91%E7%9A%84vim%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2-%E5%B8%B8%E7%94%A8%E7%9A%84vim%E6%8F%92%E4%BB%B6/signify%E6%98%BE%E7%A4%BAgit%E9%A1%B9%E7%9B%AE%E4%BF%AE%E6%94%B9%E6%83%85%E5%86%B5.jpg" alt="signify显示git项目修改情况"></p>
<h3 id="4-7-vim页面美化插件"><a href="#4-7-vim页面美化插件" class="headerlink" title="4.7 vim页面美化插件"></a>4.7 vim页面美化插件</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Plug &#x27;sickill/vim-monokai&#x27;               <span class="string">&quot; monokai主题</span></span><br><span class="line">Plug &#x27;vim-airline/vim-airline&#x27;           <span class="string">&quot; 美化状态栏</span></span><br><span class="line">Plug &#x27;vim-airline/vim-airline-themes&#x27;</span><br><span class="line">Plug &#x27;plasticboy/vim-markdown&#x27;           <span class="string">&quot; markdown高亮</span></span><br><span class="line">Plug &#x27;octol/vim-cpp-enhanced-highlight&#x27;  <span class="string">&quot; C++代码高亮</span></span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span> airline</span><br><span class="line"><span class="keyword">let</span> laststatus = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_powerline_fonts</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_theme</span> = <span class="string">&quot;dark&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#enabled = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> <span class="keyword">vim</span>-monokai</span><br><span class="line"><span class="keyword">colorscheme</span> monokai</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> <span class="keyword">vim</span>-markdown</span><br><span class="line"><span class="comment">&quot; Github风格markdown语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:vim_markdown_no_extensions_in_markdown</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span> <span class="keyword">vim</span>-cpp-enhanced-<span class="keyword">highlight</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_scope_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_member_variable_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_class_decl_highlight</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:cpp_experimental_template_highlight</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="5-我自己写的简单代码模板"><a href="#5-我自己写的简单代码模板" class="headerlink" title="5. 我自己写的简单代码模板"></a>5. 我自己写的简单代码模板</h2><p>之前简单学了下vimscripts，简单写了点代码模板，即新建<code>.h</code>、<code>.c</code>、<code>.cc</code>、<code>.cpp</code>文件会自动生成相应代码。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; 代码模板</span></span><br><span class="line"><span class="keyword">autocmd</span> BufNewFile *.<span class="keyword">cc</span>,*.cpp,*.<span class="keyword">c</span> exec <span class="string">&quot;:call SetTitle()&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title">SetTitle</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">1</span>, <span class="string">&quot;#include &lt;iostream&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">2</span>, <span class="string">&quot;using namespace std;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">3</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">4</span>, <span class="string">&quot;int main(int argc, char* argv[]) &#123;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">5</span>, <span class="string">&quot;  return 0;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">6</span>, <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="keyword">if</span> &amp;<span class="keyword">filetype</span> == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">1</span>, <span class="string">&quot;#include &lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">2</span>, <span class="string">&quot;#include &lt;stdlib.h&gt;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">3</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">4</span>, <span class="string">&quot;int main(int argc, char* argv[]) &#123;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">5</span>, <span class="string">&quot;  return 0;&quot;</span>)</span><br><span class="line">        <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">6</span>, <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">endif</span></span><br><span class="line">    <span class="comment">&quot; 新建文件后自动定位到文件末尾</span></span><br><span class="line">    <span class="keyword">autocmd</span> BufNewFile * <span class="keyword">normal</span> G</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">autocmd</span> BufNewFile *.h exec <span class="string">&quot;:call SetTitleForH()&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title">SetTitleForH</span><span class="params">()</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="built_in">toupper</span>(<span class="string">&quot;&quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">    <span class="keyword">let</span> name = <span class="keyword">join</span>(<span class="keyword">split</span>(name, <span class="string">&#x27;\.&#x27;</span>), <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> name = <span class="keyword">join</span>(<span class="keyword">split</span>(name, <span class="string">&#x27;-&#x27;</span>), <span class="string">&#x27;_&#x27;</span>)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">1</span>, <span class="keyword">join</span>([<span class="string">&#x27;#ifndef&#x27;</span>, name]))</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">2</span>, <span class="keyword">join</span>([<span class="string">&#x27;#define&#x27;</span>, name]))</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">setline</span>(<span class="number">3</span>, <span class="keyword">join</span>([<span class="string">&#x27;#endif  //&#x27;</span>, name]))</span><br><span class="line">    exec <span class="string">&quot;:2&quot;</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>

<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>本篇介绍了搭建C&#x2F;C++开发环境中的一些插件，虽然对于一般人我可以算vim狂热者了，但是对于真正熟悉vim的人来说，我还有很多需要学习的，比如很多插件我也是浅尝辄止，但毕竟vim不同于IDE的一点就是其配置高度个人化，真正觉得需要提高效率了再去看看是不是需要详细了解下插件怎么用。</p>
<p>我的vim-plug管理的插件如下：</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">call plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;Valloric</span>/<span class="type">YouCompleteMe&#x27;</span></span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;scrooloose</span>/nerdtree&#x27;, &#123; <span class="symbol">&#x27;on&#x27;</span>: <span class="symbol">&#x27;NERDTreeToggle&#x27;</span> &#125;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;w0rp</span>/ale&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;SirVer</span>/ultisnips&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;honza</span>/vim-snippets&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;rhysd</span>/vim-clang-format&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;vim</span>-scripts/a.vim&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;skywind3000</span>/asyncrun.vim&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;Yggdroot</span>/<span class="type">LeaderF&#x27;</span></span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;mhinz</span>/vim-signify&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;sickill</span>/vim-monokai&#x27;               <span class="string">&quot; monokai主题</span></span><br><span class="line"><span class="string">Plug &#x27;vim-airline/vim-airline&#x27;           &quot;</span> 美化状态栏</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;vim</span>-airline/vim-airline-themes&#x27;</span><br><span class="line"><span class="type">Plug</span> <span class="symbol">&#x27;plasticboy</span>/vim-markdown&#x27;           <span class="string">&quot; markdown高亮</span></span><br><span class="line"><span class="string">Plug &#x27;octol/vim-cpp-enhanced-highlight&#x27;  &quot;</span> <span class="type">C</span>++代码高亮</span><br><span class="line"></span><br><span class="line">call plug#<span class="keyword">end</span><span class="literal">()</span></span><br></pre></td></tr></table></figure>

<p>如果vim编辑比较卡的话，可以试着注释掉某些插件，比如我实测C++代码高亮有时候会拖慢速度。YCM如果配置于某些较为庞大的项目可能也有点问题。</p>
<p><code>~/.vim/plugged</code>目录下各插件占用磁盘大小：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ du -h <span class="params">--max-depth=1</span> . | grep -v <span class="string">&quot;\.$&quot;</span></span><br><span class="line">512K    <span class="string">./vim-clang-format</span></span><br><span class="line">1.8M    <span class="string">./vim-snippets</span></span><br><span class="line">240K    <span class="string">./a.vim</span></span><br><span class="line">8.8M    <span class="string">./ultisnips</span></span><br><span class="line">1.4M    <span class="string">./LeaderF</span></span><br><span class="line">436K    <span class="string">./vim-cpp-enhanced-highlight</span></span><br><span class="line">908K    <span class="string">./nerdtree</span></span><br><span class="line">1.9M    <span class="string">./asyncrun.vim</span></span><br><span class="line">341M    <span class="string">./YouCompleteMe</span></span><br><span class="line">992K    <span class="string">./vim-markdown</span></span><br><span class="line">2.3M    <span class="string">./vim-signify</span></span><br><span class="line">820K    <span class="string">./vim-airline-themes</span></span><br><span class="line">1.2M    <span class="string">./vim-airline</span></span><br><span class="line">24M     <span class="string">./ale</span></span><br><span class="line">224K    <span class="string">./vim-monokai</span></span><br></pre></td></tr></table></figure>

<p>YCM目录包含了编译的文件，所以从200多M涨到了341M。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XYZ, aka BewareMyPower</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYZ, aka BewareMyPower</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
