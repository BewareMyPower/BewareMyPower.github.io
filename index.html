<!DOCTYPE html>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="BewareMyPower的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BewareMyPower的博客">
<meta property="og:locale">
<meta property="article:author" content="XYZ, aka BewareMyPower">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>BewareMyPower的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BewareMyPower的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/04/08/Python-lambda-%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/08/Python-lambda-%E5%AE%9E%E7%8E%B0%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">Python lambda 实现回调函数</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-08 23:14:09 / Modified: 23:53:37" itemprop="dateCreated datePublished" datetime="2022-04-08T23:14:09+08:00">2022-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>本文偏实用性，从一个熟悉 C++ 但是对 Python 不太熟悉的用户角度，讲讲我的历程。不讨论语言上的细节。最近遇到一个 Python 中传递回调函数的场景，由于 Python 写得不多，导致 Python 的行为并不像我预期的那样。首先以一个错误示例开始：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_f</span>():</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    l.append(inner_f)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>看起来这里的 <code>i</code> 捕获了循环变量 <code>i</code>，将闭包先存入列表 <code>l</code> 中然后延迟调用。然而输出结果违反了直觉：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="按引用捕获，而非按值捕获"><a href="#按引用捕获，而非按值捕获" class="headerlink" title="按引用捕获，而非按值捕获"></a>按引用捕获，而非按值捕获</h2><p>我的第一反应是这里的 <code>i</code> 并不是按值捕获，而是按引用捕获。我修改代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_f</span>():</span><br><span class="line">        <span class="built_in">print</span>(s)</span><br><span class="line">    l.append(inner_f)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>打印结果却是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">prefix</span>-<span class="number">2</span></span><br><span class="line"><span class="attribute">prefix</span>-<span class="number">2</span></span><br><span class="line"><span class="attribute">prefix</span>-<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这就令人非常迷惑了，<code>s</code> 应该每次循环都创建的局部变量，难道 <code>s</code> 的创建也推迟到函数运行了？这里打印了 <code>i</code> 和 <code>s</code> 的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;i: &#123;&#125; (&#123;&#125;), s: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i, <span class="built_in">id</span>(i), s, <span class="built_in">id</span>(s)))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_f</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;i: &#123;&#125; (&#123;&#125;), s: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i, <span class="built_in">id</span>(i), s, <span class="built_in">id</span>(s)))</span><br><span class="line">    l.append(inner_f)</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span>: <span class="number">0</span> (<span class="number">4536600848</span>), s: prefix-<span class="number">0</span> (<span class="number">4539234672</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">1</span> (<span class="number">4536600880</span>), s: prefix-<span class="number">1</span> (<span class="number">4539234800</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4536600912</span>), s: prefix-<span class="number">2</span> (<span class="number">4539234736</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4536600912</span>), s: prefix-<span class="number">2</span> (<span class="number">4539234736</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4536600912</span>), s: prefix-<span class="number">2</span> (<span class="number">4539234736</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4536600912</span>), s: prefix-<span class="number">2</span> (<span class="number">4539234736</span>)</span><br></pre></td></tr></table></figure>

<p>看起来确实……所有循环里的 <code>i</code> 和 <code>s</code> 都是复用了同一个变量。</p>
<h2 id="Python-局部变量生命周期"><a href="#Python-局部变量生命周期" class="headerlink" title="Python 局部变量生命周期"></a>Python 局部变量生命周期</h2><p>其实到这里，我突然想起最开始入门 Python 的时候，那本小册子上特地讲了，Python 与很多主流语言处理局部变量的不同之处。</p>
<p>比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>.<span class="built_in">format</span>(i, s))</span><br></pre></td></tr></table></figure>

<p>循环变量 <code>i</code> 和在循环体内定义的变量 <code>s</code>，在脱离循环后，仍然可以访问。可见 Python 在循环中使用的所有局部变量。Python 的局部变量不会随着循环脱离作用域，而是会随着函数退出才脱离作用域。用 C++ 作为比方，可能上述代码被解释成类似下面这样的 C++ 代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">std::string s;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  s = <span class="string">&quot;prefix-&quot;</span> + std::<span class="built_in">to_string</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h2 id="闭包按值捕获"><a href="#闭包按值捕获" class="headerlink" title="闭包按值捕获"></a>闭包按值捕获</h2><p>这个时候也许需要借助类似<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Partial_function">偏函数</a>的概念。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner_f</span>(<span class="params">i, s</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;i: &#123;&#125; (&#123;&#125;), s: &#123;&#125; (&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(i, <span class="built_in">id</span>(i), s, <span class="built_in">id</span>(s)))</span><br><span class="line">    <span class="comment"># 使用 partial 将二元谓词 inner_f 的两个参数绑定为 i 和 s 的值</span></span><br><span class="line">    l.append(partial(inner_f, i, s))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span>: <span class="number">0</span> (<span class="number">4373719312</span>), s: prefix-<span class="number">0</span> (<span class="number">4376353072</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">1</span> (<span class="number">4373719344</span>), s: prefix-<span class="number">1</span> (<span class="number">4376353200</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4373719376</span>), s: prefix-<span class="number">2</span> (<span class="number">4376353264</span>)</span><br></pre></td></tr></table></figure>

<h2 id="使用-lambda-进行简化"><a href="#使用-lambda-进行简化" class="headerlink" title="使用 lambda 进行简化"></a>使用 lambda 进行简化</h2><p>其实 Python 也提供了方便的 lambda 表达式，而不用使用 <code>functools</code> 下面的工具。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    l.append(</span><br><span class="line">        <span class="keyword">lambda</span> i=i, s=s: <span class="built_in">print</span>(<span class="string">&quot;i: &#123;&#125; (&#123;&#125;), s: &#123;&#125; (&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(i, <span class="built_in">id</span>(i), s, <span class="built_in">id</span>(s)))</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>这里 <code>i=i</code> 和 <code>s=s</code> 看起来比较诡异，实际上是进行初始化，用外部变量（实参）来初始化 lambda 的内部变量（形参）。对于不熟悉这种语法的人而言，上面代码改成这样可能更好理解（当然，也更冗长了，实际上就用上面这种代码更好）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    s = <span class="string">&quot;prefix-&quot;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">    l.append(</span><br><span class="line">        <span class="keyword">lambda</span> inner_i=i, inner_s=s: <span class="built_in">print</span>(</span><br><span class="line">            <span class="string">&quot;i: &#123;&#125; (&#123;&#125;), s: &#123;&#125; (&#123;&#125;)&quot;</span>.<span class="built_in">format</span>(inner_i, <span class="built_in">id</span>(inner_i), inner_s, <span class="built_in">id</span>(inner_s))</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> l:</span><br><span class="line">    f()</span><br></pre></td></tr></table></figure>

<p>总之，输出也是符合期望的：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">i</span>: <span class="number">0</span> (<span class="number">4427942160</span>), s: prefix-<span class="number">0</span> (<span class="number">4430575856</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">1</span> (<span class="number">4427942192</span>), s: prefix-<span class="number">1</span> (<span class="number">4430576048</span>)</span><br><span class="line"><span class="attribute">i</span>: <span class="number">2</span> (<span class="number">4427942224</span>), s: prefix-<span class="number">2</span> (<span class="number">4430576112</span>)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之磕磕绊绊，发现 Python 在处理稍微复杂一点点的逻辑时，并不是像初入门那么简单，易如 Python 也有所谓的坑。本文很多细节都没深究，只是以一个 C++er 的角度踩踩坑。</p>
<h2 id="附录：C-风格的等价代码"><a href="#附录：C-风格的等价代码" class="headerlink" title="附录：C++ 风格的等价代码"></a>附录：C++ 风格的等价代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  vector&lt;function&lt;<span class="type">void</span>()&gt;&gt; l;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;prefix-&quot;</span> + std::<span class="built_in">to_string</span>(i)&#125;;</span><br><span class="line">    l.<span class="built_in">emplace_back</span>([ i, s&#123;std::<span class="built_in">move</span>(s)&#125; ] &#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, s: &quot;</span> &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; f : l) &#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 lambda 表达式中：</p>
<ul>
<li><code>i</code>：直接按值来捕获循环变量 <code>i</code>，发生一次 <code>int</code> 的拷贝。</li>
<li><code>s</code>：对于 <code>std::string</code> 类型，使用移动构造来避免拷贝的开销。当然，在这个例子里没必要，因为对于短字符串的移动构造实际上还是发生了拷贝，一般都是 SSO（短字符串优化）实现。</li>
</ul>
<p>这里用到了 C++14 的特性，也就是支持 lambda 表达式的捕获列表初始化（<code>s&#123;std::move(s)&#125;</code>），因此编译器至少需要支持 C++14 然后加上 <code>-std=c++14</code> 这种选项来编译。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/27/Java-Stream-%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/Java-Stream-%E7%AE%80%E5%8D%95%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java Stream 简单学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-27 01:23:57 / Modified: 01:28:00" itemprop="dateCreated datePublished" datetime="2022-02-27T01:23:57+08:00">2022-02-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近对项目做了一个重构，其中有一部分是把代码风格变得很函数式了。Java 8 引入了 lambda 表达式和 <code>Stream</code> 后使得函数式编程就更容易了。这里不谈及比较理论的东西，只谈下我认为的优缺点。</p>
<p>优点：</p>
<ul>
<li>表达简单直观（虽然使用 Java 还是比较啰嗦）</li>
<li>提倡使用 immutable 对象，实现线程安全更容易</li>
<li>能够通过将 stream 改成 parallel stream 将现有代码改成并行处理</li>
</ul>
<p>缺点：</p>
<ul>
<li>性能有一定损失。可以用 <a target="_blank" rel="noopener" href="https://github.com/openjdk/jmh">JMH</a> 进行性能测试，大多数情况这点性能损失不会有明显影响，除非代码处在关键路径上。</li>
<li>调试相对比较麻烦。其实很多时候可以通过测试驱动的编码方式避免写了一大串代码后再去排查是不是链式调用的某一块出问题了。</li>
</ul>
<h2 id="了解-Stream"><a href="#了解-Stream" class="headerlink" title="了解 Stream"></a>了解 Stream</h2><p>举个例子，给出下面这段处理代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1.size());</span><br><span class="line">list1.forEach(x -&gt; list2.add(x + <span class="number">100</span>));</span><br><span class="line"><span class="keyword">final</span> List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list2.size());</span><br><span class="line">list2.forEach(x -&gt; list3.add(<span class="string">&quot;i-&quot;</span> + x));</span><br></pre></td></tr></table></figure>

<p>从函数式思维的角度，我们实际上是依次对 <code>list1</code> 的每个元素执行以下运算：</p>
<ol>
<li>加上 100</li>
<li>转换成字符串，并加上 <code>i-</code> 前缀。</li>
</ol>
<p>理想的函数映射表达是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list3 = list1.map(x -&gt; x + <span class="number">100</span>).map(x -&gt; <span class="string">&quot;i-&quot;</span> + x);</span><br></pre></td></tr></table></figure>

<p>但是在实际的 Java 代码中，<code>map</code> 这样的操作不能直接作用于容器，而必须作用于容器对应的 stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;String&gt; list3 = list1.stream().map(x -&gt; x + <span class="number">100</span>).map(x -&gt; <span class="string">&quot;i-&quot;</span> + x).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>容器必须先调用 <code>stream()</code> 方法转换成流（<code>Stream</code> 接口）。其实从设计的角度也可以理解，假如对 <code>List</code> 扩充 <code>map</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; List&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span></span><br></pre></td></tr></table></figure>

<p>那么每次 <code>map</code> 都会创建新的 <code>List</code> 对象。而 <code>Stream</code> 是可以理解为它只记录了对流中每个元素的<strong>函数</strong>，每次 <code>map</code> 调用返回的只有记录了新的函数（<code>Function</code>）的 <code>Stream</code>，不会将容器中地元素进行拷贝。只有在 <code>collect</code> 调用时才会将元素从流中取出，放入新的容器中。</p>
<p>流操作会被复合成一个<strong>流管道（stream pipeline）</strong>，它包含：</p>
<ul>
<li>源（source）：可以是集合，数组或者函数生成器，或者 I&#x2F;O 管道。</li>
<li>中间操作（intermediate operation）：将流转换成另一个流，比如前文的 <code>map</code>。</li>
<li>终端操作（terminal operation）：产生结果或副作用，比如前文的 <code>collect</code>。</li>
</ul>
<p>流是惰性的（lazy），只有在终端操作才会对源数据进行计算，并且仅在需要时消耗源元素。</p>
<p>Java 容器都提供了 <code>stream()</code> 方法取得对应的流。类似的，用 <code>parallelStream()</code> 方法得到并行流，并行流会使用线程池来计算，本文只讨论顺序流。对于数组 <code>T[]</code> 可以用 <code>Arrays#stream</code> 静态方法将其转换成流，对于可变参数列表 <code>T...</code> 可以用 <code>Streams#of</code> 静态方法将其转换成流，对于两个整型表示的左闭右开区间，可以用 <code>IntStream#range</code> 或者 <code>LongStream#range</code> 将其转换成流。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;);</span><br><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">LongStream.range(<span class="number">0L</span>, <span class="number">3L</span>);</span><br></pre></td></tr></table></figure>

<p>上述四行代码都是将序列 0，1，2 转换成流。</p>
<p>流也是一次性的，在遍历一遍后，流就会处于关闭状态。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">stream.map(x -&gt; x + <span class="number">10</span>);</span><br><span class="line">stream.map(x -&gt; x + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>在对同一个流第二次调用 <code>map</code> 时会报出异常：</p>
<blockquote>
<p>java.lang.IllegalStateException: stream has already been operated upon or closed</p>
</blockquote>
<p>因为无法对同一个流进行两次中间操作（如果允许的话，就会流就会出现两个分支），因此在进行一个中间操作后，这个流就无法再使用，必须对返回的流添加新的中间操作。注意到错误提示里还有个 or closed 描述，因为流也可以调用 <code>close()</code> 主动关闭，一般是对于 I&#x2F;O 管道的流才需要这些操作。</p>
<h2 id="常用的流操作示例"><a href="#常用的流操作示例" class="headerlink" title="常用的流操作示例"></a>常用的流操作示例</h2><p>在对流有了一个基础认识后，这一节偏实用性，以 <code>List</code> 容器（列表）作为源，介绍一些常见的操作。</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>比如最简单的求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer x : list) &#123;</span><br><span class="line">    sum += x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上可以看作有一个初始值 0（<code>identity</code>），然后依次对流的每个元素 <code>value</code> 进行求和运算（<code>identity + value</code>）。此时可以用 <code>reduce</code> 中间操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>

<p>如果初始值的类型和流的元素类型不一致，那么需要第三个参数 <code>combiner</code>，它是函数 <code>(T, T) -&gt; T</code>，其中 <code>T</code> 为初始值的类型，该函数必须满足：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)</span><br></pre></td></tr></table></figure>

<p>其中 <code>accumulator</code> 为 <code>reduce</code> 的第二个参数。如果流不是并行的，这个参数不起作用，该函数不会被调用，这个时候传入一个简单的 <code>(x, y) -&gt; x</code> 函数即可。对 combiner 感兴趣的可以阅读 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24308146/why-is-a-combiner-needed-for-reduce-method-that-converts-type-in-java-8">这个讨论</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.stream().reduce(<span class="string">&quot;prefix&quot;</span> , (s, i) -&gt; s + <span class="string">&quot;-&quot;</span> + i, (x, y) -&gt; x);</span><br><span class="line">System.out.println(result)</span><br></pre></td></tr></table></figure>

<p>上述代码得到的 <code>result</code> 是字符串 <code>prefix-1-2-3</code>。如果要在并行场景下也能工作，那么需要特别设计 combiner，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> list.parallelStream().reduce(<span class="string">&quot;prefix&quot;</span> , (s, i) -&gt; s + <span class="string">&quot;-&quot;</span> + i,</span><br><span class="line">        (s1, s2) -&gt; s1 + s2.substring(<span class="string">&quot;prefix&quot;</span>.length()));</span><br></pre></td></tr></table></figure>

<p>类似地，假如要合并多个列表，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list2 = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list3 = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br></pre></td></tr></table></figure>

<p>直接的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1);</span><br><span class="line">list.addAll(list2);</span><br><span class="line">list.addAll(list3);</span><br></pre></td></tr></table></figure>

<p>基于 <code>reduce</code> 的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Stream.of(list1, list2, list3).reduce(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), (lhs, rhs) -&gt; &#123;</span><br><span class="line">    lhs.addAll(rhs);</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>接着前一节的示例，合并多个列表，虽然用 <code>reduce</code> 是自然的，但并不是最适合的。这种场景实际上应该用 <code>flatMap</code>。</p>
<p><code>map</code> 是将 <code>Stream&lt;T&gt;</code> 映射到 <code>Stream&lt;R&gt;</code>。但列表合并的需求，实际上是将 <code>Stream&lt;List&lt;T&gt;&gt;</code> 转换成 <code>Stream&lt;T&gt;</code>，无法直接将 <code>List&lt;T&gt;</code> 通过函数得到 <code>T</code>，而且两者关系也不是一对一，比如第 1 个 <code>List&lt;T&gt;</code> 包含 3 个元素，那么我们想要在返回的流中添加 3 个 <code>T</code> 。在这种数量发生斌华的场景，则是 <code>flatMap</code> 使用的时机。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br></pre></td></tr></table></figure>

<p>它接收的函数是将 <code>T</code> 映射到 <code>Stream&lt;R&gt;</code>。如果 <code>T</code> 是 <code>List&lt;E&gt;</code>，那么很自然地就能得到 <code>Stream&lt;E&gt;</code>。因此基于 <code>flatMap</code> 可以更自然地合并多个列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Stream.of(list1, list2, list3).flatMap(List::stream).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>可见，<code>flatMap</code> 特别适合于流的元素（比如 <code>List&lt;T&gt;</code>）本身就可以转换成流（<code>Stream&lt;T&gt;</code>）的场景。对于列表嵌套，只需要多调用几次 <code>flatMap</code> 即可，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list1 = Arrays.asList(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Arrays.asList(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"><span class="keyword">final</span> List&lt;List&lt;Integer&gt;&gt; list2 = Collections.singletonList(Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Stream.of(list1, list2)</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .flatMap(Collection::stream)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h3><p>这个需求常见于将流进行分类。比如将整数流按照奇数和偶数分成两部分。这个操作本身是将列表分成多个列表，但是并没有对应的中间操作，原因在于，流不支持分叉成多个流。此时要使用终端操作 <code>Collectors.groupingBy</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</span><br><span class="line">groupingBy(Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">K</span>&gt; classifier) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它将流的元素 <code>T</code> 映射到结果 <code>K</code>，最终得到的结果是 <code>Map&lt;K, List&lt;T&gt;&gt;</code>。假如要将整数流分成奇数和偶数，那么我们可以用 <code>Boolean</code> 表示元素 <code>Integer</code> 是否为奇数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">final</span> Map&lt;Boolean, List&lt;Integer&gt;&gt; map = list.stream().collect(Collectors.groupingBy(i -&gt; i % <span class="number">2</span> != <span class="number">0</span>));</span><br><span class="line">System.out.println(map.get(<span class="literal">true</span>)); <span class="comment">// 奇数</span></span><br><span class="line">System.out.println(map.get(<span class="literal">false</span>)); <span class="comment">// 偶数</span></span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[1, 3, 5]</span></span><br><span class="line"><span class="string">[2, 4]</span></span><br></pre></td></tr></table></figure>

<p>这里需要重点注意的是，<code>get(true)</code> 和 <code>get(false)</code> 可能得到的是 <code>null</code>，对应的分别是流中没有偶数和没有奇数。因此需要谨慎地进行  null check。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>将整数流分成奇数和偶数有一个更慢的方法，那就是实用 <code>filter</code> 遍历两次，第一次过滤出奇数，第二次过滤出偶数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; odds = list.stream().filter(x -&gt; x % <span class="number">2</span> != <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; evens = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(odds);</span><br><span class="line">System.out.println(evens);</span><br></pre></td></tr></table></figure>

<p>如果我们只想对奇数或者偶数处理，那么 <code>filter</code> 则是最适合的。</p>
<h2 id="Map-容器的流处理"><a href="#Map-容器的流处理" class="headerlink" title="Map 容器的流处理"></a>Map 容器的流处理</h2><p>比如对 <code>Map</code> 容器本身无法得到流，因为 <code>Map</code> 并不是单个元素的流，只能对 <code>entrySet()</code> 方法返回的 <code>Set</code> 得到流 <code>Stream&lt;Map.Entry&lt;K, V&gt;&gt;</code>，然后对每个元素 <code>Map.Entry&lt;K, V&gt;</code> 进行处理。如果要在终端操作中重新得到新的 map，比如 <code>Map&lt;K, V2&gt;</code> 或者 <code>Map&lt;K2, V2&gt;</code>，那么则需要用 <code>Collector.toMap</code> 方法。</p>
<p>举个例子，下列 Java 代码将 <code>Map&lt;Integer, Integer&gt;</code> 分别对 value 和 entry 做映射得到 <code>Map&lt;Integer, String&gt;</code> 和 <code>Map&lt;String, String&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">System.out.println(map.entrySet().stream().collect(Collectors.toMap(</span><br><span class="line">        Map.Entry::getKey,</span><br><span class="line">        e -&gt; <span class="string">&quot;value-&quot;</span> + e.getValue())</span><br><span class="line">));</span><br><span class="line">System.out.println(map.entrySet().stream().collect(Collectors.toMap(</span><br><span class="line">        e -&gt; <span class="string">&quot;key-&quot;</span> + e.getKey(),</span><br><span class="line">        e -&gt; <span class="string">&quot;value-&quot;</span> + e.getValue())</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">1</span>=value-100, <span class="attribute">2</span>=value-200&#125;</span><br><span class="line">&#123;<span class="attribute">key-1</span>=value-100, <span class="attribute">key-2</span>=value-200&#125;</span><br></pre></td></tr></table></figure>

<p>可见 <code>Collectors.toMap</code> 中分别接收对 key 和 value 的映射，因此支持 key 和 value 不同的中间操作次数。</p>
<p>相比而言，Scala 在函数式编程上简洁太多，比如实现上述功能，在 Scala 中只需要如下所示：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="number">1</span> -&gt; <span class="number">100</span>, <span class="number">2</span> -&gt; <span class="number">200</span>)</span><br><span class="line">println(map.map(e =&gt; (e._1, <span class="string">&quot;value-&quot;</span> + e._2)))</span><br><span class="line">println(map.map(e =&gt; (<span class="string">&quot;key-&quot;</span> + e._1, <span class="string">&quot;value-&quot;</span> + e._2)))</span><br></pre></td></tr></table></figure>

<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>前面我们使用了三种 <code>Collectors</code> 的静态方法，这里我们来看看 <code>collect</code> 到底做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span></span><br></pre></td></tr></table></figure>

<p>首先 <code>collect</code> 方法接受的是 <code>Collector&lt;T, A, R&gt;</code> 类型，其中：</p>
<ul>
<li>T 是流的元素类型</li>
<li>A 是 <code>Collector</code> 进行中间运算的类型</li>
<li>R 是结果类型</li>
</ul>
<p>以 <code>Collectors#toList</code> 方法为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CollectorImpl</span>&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>CollectorImpl</code> 实现了 <code>Collector</code> 接口，接收四个参数，最主要的是：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th><code>toList</code> 传入的参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>supplier</code></td>
<td><code>ArrayList::new</code></td>
<td>创建 <code>ArrayList</code> 存放收集的元素</td>
</tr>
<tr>
<td><code>accumulator</code></td>
<td><code>List::add</code></td>
<td>以流的元素作为参数对 <code>supplier</code> 调用该方法，</td>
</tr>
</tbody></table>
<p>其余的 <code>combiner</code> 和 <code>characteristics</code> 比较复杂，这里就不深入研究了。</p>
<p>如果有特殊要求，我们也可以模仿 <code>CollectorImpl</code> 类自行实现 <code>Collector</code> 接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要是最近一次重构中对 Java 基于 <code>Stream</code> 的函数式编程的一点学习笔记，从了解 <code>Stream</code> 开始到常用的几个中间操作，以及针对 <code>Map</code> 容器的特殊处理，最后看了下终端操作 <code>collect</code>。更多内容可以参考 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">Java SE 8 Documents</a>。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/06/Java-Executor-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/06/Java-Executor-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java Executor 学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-06 21:25:00" itemprop="dateCreated datePublished" datetime="2022-02-06T21:25:00+08:00">2022-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="Executor-简介"><a href="#Executor-简介" class="headerlink" title="Executor 简介"></a>Executor 简介</h2><p>在 Java 中，更偏向于使用 <code>Executor</code> 而非 <code>Thread</code> 来执行任务。<code>Executor</code> 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Executor</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于 <code>Thread</code>，它可以用来在线程中执行一个 <code>Runnable</code>（任务），具体的执行策略取决于具体实现。比如以下实现就是每个任务都新建一个线程来执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> command -&gt; <span class="keyword">new</span> <span class="title class_">Thread</span>(command).start()</span><br></pre></td></tr></table></figure>

<p>在标准库中，<code>Executors</code> 类提供了若干 static 方法可用于构造不同类型的 <code>Executor</code>，它们在线程池中取出线程来执行任务，对于<strong>已提交（调用 <code>execute</code> 或 <code>submit</code> 方法执行）</strong>的任务，一般有三种状态：</p>
<ul>
<li>已经完成：任务已经由池中的某个线程执行完毕，对应线程已返回给池中</li>
<li>运行中：已经分配了线程执行任务</li>
<li>等待执行：由于线程分配策略限制（比如限制了同时运行的线程数量上限），任务被缓存到内部队列，等待被执行。</li>
</ul>
<h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><h3 id="Executor-的生命周期"><a href="#Executor-的生命周期" class="headerlink" title="Executor 的生命周期"></a>Executor 的生命周期</h3><p>JVM 会在所有非守护线程全部终止后才会退出，比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); <span class="comment">// 该线程池仅包含一个可用线程</span></span><br><span class="line">executor.execute(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot; done&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>打印 <code>pool-1-thread-1 done</code> 后会卡住，查看线程栈会看到：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;pool-1-thread-1&quot;</span> #<span class="number">11</span> prio=<span class="number">5</span> os_prio=<span class="number">31</span> tid=<span class="number">0</span>x00007fa04392a000 nid=<span class="number">0</span>xa603 waiting on condition <span class="selector-attr">[0x0000700004bd6000]</span></span><br><span class="line">   java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: WAITING (parking)</span><br><span class="line">	at sun<span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">	- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0</span>x000000076b1778a0&gt; (<span class="selector-tag">a</span> java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span>.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport<span class="selector-class">.java</span>:<span class="number">175</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span>.AbstractQueuedSynchronizer<span class="variable">$ConditionObject</span><span class="selector-class">.await</span>(AbstractQueuedSynchronizer<span class="selector-class">.java</span>:<span class="number">2039</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue<span class="selector-class">.java</span>:<span class="number">442</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1074</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1134</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span>.ThreadPoolExecutor<span class="variable">$Worker</span><span class="selector-class">.run</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">	at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>进入 <code>ThreadPoolExecutor#getTask</code> 内部看到相应代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">    workQueue.take(); <span class="comment">// 卡在这里</span></span><br></pre></td></tr></table></figure>

<p><code>workQueue</code> 也就是前文所说的保存任务的工作队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure>

<p>可见线程池 <code>ThreadPoolExecutor</code> 都会尝试从 <code>workQueue</code> 中取出任务然后分配给线程来执行，见 <code>runWorker</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br></pre></td></tr></table></figure>

<p><code>Executors</code> 类创建的实际上是 <code>ExecutorService</code> 类型，它继承自 <code>Executor</code> 接口，提供了对 <code>Executor</code> 生命周期的管理。当然，此外还提供了 <code>submit</code> 接口来基于 <code>Future</code> 对任务进行管理。</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>该方法会使 executor 等待所有已提交的任务运行完成。包括在工作队列中的任务。注意该方法并不会等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        println(index + <span class="string">&quot; started...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1000</span>);</span><br><span class="line">        println(index + <span class="string">&quot; stopped.&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br><span class="line">println(<span class="string">&quot;Executor shutdown: &quot;</span> + executor.isShutdown());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    executor.execute(() -&gt; &#123;&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">    println(<span class="string">&quot;Failed to execute task after shutdown: &quot;</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：上述代码使用了我自省添加的 <code>println</code> 方法来打印时间戳和线程名，以及 <code>sleep</code> 方法吞掉 <code>InterruptedException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String x)</span> &#123;</span><br><span class="line">    System.out.println(System.currentTimeMillis() + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; | &quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>运行结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1644147267909 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> started...</span><br><span class="line"><span class="symbol">1644147267909 </span>main | Executor shutdown: true</span><br><span class="line"><span class="symbol">1644147267911 </span>main | Failed <span class="keyword">to</span> execute task after shutdown: Task jcip.Main$$Lambda$<span class="number">2</span>/<span class="number">598446861</span>@<span class="number">619</span>a5dff rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">1</span>ed6993a[Shutting down, pool size = <span class="number">1</span>, active threads = <span class="number">1</span>, queued tasks = <span class="number">2</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line"><span class="symbol">1644147268913 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> stopped.</span><br><span class="line"><span class="symbol">1644147268913 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">1</span> started...</span><br><span class="line"><span class="symbol">1644147269915 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">1</span> stopped.</span><br><span class="line"><span class="symbol">1644147269916 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">2</span> started...</span><br><span class="line"><span class="symbol">1644147270916 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">2</span> stopped.</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>shutdown()</code> 立刻返回了，但是 JVM 进程是等待所有线程退出后才结束。但由于 <code>shutdown</code> 方法被调用，executor  会拒绝接受新的任务，因此在调用 <code>execute</code> 时会抛出 <code>RejectedExecutionException</code> 异常，包含了线程池 <code>ThreadPoolExecutor</code> 的具体信息：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Shutting</span> down, pool size = <span class="number">1</span>, active threads = <span class="number">1</span>, queued tasks = <span class="number">2</span>, completed tasks = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>线程池已经关闭，池的大小为 1，活跃线程数为 1，排队的任务为 2，已经完成的任务数量为 0。</p>
<h3 id="awaitTermination"><a href="#awaitTermination" class="headerlink" title="awaitTermination"></a>awaitTermination</h3><p>由于 <code>shutdown</code> 并不会等待 executor 关闭，因此 <code>ExecutorService</code> 还提供了 <code>awaitTermination</code> 方法进行等待。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<p>若在 timeout 范围内 executor 已经停止，则返回 true。否则返回 false，即等待超时。因此可以轮询调用该方法来等待 executor 停止。这里修改前一节调用 <code>shutdown</code> 方法之后的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">&quot;Executor terminated: &quot;</span> + executor.isTerminated());</span><br><span class="line"><span class="keyword">while</span> (!executor.awaitTermination(<span class="number">10000</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">    <span class="comment">// No ops</span></span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Executor terminated: &quot;</span> + executor.isTerminated());</span><br></pre></td></tr></table></figure>

<p>相关打印信息：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1644148189276 </span>main | Executor terminated: false</span><br><span class="line"><span class="symbol">1644148192288 </span>main | Executor terminated: true</span><br></pre></td></tr></table></figure>

<p>从时间戳之差（3008 毫秒）可见等待不到 10 秒（timeout）就完成了。注意这里还调用了 <code>isTerminated</code> 方法，当所有任务都结束时该方法会返回 true。</p>
<h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><p><code>shutdown</code> 是优雅的关闭，如果担心有的任务是有 bug 的，会一直卡住，导致 JVM 进程无法终止，此时需要用一种粗暴的关闭方式，也就是 <code>shutdownNow</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><del>我初看这个方法时比较迷惑，以为 <code>shutdownNow</code> 是异步关闭，而 <code>shutdown</code> 是同步关闭。</del>实际上，<code>shutdown</code> 会等待所有任务完成，只不过不再接受新的任务。而 <code>shutdownNow</code> 则是<strong>取消</strong>所有运行中的任务，并且不再启动等待中的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        println(index + <span class="string">&quot; started...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            println(index + <span class="string">&quot; stopped.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            println(index + <span class="string">&quot; is cancelled&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdownNow();</span><br><span class="line">executor.awaitTermination(<span class="number">1</span>, TimeUnit.MINUTES);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1644148971844 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> started...</span><br><span class="line"><span class="symbol">1644148971844 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> is cancelled</span><br></pre></td></tr></table></figure>

<p>中断状态的线程会被取消，因此抛出 <code>InterruptedException</code>，而排队的两个任务则干脆没执行。</p>
<h2 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h2><p>前面一直使用了单线程的线程池，它创建的 executor 类型实际上是 <code>ThreadPoolExecutor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span> <span class="comment">// 仅仅是个 wrapper，finalize() 方法会调用 shutdown()</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程池的配置"><a href="#线程池的配置" class="headerlink" title="线程池的配置"></a>线程池的配置</h3><p>包括前两节提到的 <code>ThreadFactory</code> 和 <code>RejectedExecutionHandler</code>，<code>ThreadPoolExecutor</code> 构造参数及其作用如下所示：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>corePoolSize</code></td>
<td><code>int</code></td>
<td>核心线程数，即保持运行的线程数，即使处于空闲状态，除非 <code>allowCoreThreadTimeout</code> 被设置</td>
</tr>
<tr>
<td><code>maximumPoolSize</code></td>
<td><code>int</code></td>
<td>线程池最大允许创建的线程数</td>
</tr>
<tr>
<td><code>keepAliveTime</code></td>
<td><code>long</code></td>
<td>当线程数超过核心线程数数量时，闲置线程在终止前等待新任务的最大时间</td>
</tr>
<tr>
<td><code>unit</code></td>
<td><code>TimeUnit</code></td>
<td><code>keepAliveTime</code> 对应的时间单位</td>
</tr>
<tr>
<td><code>workQueue</code></td>
<td><code>BlockingQueue&lt;Runnable&gt;</code></td>
<td>持有待执行的任务的队列</td>
</tr>
<tr>
<td><code>threadFactory</code></td>
<td><code>ThreadFactory</code></td>
<td>提供 <code>newThread</code> 接口，可在通过 <code>Runnable</code>创建线程时设置线程的一些信息（比如名字）</td>
</tr>
<tr>
<td><code>handler</code></td>
<td><code>RejectedExecutionHandler</code></td>
<td>当线程池到达上限时，新任务到来的处理策略。默认是抛出 <code>RejectedExecutionException</code></td>
</tr>
</tbody></table>
<p>常见的几种快速创建线程池（用静态方法去掉 <code>new</code> 前缀）的参数：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>corePoolSize</code></th>
<th><code>maximumPoolSize</code></th>
<th><code>keepAliveTime</code></th>
<th><code>workQueue</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>FixedThreadPool</code></td>
<td>nThreads</td>
<td>nThreads</td>
<td>0</td>
<td><code>LinkedBlockingQueue</code></td>
</tr>
<tr>
<td><code>SingleThreadExecutor</code></td>
<td>1</td>
<td>1</td>
<td>0</td>
<td><code>LinkedBlockingQueue</code></td>
</tr>
<tr>
<td><code>CachedThreadPool</code></td>
<td>0</td>
<td><code>Integer.MAX_VALUE</code></td>
<td>60 s</td>
<td><code>SynchronousQueue</code></td>
</tr>
</tbody></table>
<p>上述几种典型的配置各有缺陷，比如 <code>CachedThreadPool</code> 无法限制线程数量，容易导致线程创建太多而 OOM。而另外两种配置则限制死了线程的最大数量。</p>
<p>最核心的参数是 <code>corePoolSize</code> 和 <code>maximumPoolSize</code>。当线程池的线程数不大于 <code>corePoolSize</code> 时，对于新的任务都会创建线程。但是如果正在运行的线程数量达到了 <code>corePoolSize</code>，新任务到来时则会根据 <code>maximumPoolSize</code> 和 <code>workQueue</code> 来决定行为：</p>
<ul>
<li><code>workQueue</code> 未满：加入队列</li>
<li><code>workQueue</code> 已满：<ul>
<li>若正在运行的线程数小于 <code>maximumPoolSize</code>，则创建新的线程执行任务</li>
<li>否则抛出 <code>RejectedExecutionException</code></li>
</ul>
</li>
</ul>
<p>这里给出一段示例配置的行为表现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">        <span class="number">1</span>, <span class="comment">// corePoolSize</span></span><br><span class="line">        <span class="number">3</span>, <span class="comment">// maximumPoolSize</span></span><br><span class="line">        <span class="number">1</span>, <span class="comment">// keepAliveTime</span></span><br><span class="line">        TimeUnit.SECONDS, <span class="comment">// unit</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>) <span class="comment">// workQueue</span></span><br><span class="line">        );</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            println(index + <span class="string">&quot; started...&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2000</span>);</span><br><span class="line">            println(index + <span class="string">&quot; stopped.&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        println(index + <span class="string">&quot; rejected: &quot;</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">executor.shutdown();</span><br><span class="line"><span class="keyword">while</span> (!executor.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    <span class="comment">// No ops</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1644155259100 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> started...</span><br><span class="line"><span class="symbol">1644155259101 </span>main | <span class="number">4</span> rejected: Task jcip.Main$$Lambda$<span class="number">1</span>/<span class="number">758705033</span>@<span class="number">4534</span>b60d rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">3</span>fa77460[Running, pool size = <span class="number">3</span>, active threads = <span class="number">3</span>, queued tasks = <span class="number">1</span>, completed tasks = <span class="number">0</span>]</span><br><span class="line"><span class="symbol">1644155259100 </span>pool-<span class="number">1</span>-thread-<span class="number">3</span> | <span class="number">3</span> started...</span><br><span class="line"><span class="symbol">1644155259100 </span>pool-<span class="number">1</span>-thread-<span class="number">2</span> | <span class="number">2</span> started...</span><br><span class="line"><span class="symbol">1644155261104 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">0</span> stopped.</span><br><span class="line"><span class="symbol">1644155261104 </span>pool-<span class="number">1</span>-thread-<span class="number">2</span> | <span class="number">2</span> stopped.</span><br><span class="line"><span class="symbol">1644155261104 </span>pool-<span class="number">1</span>-thread-<span class="number">3</span> | <span class="number">3</span> stopped.</span><br><span class="line"><span class="symbol">1644155261104 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">1</span> started...</span><br><span class="line"><span class="symbol">1644155263107 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | <span class="number">1</span> stopped.</span><br></pre></td></tr></table></figure>

<p>因为 <code>println</code> 不是线程安全的，因此打印法航了乱序，但从时间戳来看，顺序为：</p>
<ol>
<li>提交任务 0，新建线程 <code>pool-1-thread-1</code> 来执行，此时活跃线程数到达了 <code>corePoolSize</code>。</li>
<li>提交任务 1，进入大小为 1 的 <code>ArrayBlockingQueue</code> 中，此时队列已满。</li>
<li>提交任务 2，新建线程 <code>pool-1-thread-2</code> 来执行。</li>
<li>提交任务 3，新建线程 <code>pool-1-thread-3</code> 来执行，此时活跃线程数到达了 <code>maximumPoolSize</code>。</li>
<li>提交任务 4，抛出 <code>RejectedExecutionException</code>。</li>
<li>2 秒后，任务 0，2，3 执行完毕，队列中的任务 1 弹出，由线程 <code>pool-1-thread-1</code> 执行。</li>
</ol>
<h3 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep Alive"></a>Keep Alive</h3><p><code>keepAliveTime</code> 和 <code>unit</code> 参数更多的是控制闲置的非核心线程数的等待时间。闲置线程即没有执行任务的线程，非核心线程，则是相对于核心线程而言的。比如若 <code>corePoolSize</code> 为 1，<code>maximumPoolSize</code> 为 3，那么如果因为提交任务数量比较多，导致创建了 3 个线程，这多出的 2 个线程都是非核心线程。</p>
<p>这里仅从代码角度分析见 <code>ThreadPoolExecutor#getTask</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须对 ThreadPoolExecutor 调用 allowCoreThreadTimeOut 方法将同名参数设为 true 才会启用 keepAliveTime 检查</span></span><br><span class="line"><span class="comment">// wc 为工作线程数量，因此只有大于 corePoolSize 才会检查，因为只有超过核心运行线程数量的线程才会被当成多余的线程</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">    &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) <span class="comment">// [2] 回收多余线程，减少工作线程数量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    timedOut = <span class="literal">true</span>; <span class="comment">// [1] 在 keepAliveTime 内没有任务，则置为 true</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">    timedOut = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的 <code>keepAliveTime</code> 在构造时已经转换成了纳秒单位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br></pre></td></tr></table></figure>

<p>上面代码有个比较诡异的地方，就是什么时候 <code>wc</code> 会超过最大线程数量。查看方法注释，可知如果 <code>setMaximumPoolSize</code> 被调用，那么 <code>maximumPoolSize</code> 会发生动态变化，此时会导致 worker 数超过了  <code>maximumPoolSize</code>。</p>
<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">    Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>ThreadPoolExecutor</code> 中，默认的线程工厂是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title function_">defaultThreadFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DefaultThreadFactory() &#123;</span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">s</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="literal">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                          Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">&quot;pool-&quot;</span> +</span><br><span class="line">                  poolNumber.getAndIncrement() +</span><br><span class="line">                 <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, r,</span><br><span class="line">                          namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                          <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="literal">false</span>); <span class="comment">// 对于守护线程，也要将其改成用户线程</span></span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY); <span class="comment">// 默认线程优先级是 NORM</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它首先通过系统的 <code>SecurityManager</code> 是否存在来设置线程组。线程名则是 <code>pool-&lt;id&gt;-thread-&lt;thread-id&gt;</code>，其中 <code>id</code> 为线程池 id，从 1 开始递增，<code>thread-id</code> 为线程 id，也从 1 开始递增。</p>
<p>运行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">executor1.execute(() -&gt; println(<span class="string">&quot;executor 1 thread 1&quot;</span>));</span><br><span class="line">executor2.execute(() -&gt; println(<span class="string">&quot;executor 2 thread 1&quot;</span>));</span><br><span class="line">executor2.execute(() -&gt; println(<span class="string">&quot;executor 2 thread 2&quot;</span>));</span><br><span class="line">executor1.shutdown();</span><br><span class="line">executor2.shutdown();</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1644149652981 </span>pool-<span class="number">1</span>-thread-<span class="number">1</span> | executor <span class="number">1</span> thread <span class="number">1</span></span><br><span class="line"><span class="symbol">1644149652981 </span>pool-<span class="number">2</span>-thread-<span class="number">1</span> | executor <span class="number">2</span> thread <span class="number">1</span></span><br><span class="line"><span class="symbol">1644149652981 </span>pool-<span class="number">2</span>-thread-<span class="number">1</span> | executor <span class="number">2</span> thread <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>从打印出的线程名就可以看出对应关系。常见的自定义 <code>ThreadFactory</code> 的场景往往是要单独给某些 executor 的线程进行标识，从而在调试的时候区分线程。当然，由于 <code>newThread</code> 方法是可定制的，也可以定制更多线程策略。</p>
<p>在 <code>Executors</code> 的方法中，一般都会有重载形式来支持指定 <code>ThreadFactory</code>，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>在前文提到 <code>shutdown</code> 方法时，我们知道对于一个已关闭的 executor，若强行执行新的任务会抛出 <code>RejectedExecutionException</code> 异常。这里 <code>RejectedExecutionHandler</code> 则是支持定制化此时的行为。默认策略是 <code>AbortPolicy</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RejectedExecutionHandler</span> <span class="variable">defaultHandler</span> <span class="operator">=</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AbortPolicy</span>();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AbortPolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Task &quot;</span> + r.toString() +</span><br><span class="line">                                             <span class="string">&quot; rejected from &quot;</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过 <code>Executors</code>的方法并没有支持自定义 <code>RejectedExecutionHandler</code>，因为抛出异常的处理方式基本上是很痛用了，一般没必要定制。</p>
<h2 id="使用-submit-执行任务"><a href="#使用-submit-执行任务" class="headerlink" title="使用 submit 执行任务"></a>使用 submit 执行任务</h2><p><code>ExecutorService</code> 在 <code>Executor</code> 的基础上增加了 <code>submit</code> 方法，它会返回一个 <code>Future</code>，因此我们可以用 <code>Future</code> 来管理任务状态以及任务的返回值。对于有返回值的任务，<code>submit</code> 方法往往更实用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; DATA = prepareData();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">prepareData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Integer&gt; data = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        data.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">numThreads</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">sizePerThread</span> <span class="operator">=</span> DATA.size() / numThreads;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Future&lt;Long&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(numThreads);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numThreads; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> i * sizePerThread;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> (i &lt; numThreads - <span class="number">1</span>) ? (startIndex + sizePerThread) : DATA.size();</span><br><span class="line">        futures.add(executor.submit(() -&gt; &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> startIndex; j &lt; endIndex; j++) &#123;</span><br><span class="line">                sum += DATA.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum; <span class="comment">// 该 lambda 返回 Long，对应 Callable&lt;Long&gt;，因此 submit 返回的是 Future&lt;Long&gt;</span></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Future&lt;Long&gt; future : futures) &#123;</span><br><span class="line">        sum += future.get();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码则是将 100000 个数据的 <code>DATA</code> 分成 5 块，每块由一个任务来求和，每个任务对应一个 <code>Future</code>，最后将结果汇总求和。</p>
<h2 id="总结和展望"><a href="#总结和展望" class="headerlink" title="总结和展望"></a>总结和展望</h2><p>本文主要从 <code>Executor</code> 谈到最基本的线程池（<code>ThreadPoolExecutor</code>）的使用。</p>
<p>除此之外，以下相关内容并不属于本文的讨论范畴，但简单提及下。</p>
<ul>
<li>Java 7 引入了基于 work-stealing 的 executor（使用 <code>newWorkStealingPool</code> 创建，类型为 <code>ForkJoinPool</code>），比起普通的线程池并行化更高，它的原理是用双端队列（deque）保存任务，并且可以有多个队列保存任务，这样在一个队列任务执行完毕后，还可以从其他队列的尾端来<strong>窃取</strong>工作线程。</li>
<li>对于延时任务或者定时任务，应该使用 <code>ScheduledThreadPoolExecutor</code> 和 <code>schedule()</code> 方法。相比起用 <code>Timer</code> 和 <code>schedule()</code> 而言，不受系统时钟变化的影响，而且能够正确处理抛出 unchecked exception 的任务。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/10/03/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Golang/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/03/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Golang/" class="post-title-link" itemprop="url">重新学习 Golang</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-03 20:46:01" itemprop="dateCreated datePublished" datetime="2021-10-03T20:46:01+08:00">2021-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第一次接触 Go 还是 2018 年在 360 实习的时候，当时调研一个 Kafka 监控工具 <a target="_blank" rel="noopener" href="https://github.com/linkedin/Burrow">Burrow</a>，还贡献了我在开源社区的 <a target="_blank" rel="noopener" href="https://github.com/linkedin/Burrow/pull/439/files">第一个 PR</a>。到后来正式入职前，还特地过了遍 The Way of Go，再后来也基本搁置了，偶尔帮业务排查下问题的时候会简单写个例子。当时还在用 GOPATH，现在 Burrow 官方文档都表示最低支持 Golang 1.11 和 Go module 的管理方式了。总的来说感觉目前由于云原生的火热，Go 的使用确实比较广，国庆刚好休息下，就重新看看了。</p>
<h2 id="Get-Started"><a href="#Get-Started" class="headerlink" title="Get Started"></a>Get Started</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>module（模块）：一组 package 的集合，可以直接从版本控制仓库或者模块代理服务器上下载。module 由 go.mod 文件中的 module path 以及 module 依赖决定。module 根目录是包含 go.mod 文件的目录，main module 是包含这个目录的模块，并且在该目录下可以执行 go 命令。</li>
<li>module path（模块路径）：仅作为 package 的 import path 的前缀，表明了 go 命令应该在哪去下载。</li>
<li>package（包）：同一个目录下的一组源文件的集合。</li>
<li>package path：也就是 package 的 import path。是 module path 加上包含该 package 的子目录的路径。例如 <code>&quot;golang.org/x/net&quot;</code> 在目录 <code>&quot;html&quot;</code> 下面包含一个 package，这个 package 的路径是 <code>&quot;golang.org/x/net/html&quot;</code>。</li>
</ul>
<h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><p>首先指定一个 module path（这里是 <code>example.com/user/hello</code>）创建 go.mod 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init example.com/user/hello</span><br><span class="line">go: creating new go.mod: module example.com/user/hello</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br></pre></td></tr></table></figure>

<p>可以发现生成了 go.mod 文件，内容为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module example.com/user/hello</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br></pre></td></tr></table></figure>

<p>然后创建 main.go，包含以下代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>go</code> 工具安装并运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go install example.com/user/hello</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>该命令会构建 <code>hello</code> 命令并生成二进制文件 <code>hello</code>，安装到 <code>GOPATH</code> 目录（可通过 <code>go env GOPATH</code> 查看，默认是 <code>$HOME/go</code>）的 <code>bin/</code> 子目录下。如果 <code>GOBIN</code> 已经设置，则会安装到 <code>GOBIN</code> 下面。</p>
<p>也可以直接用以下方式将其导入环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:$(<span class="built_in">dirname</span> $(go list -f <span class="string">&#x27;&#123;&#123;.Target&#125;&#125;&#x27;</span> .))</span><br></pre></td></tr></table></figure>


<p>设置 Go 环境变量的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -w GOBIN=<span class="variable">$PWD</span></span><br></pre></td></tr></table></figure>

<p>这样就会安装到当前目录（注意这只是示例，而且会永久生效，最好改到需要的路径）。如果要取消 Go 环境变量，使用 <code>-u</code> 选项即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go <span class="built_in">env</span> -u GOBIN</span><br></pre></td></tr></table></figure>

<h3 id="从-module-中导入-package"><a href="#从-module-中导入-package" class="headerlink" title="从 module 中导入 package"></a>从 module 中导入 package</h3><p>创建子目录 *morestrings&#x2F;*，然后在该目录下创建文件 <em>reverse.go</em>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package morestrings implements additional functions to manipulate UTF-8</span></span><br><span class="line"><span class="comment">// encoded strings, beyond what is provided in the standard &quot;strings&quot; package.</span></span><br><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReverseRunes returns its argument string reversed rune-wise left to right.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReverseRunes</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	r := []<span class="type">rune</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(r)<span class="number">-1</span>; i &lt; <span class="built_in">len</span>(r)/<span class="number">2</span>; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		r[i], r[j] = r[j], r[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入该目录，运行 <code>go build</code>，可以发现不会生成文件，但实际上已经编译到本地 build cache 里了。</p>
<p>现在修改 <em>hello.go</em> 内容，导入刚才的 package：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;example.com/user/hello/morestrings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后重新 <code>go install example.com/user/hello</code> 编译。 </p>
<h3 id="调用外部-package-的代码"><a href="#调用外部-package-的代码" class="headerlink" title="调用外部 package 的代码"></a>调用外部 package 的代码</h3><p>Go 可以导入版本控制系统比如 Git 的 package 源码，<code>go</code> 工具使用这个属性去从远程仓库自动下载 package，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;example.com/user/hello/morestrings&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/google/go-cmp/cmp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(morestrings.ReverseRunes(<span class="string">&quot;!oG ,olleH&quot;</span>))</span><br><span class="line">	fmt.Println(cmp.Diff(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Hello Go&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> package github.com/google/go-cmp/cmp</span><br><span class="line">go: found github.com/google/go-cmp/cmp <span class="keyword">in</span> github.com/google/go-cmp v0.5.6</span><br></pre></td></tr></table></figure>

<p>然后查看 <em>go.mod</em> 内容，可以发现它新加了一行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require github.com/google/<span class="keyword">go</span>-cmp v0<span class="number">.5</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>go mod tidy</code> 命令会添加缺失的 module requirements，同时移除不再使用的模块 requirements。在导入新 module 时，会从网上下载。</p>
<p>module 依赖会自动下载到 <code>$GOPATH/pkg/mod</code> 目录下面，下载内容会被所有其他 module 共享，要删除所有下载的 module，可以传递 <code>-modcache</code> 标志给 <code>go clean</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go clean -modcache</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>一般在包目录下面会创建单元测试，比如 <em>morestrings&#x2F;reverse.go</em>，一般会创建 <em>morestrings&#x2F;reverse_test.go</em>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> morestrings</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestReverseRunes</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	cases := []<span class="keyword">struct</span> &#123;</span><br><span class="line">		in, want <span class="type">string</span></span><br><span class="line">	&#125;&#123;</span><br><span class="line">		&#123;<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;dlrow ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;Hello, 世界&quot;</span>, <span class="string">&quot;界世 ,olleH&quot;</span>&#125;,</span><br><span class="line">		&#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		got := ReverseRunes(c.in)</span><br><span class="line">		<span class="keyword">if</span> got != c.want &#123;</span><br><span class="line">			t.Errorf(<span class="string">&quot;ReverseRunes(%q) == %q, want %q&quot;</span>, c.in, got, c.want)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 <em>go test</em> 命令运行测试即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> morestrings/</span><br><span class="line">$ go <span class="built_in">test</span></span><br><span class="line">PASS</span><br><span class="line">ok  	example.com/user/hello/morestrings	0.401s</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基于 go mod 的方法，创建 go.mod 指定当前的 <strong>模块路径</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init &lt;module-path&gt;</span><br></pre></td></tr></table></figure>

<p>模块路径一般是多级的，比如 <em>github.com&#x2F;google&#x2F;go-cmp&#x2F;cmp</em>，可以发现项目是在 <a target="_blank" rel="noopener" href="https://github.com/google/go-cmp/%EF%BC%8C%E9%82%A3%E4%B9%88%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E5%B0%B1%E6%98%AF">https://github.com/google/go-cmp/，那么模块路径就是</a> <em>github.com&#x2F;google&#x2F;go-cmp</em>，也就是项目下载地址，而包路径则是 <code>cmp</code> 目录。</p>
<p>然后代码中如果引入了外部依赖，需要在 <em>go.mod</em> 里导入依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>

<p>如果依赖在本地不存在，它会去下载依赖。不仅在 <em>go.mod</em> 中添加依赖模块路径和版本，还会在 <em>go.sum</em> 文件中引入模块元数据（tag 或 commit 信息，Base64 编码的 Hash 码）。</p>
<p>在代码中导入 <strong>包</strong> 的方式是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;&lt;module-path&gt;/&lt;package-path&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p>包路径即包目录的相对路径。如果包路径是多级的，比如 <em>dir1&#x2F;dir2&#x2F;dir3</em>，那么包名是最后一级 <em>dir3</em>。</p>
<p>构建即 <code>go build</code>，安装即 <code>go install</code>，可以使用 <code>go env</code> 相关命令设置环境变量，比如 <code>GOBIN</code> 配置安装目录。</p>
<p>一般对于模块下的 <em>xxx.go</em> 一般创建对应的测试文件 <em>xxx_test.go</em>，导入 <em>testing</em> 包然后使用相关对象比如 <code>T</code> 进行验证。在模块目录下运行 <code>go test</code> 即可。</p>
<h2 id="Tour-of-Go-笔记"><a href="#Tour-of-Go-笔记" class="headerlink" title="Tour of Go 笔记"></a>Tour of Go 笔记</h2><p><a target="_blank" rel="noopener" href="https://tour.golang.org/welcome/1">https://tour.golang.org/welcome/1</a></p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>Go 没有继承，也没有 <code>public</code>&#x2F;<code>private</code> 这种关键字，导入一个包时，包内的函数&#x2F;类&#x2F;变量等，只有大写字母开头的才可以导入。</p>
<p>函数参数的定义基本是较新语言的 <code>&lt;value&gt; &lt;type&gt;</code> 的顺序，此外连续参数可以合并，比如 <code>x int, y int</code> 可以合并为 <code>x, y int</code>。Go 可以返回多值，这使得交换操作可以写成 <code>x, y = y, x</code> 这种形式。</p>
<p>函数的返回值也可以被命名，这样就不用显式 return 返回值了，但还是需要 return。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">split</span><span class="params">(sum <span class="type">int</span>)</span></span> (x, y <span class="type">int</span>) &#123;</span><br><span class="line">	x = sum * <span class="number">4</span> / <span class="number">9</span></span><br><span class="line">	y = sum - x</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于这个例子可能不太好，但是对于那种多返回值，且一个返回值在很多分支之前都是同样的情况，可能比较适用。</p>
</blockquote>
<p>Go 的基本类型：</p>
<ul>
<li><code>bool</code></li>
<li>普通整型：<code>int</code>&#x2F;<code>uint</code>，或者加上位数的后缀，比如 <code>uint8</code>，位数包括8，16，32，64。不带位数的话，能存储的位数取决于平台，最多为 64。</li>
<li><code>uintptr</code>：指针类型，也是整型。Go 的指针不像 C 一样支持数学运算，从而保证安全。</li>
<li><code>byte</code>：<code>uint8</code> 的别名，代表一个字节</li>
<li><code>rune</code>：<code>int32</code> 的别名，它表示一个 Unicode 码点，因为对于 ASCII 字符串而言，基本单位是 <code>int8</code>（也就是 <code>char</code>），但是 Go 对字符串只支持 Unicode 编码，因此没有使用 <code>char</code> 关键字，而是使用 <code>rune</code>，代表一个 Unicode 字符。因此在 Go 里，字符和字节不会混淆。</li>
<li>浮点数：<code>float32</code>，<code>float64</code></li>
<li>复数：<code>complex64</code>，<code>complex128</code>。</li>
</ul>
<blockquote>
<p>Go 保证变量不赋予初值的话，默认是<strong>零值</strong>。数值类型都是 0，布尔类型是 false，字符串是空字符串 <code>&quot;&quot;</code>（注意不是 <strong>空值</strong> <code>nil</code>）。</p>
</blockquote>
<p>Go 的变量初始化可以推断类型，整型默认为 <code>int</code>，浮点数类型默认为 <code>float64</code>，如果没有初始值，则必须显式注明类型。此外初始化还支持 <code>:=</code> 这种形式（但是必须在函数体内使用），比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">int</span></span><br><span class="line">y = x + <span class="number">10</span></span><br><span class="line">z := <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>常量（<code>const</code> 修饰）因为必须有初值，所以基本可以省略类型声明。</p>
<p>Go 的格式化打印不是很灵活，只支持 C 风格的格式化字符串（使用 <code>fmt.Printf</code>）或者直接打印任意类型（使用 <code>fmt.Println</code> 或 <code>fmt.Print</code>）。但是在 C 风格打印时，Go 支持 <code>%T</code> 打印类型名，<code>%v</code> 打印任何类型，还能用 <code>%#v</code> 对类型本身进行修饰，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%T x = %v, %T y = %#v\n&quot;</span>, x, x, y, y)</span><br></pre></td></tr></table></figure>

<p>打印的是 <code>int x = 10, string y = &quot;hello&quot;</code>，注意如果不用 <code>%#v</code> 的话，不会给字符串加上引号。</p>
<p>Go 的类型转换有点像函数调用，比如 <code>T(v)</code> 将 <code>v</code> 转换成类型 <code>T</code>。Go 没有隐式类型转换，因此即使将 <code>int32</code> 转换成 <code>int</code> 也要显式进行，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int32</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> y <span class="type">int</span> = <span class="type">int</span>(x)</span><br></pre></td></tr></table></figure>

<p>Go 的循环只支持 <code>for</code> 循环，循环体必须有大括号，而初始化（可选），条件判断以及后置语句（可选）的部分则不用。<code>if</code> 也类似。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> i%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无限循环可以缩写为</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>if</code> 也支持初始化，并且初始化语句的值可以在 <code>else</code> 分支使用，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="type">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> y := x / <span class="number">2</span>; y%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意在 <code>for</code> 和 <code>if</code> 的初始化语句里，只能用 <code>:=</code> 的形式，因此要声明类型必须对 <code>:=</code> 右边的表达式进行类型转换。另外，Go 虽然也支持 <code>else if</code>，但这种情况下，最好使用 <code>switch</code>。Go 的 <code>switch</code> 默认不会 fallthrough，因此不需要对每个分支加 <code>break</code>。</p>
<p><code>switch</code> 比较灵活，其实更类似把 <code>if</code> 语句做个包装，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> x := <span class="number">1</span>; <span class="literal">true</span> &#123; <span class="comment">// switch &lt;initialize&gt;; &lt;variable&gt;</span></span><br><span class="line"><span class="keyword">case</span> x &lt; <span class="number">0</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;x &lt; 0&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> x == <span class="number">0</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;x = 0&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> x &gt; <span class="number">0</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;x &gt; 0&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>true</code> 可以省略（因为默认的 <code>&lt;variable&gt;</code> 就是 <code>true</code>），比如上面代码可以改为 <code>switch x := 1; &#123;</code>。这里我这么写实际上想表达，上面语句是将 <code>true</code> 与下面的 <code>case</code> 后接的表达式（比如 <code>x &lt; 0</code>）求值依次进行比较。</p>
<blockquote>
<p>这次重新学习的时候，差点以为 Go 的 <code>switch</code> 语句像 Scala，Rust 的模式匹配一样强大，实际上，虽然也比较强大就是了。</p>
</blockquote>
<p>最后 Go 关键字里最关键的 <code>defer</code>，类似于 C++ 的析构，举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	x := <span class="number">100</span></span><br><span class="line">	<span class="keyword">defer</span> fmt.Printf(<span class="string">&quot;defer %v\n&quot;</span>, x)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">main</span></span><br><span class="line"><span class="attribute">defer</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>因为 <code>defer</code> 语句会在脱离当前作用域时执行。</p>
<h3 id="指针和结构体"><a href="#指针和结构体" class="headerlink" title="指针和结构体"></a>指针和结构体</h3><p>Go 也有指针类型，但是它更多的只是作为对象的地址，不像 C 一样支持算术运算。因为 Go 没有所谓的引用类型，都是传值，对于复杂结构，传指针起到了传递引用的作用，并且避免了对象拷贝。示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="type">int</span></span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">p = &amp;i</span><br><span class="line">fmt.Printf(<span class="string">&quot;i = %v (%v)\n&quot;</span>, *p, p)</span><br></pre></td></tr></table></figure>

<p>Go 的函数可以像值一样直接传递，而不是像 C 一样需要传递函数指针。Go 的闭包也就是匿名函数，函数签名里少了函数名。闭包可以访问函数体之外的变量，类似 C++ 的 lambda 表达式捕获所有引用（<code>[&amp;]</code>）。</p>
<p>Go 有结构体，语法和 C 类似。这里有个特殊的语法，Go 的结构体指针（假如为 <code>p</code>）可以直接访问字段，比如 <code>p.X</code>，而不用 <code>(*p).X</code>。 这是为了简单实现『方法』而用的。不同于 Java 这种面向对象语言，它没有方法，对于方法的定义，是在函数定义的 <code>func</code> 以及参数列表之间插入结构体的值或指针（也就是所谓的 <strong>接收者</strong>），在这个前提下，针对结构体指针访问字段的语法就能大量简化代码，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里也可以写为 func (v Vertex) ToString() string，即将值而非指针作为接收者（但大多数情况下没必要）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> ToString() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Vertex&#123;X: %d, Y: %d&#125;&quot;</span>, v.X, v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">// 依次初始化</span></span><br><span class="line">  <span class="comment">// 这里用到了结构体部分初始化的语法，即用 Name: Value 的语法列出部分字段</span></span><br><span class="line">	v2 := Vertex&#123;X: <span class="number">1</span>&#125; <span class="comment">// 仅初始化 X，Y 为默认值 0</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;v1: %s, v2: %s\n&quot;</span>, v1.ToString(), v2.ToString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 也没有继承，但是可以通过匿名字段的方式实现继承，也就是结构体嵌入。（似乎官方 go tour 教程里并没有讲这个）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Base <span class="keyword">struct</span> &#123;</span><br><span class="line">	i <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Base)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Base: %d&quot;</span>, b.i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Derived <span class="keyword">struct</span> &#123;</span><br><span class="line">	Base <span class="comment">// 匿名字段</span></span><br><span class="line"></span><br><span class="line">	s <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不实现 String() 方法，那么 Derived 对象也能调用父类的 String() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Derived)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Derived: %s, %s&quot;</span>, d.Base.String(), d.s) <span class="comment">// d.Base 直接访问父类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组，切片，映射"><a href="#数组，切片，映射" class="headerlink" title="数组，切片，映射"></a>数组，切片，映射</h3><p>数组，切片，映射都是引用语义，因此想要修改内部时，不必传递指针。默认值都是 <code>nil</code>，也就是底层为空，但是像 <code>len</code> 和 <code>cap</code> 都能成功调用并返回 0。</p>
<p>Go 的数组也类似 C，即是定长数组比如 <code>[n]T</code>，表示数组元素类型为 <code>T</code>，数量为 <code>n</code> ，也可以采用大括号初始化的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>注意，Go 的数组不像 C 一样可以推断出数组长度，如果你写成了下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>x</code> 的类型是切片（<code>[]int</code>）而非数组（<code>[5]int</code>）。相比数组而言，切片可以动态增长，类似 C++ 的 <code>vector</code>，因此对于切片 <code>x</code>，可以用 <code>cap(x)</code> 取得切片 <code>x</code> 的容量，<code>len(x)</code> 取得切片的长度，以及用 <code>make</code> 进行初始化（<code>make(&lt;type&gt;, &lt;len&gt;)</code> 或者 <code>make(&lt;type&gt;, &lt;len&gt;, &lt;cap&gt;)</code>，用 <code>append</code> 添加元素。但这些都是 Go 的内置函数。</p>
<p>数组和切片都支持 <code>x[low:high]</code> 这种形式的部分引用，<code>low</code> 缺省为 0，<code>high</code> 缺省为 <code>len(x)</code>（数组或切片的长度）。而 <code>x[low:high]</code> 本身类型其实也是切片，也就是说数组可以方便地转换成切片。如果 <code>high</code> 超出切片长度上限但没有超出容量上限，会扩充切片长度到 <code>high</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v len=%d cap=%d\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">	printSlice(s)</span><br><span class="line">	s = s[:<span class="number">10</span>]</span><br><span class="line">	printSlice(s)</span><br><span class="line">	s = s[:<span class="number">20</span>] <span class="comment">// 超出容量上限，引发 panic</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0 0 0 0 0] <span class="attribute">len</span>=5 <span class="attribute">cap</span>=10</span><br><span class="line">[0 0 0 0 0 0 0 0 0 0] <span class="attribute">len</span>=10 <span class="attribute">cap</span>=10</span><br><span class="line">panic: runtime error: slice bounds out of range [:20] with capacity 10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>panic 类似其他语言的 <strong>异常</strong>。Go 对错误处理的态度是，它认为异常（panic）默认是不可恢复的，对于可恢复的错误，一般使用错误码或字符串保存。当然，万不得已要恢复异常，可以用 recover 内置函数。不像 Java 这种用 unchecked exception 和 checked exception 来区分这两种错误，而且很多时候写代码的人都没注意好。</p>
</blockquote>
<p>如果要扩充容量，那么就必须用内置的 <code>append</code> 函数，它可以添加一个或多个元素。可以用以下代码查看切片的扩容策略。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceMetadata</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;len=%d cap=%d\n&quot;</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		s = <span class="built_in">append</span>(s, i)</span><br><span class="line">		printSliceMetadata(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于切片（以及映射），可以用 <code>range</code> 来进行遍历：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d %v\n&quot;</span>, i, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>range</code> 遍历映射返回 <code>(key, value)</code> 比较直观，但是对于切片，实际上也是返回一对值 <code>(index, value)</code>，这样方便操作下标。如果不想取得值或下标，可以用 <code>_</code> 隐去，比如下列代码就是只打印切片 <code>s</code> 的值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于映射，直接用个 demo 表示吧，顺便复习下之前的知识。当前项目的模块路径为 <em>com.example&#x2F;temp</em>，新建 <em>wrapper&#x2F;map.go</em>，内容如下（实现了类似 Java <code>Map</code> 的接口）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">	internalMap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>)</span></span> Map &#123;</span><br><span class="line">	<span class="keyword">return</span> Map&#123;m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> ContainsKey(key <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	_, ok := m.internalMap[key]</span><br><span class="line">	<span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Put(key <span class="type">int</span>, value <span class="type">string</span>) &#123;</span><br><span class="line">	m.internalMap[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Get(key <span class="type">int</span>) (value <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	value, ok := m.internalMap[key]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		err = errors.New(fmt.Sprintf(<span class="string">&quot;Map doesn&#x27;t contain key %v&quot;</span>, key))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Remove(key <span class="type">int</span>) (value <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	value, ok := m.internalMap[key]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="built_in">delete</span>(m.internalMap, key)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		err = errors.New(fmt.Sprintf(<span class="string">&quot;Map doesn&#x27;t contain key %v&quot;</span>, key))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <em>main.go</em> 如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;com.example/temp/wrapper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkKey</span><span class="params">(m *wrapper.Map, key <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	value, err := m.Get(key)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;Get %d: %s\n&quot;</span>, key, value)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := wrapper.NewMap(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;hello&quot;</span>&#125;)</span><br><span class="line">	fmt.Println(m.ContainsKey(<span class="number">1</span>))</span><br><span class="line">	fmt.Println(m.ContainsKey(<span class="number">2</span>))</span><br><span class="line">	checkKey(&amp;m, <span class="number">2</span>)</span><br><span class="line">	m.Put(<span class="number">2</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">	checkKey(&amp;m, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line">Map doesn<span class="comment">&#x27;t contain key 2</span></span><br><span class="line"><span class="keyword">Get</span> <span class="number">2</span>: world</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Remove 方法的示例和 Get 类似，在 <em>main.go</em> 里就不写了，总之套路就是返回正确值和 <code>error</code> 接口。很多其他语言用户觉得这种处理很丑陋，但其实我觉得还好。入乡随俗。</p>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>基于对象编程只需要 <strong>结构体</strong> 和 <strong>方法</strong> 即可，但是面向对象编程则需要 <strong>结构体</strong> 和 <strong>接口</strong> 结合。接口的语法其实就是在 <code>type &lt;interface-name&gt; interface</code> 代码块中定义一系列函数，但是不需要 <code>func</code> 前缀。还是用个 demo 比较明确。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 二员操作符接口</span></span><br><span class="line"><span class="keyword">type</span> BinaryOperation <span class="keyword">interface</span> &#123;</span><br><span class="line">	Calculate(x, y <span class="type">int</span>) <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 加操作和乘操作的结构体，并且都实现了 Calculate 方法（函数参数和返回类型都一样）</span></span><br><span class="line"><span class="keyword">type</span> AddOperation <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> ProductOperation <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op AddOperation)</span></span> Calculate(x, y <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op ProductOperation)</span></span> Calculate(x, y <span class="type">int</span>) <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x * y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runBinaryOperation</span><span class="params">(op BinaryOperation, x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> op.Calculate(x, y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 3. 因此加操作和乘操作都可以视为二员操作符</span></span><br><span class="line">	x := runBinaryOperation(AddOperation&#123;&#125;, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	y := runBinaryOperation(ProductOperation&#123;&#125;, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Duck typing 使得 Golang 实现多态非常灵活，无需像 Java 一样显式 <code>implements</code> 某个接口，不然无法被转换成对应的接口类型。典型的接口在我们之前用 <code>errors.Error</code> 接口保存错误信息时已经看到了。此外，Golang 的 <code>Stringer</code> 接口用于将任意结构体转换成字符串，从而可以被 <code>%v</code> 格式化打印。这点类似于 Java 的 <code>toString()</code> 方法。</p>
<p>需要注意的是，如果是将结构体指针作为方法的接收者，那么必须要通过指针访问才会被视为该接口，比如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Point(%d, %d)&quot;</span>, v.X, v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实现了接口 <code>Stringer</code> 的是 <code>*Vertex</code>，而不是 <code>Vertex</code>。因此对于以下调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v := Vertex&#123;Y: <span class="number">100</span>&#125;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">fmt.Println(&amp;v)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span> <span class="number">100</span>&#125;</span><br><span class="line"><span class="function"><span class="title">Point</span><span class="params">(<span class="number">0</span>, <span class="number">100</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>因此很多时候，直接像这样初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v := &amp;Vertex&#123;Y: <span class="number">100</span>&#125; <span class="comment">// v 是结构体指针</span></span><br></pre></td></tr></table></figure>

<p>另一方面，duck typing 也使得 Go 可以用 <code>interface&#123;&#125;</code> 类型表示任意类型（类似 Java 的 <code>Object</code>）。由于 Golang（目前为止，1.17）没有泛型，使得它要对某种类型进行抽象，只能传递 <code>interface&#123;&#125;</code>，比如上述代码就限定了参数类型都是 <code>int</code>。比如在 C++ 中可以定义这样的接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryOperation</span> &#123;</span><br><span class="line">    <span class="function">T <span class="title">Calculate</span><span class="params">(T x, T y)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是 Golang 里，只能这么干了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BinaryOperation <span class="keyword">interface</span> &#123;</span><br><span class="line">  Calculate(x, y <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这么实现很蛋疼，因为虽然任何对象都可以转换成 <code>interace&#123;&#125;</code>，但是 <code>interface&#123;&#125;</code> 不能直接转换为其他类型，比如我基于新的 <code>BinaryOperation</code> 接口尝试写下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op AddOperation)</span></span> Calculate(x, y <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(x) + <span class="type">int</span>(y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译会报错：</p>
<blockquote>
<p>cannot convert x (type interface {}) to type int: need type assertion</p>
</blockquote>
<p>在 Golang 里需要进行类型断言，<code>t := i.(T)</code> 使得 <code>i</code> 的实际类型为 <code>T</code> 时将其转换成 <code>T</code> 类型的变量 <code>t</code>，如果类型不匹配将会触发 panic。而 <code>t, ok := i.(T)</code> 则可以避免 panic，类型不匹配时 <code>ok</code> 为 <code>false</code>。因此上述的实现可能变成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op AddOperation)</span></span> Calculate(x, y <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> x.(<span class="type">int</span>) + y.(<span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := AddOperation&#123;&#125;.Calculate(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">	fmt.Println(sum.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要支持多种类型，比如 <code>float</code>，就得利用<code>t, ok := i.(T)</code> 的形式了，但是可以用 <code>switch</code> 进行简化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(op AddOperation)</span></span> Calculate(x, y <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">switch</span> vx := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		<span class="keyword">if</span> vy, ok := y.(<span class="type">int</span>); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> vx + vy</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;x is int while y is not int&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">float64</span>:</span><br><span class="line">		<span class="keyword">if</span> vy, ok := y.(<span class="type">float64</span>); ok &#123;</span><br><span class="line">			<span class="keyword">return</span> vx + vy</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">&quot;x is int while y is not int&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;x is not int or float64&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是写起来还是很复杂……而且似乎不能写成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> vx, vy := x.(<span class="keyword">type</span>), y.(<span class="keyword">type</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>这种形式。</p>
<p>我可以理解这么做的原因，因为在没有类型检查的情况下向下转型很危险。C++ 的模板相对一般语言的泛型比较特殊，可以简单地写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AddOperation</span> &#123;</span><br><span class="line">  <span class="function">T <span class="title">add</span><span class="params">(T x, T y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但如果 <code>T</code> 的类型不支持 <code>operator+</code>，那么编译错误会非常庞大，这也是 C++20 引入 constrains 和 concepts 的原因。</p>
<h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>首先可以把 goroutine 当成轻量级线程（Fiber）来使用，这里为求方便，不去纠结名词细节，<strong>下文中若不特别说明，『线程』直接代指『goroutine』</strong>。总之起一个线程语法很简单，就是 <code>go</code> 后接函数调用，甚至可以是匿名函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">(s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(s);</span><br><span class="line">&#125;(<span class="string">&quot;hello&quot;</span>) <span class="comment">// 定义匿名函数 func (s string)，并传递参数 &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>因此类似其他语言，Golang 的线程同步也可以用锁和条件变量之类，具体见 <a target="_blank" rel="noopener" href="https://pkg.go.dev/sync@go1.17.1"><code>sync</code> 包</a>。一般更多地是推荐用 channel（我更喜欢用『管道』这个翻译）进行同步。Channel 其实就是个 FIFO 队列，对于一个 channel（假如为 <code>ch</code>）：</p>
<ul>
<li><code>&lt;- ch</code>：<strong>读操作</strong>。从 channel 中去取一个值，这个操作具有返回值，可以将其赋予一个变量，比如 <code>v := &lt;-ch</code>。</li>
<li><code>ch &lt;- v</code>：<strong>写操作</strong>。将值 <code>v</code> 放入管道。</li>
</ul>
<p>其实就类似 setter 和 getter 嘛。Channel 类型一般是 <code>chan T</code>，<code>T</code> 为 channel 元素的类型，直接用 <code>make(chan T)</code> 或 <code>make(chan T, n)</code> 的方式创建，指定 <code>n</code> 则代表 channel 带缓冲区（前提是 <code>n</code> 大于 0）。如果 channel 满了（或者没缓冲区），则写操作会阻塞直到读操作完成；如果 channel 为空，则读操作会阻塞直到 channel 有元素。这也是基于 channel 进行线程同步的基础。当然，对于单线程而言，这两个操作会直接触发 panic。就类似 Java 的 <code>ArrayBlockingQueue</code> 在队列为空时进行 <code>remove</code> 或者队列为满时进行 <code>add</code> 一样。但是 Golang channel 的特殊之处在于，多线程环境下会将 <code>remove</code>&#x2F;<code>add</code> 的语义改成 <code>take</code>&#x2F;<code>put</code> 的语义。</p>
<p>此外，channel 可以进行 <code>range</code> 操作，其实就是一个语法糖，代替在无限循环中进行读操作直到 channel 被关闭。对于一个 channel <code>ch</code>，关闭操作（<code>close(ch)</code>）意味着 <code>ch</code> 之后不再可用（无法进行读写，否则会 panic）。</p>
<p>Golang 还提供了 <code>select</code> 语句，这个名字基本上就意味着它和 I&#x2F;O 多路复用的场景。I&#x2F;O 多路复用本质上是可以同时等待多个文件描述符的事件（包括读就绪，写就绪，错误就绪）。<code>select</code> 即可以等待多个 channel 的读写事件。</p>
<p>这里举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eventLoop</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	cnt := <span class="number">1</span></span><br><span class="line">	flag := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> flag &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- cnt: <span class="comment">// 写事件，c 未满即可触发</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;Push %d\n&quot;</span>, cnt)</span><br><span class="line">			cnt++</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit: <span class="comment">// 读事件，quit 未空即可触发</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;Quit&quot;</span>)</span><br><span class="line">			flag = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">break</span> <span class="comment">// 跳出 select block</span></span><br><span class="line">		<span class="keyword">default</span>: <span class="comment">// 其他事件都未就绪时执行</span></span><br><span class="line">			time.Sleep(<span class="number">500</span> * time.Millisecond)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">300</span> * time.Millisecond)</span><br><span class="line">		&lt;-ch <span class="comment">// 取出元素，使得 eventLoop 的 case c &lt;- cnt 可以就绪</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">		quit &lt;- <span class="number">0</span> <span class="comment">// 触发 eventLoop 的 case &lt;-quit</span></span><br><span class="line">	&#125;()</span><br><span class="line">	eventLoop(ch, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次运行，可以发现输出结果有两种，一种是</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Push</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">Push</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">Quit</span></span><br></pre></td></tr></table></figure>

<p>另一种是</p>
<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Push</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">Push</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">Push</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">Quit</span></span><br></pre></td></tr></table></figure>

<p>原因是在 push 1 和 2 之后，<code>c &lt;- cnt</code> 和 <code>&lt;- quit</code> 都处于阻塞状态，因此进入 <code>default</code> 分支等待 500 ms。在此期间，子线程中的 <code>&lt;-ch</code> 和 <code>quit &lt;- 0</code> 使得两个事件都就绪了。此时 <code>select</code> 语句触发的顺序不是固定的。</p>
<p>在做等价二叉查找树练习的时候，发现一些 channel 被忽视的用法。Golang 不允许声明不被使用的变量，因此仅仅是想判断 channel 是否还有多余值时，可以用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> ch &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;There&#x27;s a value in channel&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，默认读取空 channel 时会阻塞，但是有一种非阻塞的方式，和之前的类似：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elem, ok := &lt;-ch <span class="comment">// 如果 ch 暂时没有元素，则 ok 为 false，elem 为 nil</span></span><br></pre></td></tr></table></figure>

<h2 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h2><p>总的来说 Go 的语言设计最大的优点就是作为一门广泛使用的非脚本语言，上手很快，就这一两天把 Tour of Go 过了遍，感觉直接上手写代码是足够了。</p>
<p>不过感觉也可以抽时间看看：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go">Effective Go</a>：感觉类似 Effective C++，各种 tips。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/xxjwxc/uber_go_guide_cn">Uber Go 语言编码规范</a>：也就是编码上最佳实践类型的。</li>
<li><a target="_blank" rel="noopener" href="https://golang.org/doc/gdb">Debugging Go Code with GDB</a>：毕竟除了 Java 系语言我都不用 IDE。另外官网推荐了 <a target="_blank" rel="noopener" href="https://github.com/go-delve/delve">dlv</a> 进行调试。</li>
</ul>
<p>当然，也有两个词典性质的网站：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://golang.org/ref/spec">Go 语言标准</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/std">Go 标准库</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/02/Pulsar-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/02/Pulsar-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%AE%A2%E9%98%85/" class="post-title-link" itemprop="url">Pulsar 源码阅读 - 消费者的订阅</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-02 20:58:55" itemprop="dateCreated datePublished" datetime="2021-09-02T20:58:55+08:00">2021-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前对 Pulsar 消费端的逻辑不太熟悉，但是一直有印象就是刚接触 Pulsar 时，不记得在哪看到 Pulsar 的消费模型是 push 的，而这点和 Kafka 的 pull 消费模型是完全不同的。之前对于 Kafka 的消费模型已经比较熟悉了，客户端发送 FETCH 请求，其中对于需要拉取（pull）数据的每个 partition，请求中会有一个 <code>partition_max_bytes</code> 字段限制该分区获取的最大字节数。而从 FETCH v3 开始，还有个总的 <code>max_bytes</code> 字段限制总的最大字节数来针对分区太多的场合。具体协议参见 <a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol#The_Messages_Fetch">Kafka Message Fetch</a>。</p>
<p>那么，Pulsar 采用的 push 消费模型是怎样的呢？为什么要采用 push 消费模型呢？带着这些问题，开始阅读源码，本文采用 Pulsar 2.8.0 的源码（实际是 master 分支），因此和之前的 release 版本可能有些许出入。</p>
<blockquote>
<p>本文在阅读源码时，会略去一些相对不核心的代码，必须合法性检查&#x2F;异常处理&#x2F;错误日志，此时会用 &#x2F;* … *&#x2F; 的风格来略去这一部分，而代码分析则统一使用 &#x2F;&#x2F; 注释风格。</p>
</blockquote>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>参见 Pulsar 官网文档 <a target="_blank" rel="noopener" href="http://pulsar.apache.org/docs/en/develop-binary-protocol/#consumer">Binary Protocol: Consumer</a>：</p>
<p><img src="http://pulsar.apache.org/docs/assets/binary-protocol-consumer.png" alt="consumer"></p>
<p>重点是客户端发送 Flow 请求，然后broker 回复消息。重点是流控的处理。这里先看看 <code>PulsarApi.proto</code> 中的定义（位于 <code>org.apache.pulsar.common.api.proto</code> 包）：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">CommandFlow</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint64</span> consumer_id       = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Max number of messages to prefetch, in addition</span></span><br><span class="line">    <span class="comment">// of any number previously specified</span></span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint32</span> messagePermits     = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了消费者 id 外，它只需要一个 permits 参数，表示 prefetch（提前获取）的最大消息数量。</p>
<p>再来看看文档的介绍。典型的消费者实现会在应用程序准备消费之前使用队列积累这些消息，在应用程序队列已经入队了半数以上消息时，消费者发送 permits 给 broker 来请求更多的消息（其数量等于队列大小的一半）。</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先给出一份最简单的客户端消费的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">        .serviceUrl(<span class="string">&quot;pulsar://localhost:6650&quot;</span>)</span><br><span class="line">        .build()) &#123;</span><br><span class="line">    Consumer&lt;<span class="type">byte</span>[]&gt; consumer = client.newConsumer()</span><br><span class="line">            .topic(<span class="string">&quot;my-topic&quot;</span>)</span><br><span class="line">            .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">            .subscribe();</span><br><span class="line">    Message&lt;<span class="type">byte</span>[]&gt; message = consumer.receive();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle the message</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (PulsarClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置目标主题和订阅名后，调用 <code>subscribe()</code> 方法订阅该主题，创建 <code>Consumer</code>;</li>
<li>consumer 调用 <code>receive()</code> 方法接收消息。</li>
</ol>
<blockquote>
<p>这里先简单介绍一下，客户端的实现代码位于 <code>pulsar-client</code> 模块，而接口定义则位于 <code>pulsar-client-api</code> 模块，一些（broker 和客户端等）公用的类位于 <code>pulsar-common</code> 模块。而各模块均位于同名目录下。</p>
<p>另外 Pulsar 所有的同步调用 API 都只是简单等待异步调用 API（方法名后缀是 Async）返回的 CompletableFuture<T> 对象完成，其返回值为 T。</T></p>
</blockquote>
<h3 id="消费者的创建"><a href="#消费者的创建" class="headerlink" title="消费者的创建"></a>消费者的创建</h3><p>创建 <code>PulsarClient</code> 时实际上是创建了 <code>PulsarClientImpl</code> 对象，其中 <code>newConsumer</code> 方法是创建一个 builder 用于链式调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumerBuilder&lt;<span class="type">byte</span>[]&gt; newConsumer() &#123;</span><br><span class="line">    <span class="comment">// 另外从这里也可以看到默认的 consumer 是使用 bytes schema</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsumerBuilderImpl</span>&lt;&gt;(<span class="built_in">this</span>, Schema.BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 builder 的方法就不仔细阅读了，主要是对参数进行必要的验证后设置相应字段，比如必要的是主题名和订阅名，都保存在 <code>conf</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBuilderImpl&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> ConsumerConfigurationData&lt;T&gt; conf;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerConfigurationData&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; topicNames = Sets.newTreeSet();</span><br><span class="line"><span class="keyword">private</span> String subscriptionName;</span><br></pre></td></tr></table></figure>

<p><code>ConsumerBuilderImpl#subscribeAsync</code> 本身只是对 <code>conf</code> 的一些参数进行合法性校验，对于只设置主题名和订阅名的情况只是验证这两项配置是否存在，最后实际上是调用 <code>PulsarClientImpl#subscribeAsync</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">interceptorList</span> <span class="operator">=</span>= <span class="literal">null</span> || interceptorList.size() == <span class="number">0</span> ?</span><br><span class="line">        client.subscribeAsync(conf, schema, <span class="literal">null</span>) : <span class="comment">// 默认 intercepto 为 null</span></span><br><span class="line">        client.subscribeAsync(conf, schema, <span class="keyword">new</span> <span class="title class_">ConsumerInterceptors</span>&lt;&gt;(interceptorList));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PulsarClientImpl&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">subscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行一些合法性检查（这里略去代码），包括：</span></span><br><span class="line">    <span class="comment">// 1. client 状态为 Open</span></span><br><span class="line">    <span class="comment">// 2. conf != null</span></span><br><span class="line">    <span class="comment">// 3. conf.topicNames 的每个主题名的格式必须合法</span></span><br><span class="line">    <span class="comment">// 4. 对于 compacted topic，主题必须为 persistent，订阅模式必须为 Exclusive 或者 Failover</span></span><br><span class="line">    <span class="comment">// 5. 对于 ConsumerEventListener，订阅模式必须为 Failover</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conf.getTopicsPattern() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 正则订阅，此时禁止设置具体的主题名字（topicNames）</span></span><br><span class="line">        <span class="keyword">if</span> (!conf.getTopicNames().isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                .failedFuture(<span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Topic names list must be null when use topicsPattern&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> patternTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conf.getTopicNames().size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 单主题订阅</span></span><br><span class="line">        <span class="keyword">return</span> singleTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 多主题订阅</span></span><br><span class="line">        <span class="keyword">return</span> multiTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为求简单，还是只看单主题订阅的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">singleTopicSubscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> preProcessSchemaBeforeSubscribe(<span class="built_in">this</span>, schema, conf.getSingleTopic())</span><br><span class="line">        .thenCompose(schemaClone -&gt; doSingleTopicSubscribeAsync(conf, schemaClone, interceptors));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的先后顺序是：</p>
<ol>
<li>调用 <code>preProcessSchemaBeforeSubscribe</code>，此时会对 schema 进行预处理，必须注册 schema。</li>
<li>对前一步得到的 schemaClone 传入 <code>doSingleTopicSubscribeAsync</code>。</li>
</ol>
<p>这里关注第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">doSingleTopicSubscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Consumer&lt;T&gt;&gt; consumerSubscribedFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> conf.getSingleTopic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先取得 topic 的 metadata（目前仅包含 partitions 字段表示分区数量）</span></span><br><span class="line">    getPartitionedTopicMetadata(topic).thenAccept(metadata -&gt; &#123;</span><br><span class="line">        <span class="comment">/* debug 日志 ... */</span></span><br><span class="line">        ConsumerBase&lt;T&gt; consumer;</span><br><span class="line">        <span class="comment">// 从 executor provider（包含一组 executors）中分配一个 executor</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">listenerThread</span> <span class="operator">=</span> externalExecutorProvider.getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (metadata.partitions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 多分区订阅，创建的是 MultiTopicsConsumerImpl</span></span><br><span class="line">            consumer = MultiTopicsConsumerImpl.createPartitionedConsumer(PulsarClientImpl.<span class="built_in">this</span>, conf,</span><br><span class="line">                listenerThread, consumerSubscribedFuture, metadata.partitions, schema, interceptors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 单分区订阅，创建的是 ConsumerImpl</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> TopicName.getPartitionIndex(topic);</span><br><span class="line">            consumer = ConsumerImpl.newConsumerImpl(PulsarClientImpl.<span class="built_in">this</span>, topic, conf, listenerThread, partitionIndex, <span class="literal">false</span>,</span><br><span class="line">                    consumerSubscribedFuture,<span class="literal">null</span>, schema, interceptors,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* createTopicIfDoesNotExist */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumers.add(consumer); <span class="comment">// 将创建的 consumer 加入到 client 内部的 consumers 中</span></span><br><span class="line">    &#125;).exceptionally(<span class="comment">/* 异常处理... */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumerSubscribedFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多分区订阅和多主题订阅本质上是一样的，都是使用 <code>MultiTopicsConsumerImpl</code> 管理多个主题（因为 Pulsar 中分区只不过是一个包含后缀 <code>-partition-&lt;n&gt;</code> 的主题）。</p>
</blockquote>
<p>这里还是关注单分区订阅，<code>ConsumerImpl.newConsumerImpl(...)</code> 只是将参数原封不动传给其构造方法，构造方法包括了 consumer 内部一些字段的初始化，因此比较长，我们还是只关注重点，那就是最简洁的订阅会和 broker 有什么交互。实际上这部分逻辑在构造方法最后，调用 <code>grabCnx</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">grabCnx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.connectionHandler.grabCnx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p><code>connectionHandler</code>（下文简称 connection）的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.connectionHandler = <span class="keyword">new</span> <span class="title class_">ConnectionHandler</span>(<span class="built_in">this</span>,</span><br><span class="line">		        <span class="keyword">new</span> <span class="title class_">BackoffBuilder</span>()</span><br><span class="line">                        <span class="comment">// 设置 BackOff 所需要的参数，参数对应 client 的配置为：</span></span><br><span class="line">                        <span class="comment">// initialTime: 默认 100 ms，ClientBuilder#startingBackoffInternal</span></span><br><span class="line">                        <span class="comment">// max: 默认 60 s，ClientBuilder#maxBackoffInterval</span></span><br><span class="line">                        <span class="comment">// mandatoryStop：固定为 0 ms</span></span><br><span class="line">                        <span class="comment">/* ... */</span></span><br><span class="line">                        .create(),</span><br><span class="line">        <span class="built_in">this</span>); <span class="comment">// 将 ConsumerImpl 对象自身传入 ConnectionHandler 的构造方法</span></span><br></pre></td></tr></table></figure>

<p>这里简单说下 <code>BackOff</code> 对象。查看 backoff 在 <code>ConnectionHandler</code> 中的使用，可以看到主要是在重连活着关闭连接时用 <code>next()</code> 方法来得到建立连接时对应的 timeout，因为连接对应的是 client，所以这里用的都是 client 的配置。</p>
<p>回到正题，继续看 <code>ConnectionHandler#grabCnx</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">grabCnx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CLIENT_CNX_UPDATER.get(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经连接成功了，无视这次调用</span></span><br><span class="line">        <span class="comment">/* warn 日志... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidStateForReconnection()) &#123;</span><br><span class="line">        <span class="comment">// 若 connection 状态不可用于重连（比如为 Closed），则无视这次调用</span></span><br><span class="line">        <span class="comment">/* info 日志... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 取得主题对应的连接</span></span><br><span class="line">        state.client.getConnection(state.topic) <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 2.1 若连接成功，则调用 connectionOpened</span></span><br><span class="line">                .thenAccept(cnx -&gt; connection.connectionOpened(cnx)) <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 2.2 若连接失败，则调用 handleConnectionError，会进行重连操作</span></span><br><span class="line">                .exceptionally(<span class="built_in">this</span>::handleConnectionError);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">/* warn 日志... */</span></span><br><span class="line">        reconnectLater(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是看看连接成功的处理。注意到 <code>ConsumerImpl</code> 是实现了 <code>Connection</code> 接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ConsumerBase</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ConnectionHandler</span>.Connection &#123;</span><br></pre></td></tr></table></figure>

<p>然后注意到构造 connection 时用的 <code>Connection</code> 接口就是 <code>ConsumerImpl</code> 对象自己，因此调用的是 <code>ConsumerImpl#connectionOpened</code>。</p>
<p>实际上这一小节的内容同样也适用于生产者以及多主题消费者，它们对应的类都实现了 <code>Connection</code> 接口，只需要实现各自的回调即可。</p>
<h3 id="连接成功的回调"><a href="#连接成功的回调" class="headerlink" title="连接成功的回调"></a>连接成功的回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectionOpened</span><span class="params">(<span class="keyword">final</span> ClientCnx cnx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == State.Closing || getState() == State.Closed) &#123;</span><br><span class="line">        <span class="comment">/* 执行一些清理工作... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 client 到 connection，前面 grabCnx() 检查的 CLIENT_CNX_UPDATER 也会在这里设置</span></span><br><span class="line">    setClientCnx(cnx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* info 日志表示准备订阅对应主题... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">requestId</span> <span class="operator">=</span> client.newRequestId();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> currentSize;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// incomingMessages 为客户端缓存收到消息的队列（接收队列），这里先取得其大小</span></span><br><span class="line">        currentSize = incomingMessages.size();</span><br><span class="line">        <span class="comment">// 清空接收队列，取得第一条消息的 id（也就是消费者第一条没有传给应用程序的消息的 id）</span></span><br><span class="line">        startMessageId = clearReceiverQueue();</span><br><span class="line">        <span class="comment">// 清空 DLQ</span></span><br><span class="line">        <span class="keyword">if</span> (possibleSendToDeadLetterTopicMessages != <span class="literal">null</span>) &#123;</span><br><span class="line">            possibleSendToDeadLetterTopicMessages.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDurable</span> <span class="operator">=</span> subscriptionMode == SubscriptionMode.Durable;</span><br><span class="line">    <span class="type">MessageIdData</span> <span class="variable">startMessageIdData</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isDurable) &#123;</span><br><span class="line">        <span class="comment">// 对持久化订阅，那么将 startMessageIdData 置为 null，因为 broker 负责告诉客户端重新开始消费的消息 id</span></span><br><span class="line">        startMessageIdData = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startMessageId != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对非持久化订阅（常用于 Reader API），则要用我们之前取得的第一条消息的 id</span></span><br><span class="line">        MessageIdData.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> MessageIdData.newBuilder();</span><br><span class="line">        builder.setLedgerId(startMessageId.getLedgerId());</span><br><span class="line">        builder.setEntryId(startMessageId.getEntryId());</span><br><span class="line">        <span class="keyword">if</span> (startMessageId <span class="keyword">instanceof</span> BatchMessageIdImpl) &#123;</span><br><span class="line">            builder.setBatchIndex(startMessageId.getBatchIndex());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startMessageIdData = builder.build();</span><br><span class="line">        builder.recycle();</span><br><span class="line">    &#125; <span class="comment">// else: 非持久化订阅，但是缓存队列里没有消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得 schema</span></span><br><span class="line">    <span class="type">SchemaInfo</span> <span class="variable">si</span> <span class="operator">=</span> schema.getSchemaInfo();</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">null</span> &amp;&amp; (SchemaType.BYTES == si.getType() || SchemaType.NONE == si.getType())) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t set schema for Schema.BYTES</span></span><br><span class="line">        si = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 CommandSubscribe 并发送，具体字段就不贴出来了</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">request</span> <span class="operator">=</span> Commands.newSubscribe(<span class="comment">/* ... */</span>);</span><br><span class="line">    cnx.sendRequestWithId(request, requestId).thenRun(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// case 1 发送成功</span></span><br><span class="line">        <span class="keyword">synchronized</span> (ConsumerImpl.<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 State 是 Uninitialized，Connecting，RegisteringSchema，则将其改为 Ready</span></span><br><span class="line">            <span class="keyword">if</span> (changeToReadyState()) &#123;</span><br><span class="line">                <span class="comment">// 将 availablePermits 置为 0</span></span><br><span class="line">                consumerIsReconnectedToBroker(cnx, currentSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其它 state 比如 Failed 则代表异常状态，此时将 state 置为 Closed</span></span><br><span class="line">                setState(State.Closed);</span><br><span class="line">                deregisterFromClientCnx(); <span class="comment">// 将 consumer 和 connection 解绑</span></span><br><span class="line">                client.cleanupConsumer(<span class="built_in">this</span>); <span class="comment">// 将 consumer 从 client 中移除</span></span><br><span class="line">                cnx.channel().close(); <span class="comment">// 关闭连接</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重制 BackOff，因为之前可能重连过导致 BackOff 内部状态发生变化，</span></span><br><span class="line">        resetBackoff();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 subscribeFuture 可能多次 complete，因此这里判断是否为第一次 complete</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstTimeConnect</span> <span class="operator">=</span> subscribeFuture.complete(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 如果 receiverQueueSize（内部接收队列的大小）大于 0，则代表 consumer 有缓冲区可以接收消息。</span></span><br><span class="line">        <span class="comment">// 此时，会将接收队列大小的一半作为 permits 发送 Flow 请求</span></span><br><span class="line">        <span class="comment">// 但还有一种情况也不会发送，也就是满足以下三个条件：</span></span><br><span class="line">        <span class="comment">// 1. 第一次连接完成</span></span><br><span class="line">        <span class="comment">// 2. 当前 consumer 是一个子 consumer</span></span><br><span class="line">        <span class="comment">// 3. 订阅类型是持久化（NOTE：这个条件可能是早期错误，见 https://github.com/apache/pulsar/pull/3960）</span></span><br><span class="line">        <span class="comment">// 因为当 consumer 是子 consumer 的时候，它归属于 MultiTopicsConsumerImpl，也就是多分区/主题的 consumer</span></span><br><span class="line">        <span class="comment">// MultiTopicsConsumerImpl 会在所有子 consumer 连接完成后再调用 startReceivingMessages</span></span><br><span class="line">        <span class="comment">// 从而对每个子 consumer 调用 increaseAvailablePermits</span></span><br><span class="line">        <span class="keyword">if</span> (!(firstTimeConnect &amp;&amp; hasParentConsumer &amp;&amp; isDurable) &amp;&amp; conf.getReceiverQueueSize() != <span class="number">0</span>) &#123;</span><br><span class="line">            increaseAvailablePermits(cnx, conf.getReceiverQueueSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally((e) -&gt; &#123;<span class="comment">/* 异常处理... */</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到连接成功后，主要是发送 CommandSubscribe（订阅命令），broker 处理成功后，consumer 就处于 Ready 状态，并且会发送 Flow 请求携带 permits 为接收队列大小的一半。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="comment">// availablePermits 增加 delta，代表可用的接收队列的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过了阈值（默认一半接收队列大小）且没有调用 pause，则将其清零，并将清零前的值构造 Flow 命令发送</span></span><br><span class="line">    <span class="keyword">while</span> (available &gt;= receiverQueueRefillThreshold &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 Flow 命令的定义和发送：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">CommandFlow</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint64</span> consumer_id       = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先拉取的消息数量，也称为 permits</span></span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint32</span> messagePermits     = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendFlowPermitsToBroker</span><span class="params">(ClientCnx cnx, <span class="type">int</span> numMessages)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅当连接未断开且消息数大于 0 才会发送 Flow 请求，因为 broker 收到 permits 为 0 的请求会直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (cnx != <span class="literal">null</span> &amp;&amp; numMessages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages), cnx.ctx().voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broker-处理"><a href="#Broker-处理" class="headerlink" title="Broker 处理"></a>Broker 处理</h2><h3 id="CommandSubscribe-处理"><a href="#CommandSubscribe-处理" class="headerlink" title="CommandSubscribe 处理"></a>CommandSubscribe 处理</h3><p>broker 对 TCP 协议的处理位于 <code>org.apache.pulsar.broker.service</code> 包的 <code>ServerCnx</code> 类。对于 consumer 而言，比较独有的就是 <code>CommandSubscribe</code> 和 <code>CommandFlow</code>。</p>
<p>因为代码比较长，所以日志相关代码均略过，不特意用 <code>/* xxx... */</code> 说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleSubscribe</span><span class="params">(<span class="keyword">final</span> CommandSubscribe subscribe)</span> &#123;</span><br><span class="line">    <span class="comment">/* 略去相关字段的解析... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否具有 CONSUME 权限</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; isAuthorizedFuture = isTopicOperationAllowed(</span><br><span class="line">            topicName,</span><br><span class="line">            subscriptionName,</span><br><span class="line">            TopicOperation.CONSUME</span><br><span class="line">    );</span><br><span class="line">    isAuthorizedFuture.thenApply(isAuthorized -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthorized) &#123;</span><br><span class="line">            <span class="comment">/* 验证 metadata 字段...*/</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 这里的 Consumer 是 broker consumer，对应每个 client consumer</span></span><br><span class="line">            CompletableFuture&lt;Consumer&gt; consumerFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">            CompletableFuture&lt;Consumer&gt; existingConsumerFuture = consumers.putIfAbsent(consumerId,</span><br><span class="line">                    consumerFuture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (existingConsumerFuture != <span class="literal">null</span>) &#123; <span class="comment">// 已经创建过 broker consumer</span></span><br><span class="line">                <span class="keyword">if</span> (existingConsumerFuture.isDone() &amp;&amp; !existingConsumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">                    <span class="comment">// 创建完成则直接发送成功的响应</span></span><br><span class="line">                    commandSender.sendSuccessResponse(requestId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 之前已经有相同 consumerId 的 subscribe 请求，这是因为 client timeout 小于 broker timeout，</span></span><br><span class="line">                    <span class="comment">// 因此 client 发生重试，此时需要等待之前的 consumer future 完成</span></span><br><span class="line">                    <span class="type">ServerError</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!existingConsumerFuture.isDone()) &#123;</span><br><span class="line">                        <span class="comment">// 前一个 subscribe 请求还未完成，直接返回 ServiceNotReady</span></span><br><span class="line">                        error = ServerError.ServiceNotReady;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 前一个 subscribe 请求异常完成，则返回同样的错误码并将其移除 cache 避免下次重新进入此分支</span></span><br><span class="line">                        error = getErrorCode(existingConsumerFuture);</span><br><span class="line">                        consumers.remove(consumerId, existingConsumerFuture);</span><br><span class="line">                    &#125;</span><br><span class="line">                    commandSender.sendErrorResponse(requestId, error,</span><br><span class="line">                            <span class="string">&quot;Consumer is already present on the connection&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否自动创建 topic，forceTopicCreation 为 client 填充的字段（NOTE：实际上永远为 true）</span></span><br><span class="line">            <span class="comment">// service 对象则是通过配置或者 system topic 的配置来判断是否允许自动创建 topic</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">createTopicIfDoesNotExist</span> <span class="operator">=</span> forceTopicCreation</span><br><span class="line">                    &amp;&amp; service.isAllowAutoTopicCreation(topicName.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前 broker 获取或创建 Topic 对象</span></span><br><span class="line">            service.getTopic(topicName.toString(), createTopicIfDoesNotExist)</span><br><span class="line">                    .thenCompose(optTopic -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!optTopic.isPresent()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                                    .failedFuture(<span class="keyword">new</span> <span class="title class_">TopicNotFoundException</span>(</span><br><span class="line">                                            <span class="string">&quot;Topic &quot;</span> + topicName + <span class="string">&quot; does not exist&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="type">Topic</span> <span class="variable">topic</span> <span class="operator">=</span> optTopic.get();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 对于 durable cursor 而言，如果该订阅不存在且不允许订阅自动创建，subscribe 会失败</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">rejectSubscriptionIfDoesNotExist</span> <span class="operator">=</span> isDurable</span><br><span class="line">                            &amp;&amp; !service.isAllowAutoSubscriptionCreation(topicName.toString())</span><br><span class="line">                            &amp;&amp; !topic.getSubscriptions().containsKey(subscriptionName);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (rejectSubscriptionIfDoesNotExist) &#123;</span><br><span class="line">                            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                                    .failedFuture(</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">SubscriptionNotFoundException</span>(</span><br><span class="line">                                                    <span class="string">&quot;Subscription does not exist&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 若带有 schema 则先检查 schema 兼容性，最后都会调用 Topic#subscribe</span></span><br><span class="line">                        <span class="keyword">if</span> (schema != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> topic.addSchemaIfIdleOrCheckCompatible(schema)</span><br><span class="line">                                    .thenCompose(v -&gt; topic.subscribe(<span class="comment">/* ... */</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> topic.subscribe(<span class="comment">/* ... */</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .thenAccept(consumer -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (consumerFuture.complete(consumer)) &#123;</span><br><span class="line">                            commandSender.sendSuccessResponse(requestId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果 consumerFuture 已经完成，则当前 consumer 是 client timeout 重新创建的 consumer</span></span><br><span class="line">                            <span class="comment">// 此时需要关闭 consumer 并移除这个 future</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                consumer.close();</span><br><span class="line">                                log.info(<span class="string">&quot;[&#123;&#125;] Cleared consumer created after timeout on client side &#123;&#125;&quot;</span>,</span><br><span class="line">                                        remoteAddress, consumer);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (BrokerServiceException e) &#123;</span><br><span class="line">                                log.warn(</span><br><span class="line">                                        <span class="string">&quot;[&#123;&#125;] Error closing consumer created&quot;</span></span><br><span class="line">                                                + <span class="string">&quot; after timeout on client side &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">                                        remoteAddress, consumer, e.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                            consumers.remove(consumerId, consumerFuture);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .exceptionally(exception -&gt; &#123;</span><br><span class="line">                        <span class="comment">/* 根据异常严重性打印对应等级的日志... */</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回错误码移除订阅失败过程中添加的 consumer</span></span><br><span class="line">                        <span class="keyword">if</span> (consumerFuture.completeExceptionally(exception)) &#123;</span><br><span class="line">                            commandSender.sendErrorResponse(requestId,</span><br><span class="line">                                    BrokerServiceException.getClientErrorCode(exception),</span><br><span class="line">                                    exception.getCause().getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        consumers.remove(consumerId, consumerFuture);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 鉴权失败</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Client is not authorized to subscribe&quot;</span>;</span><br><span class="line">            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123; <span class="comment">// 鉴权抛出异常</span></span><br><span class="line">        commandSender.sendErrorResponse(requestId, ServerError.AuthorizationError, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来，处理 subscribe 请求核心调用是：</p>
<ul>
<li><code>BrokerService#getTopic</code>：获取当前 broker 所拥有（own）的 <code>Topic</code> 对象</li>
<li><code>Topic#subscribe</code>：在 <code>Topic</code> 对象中创建对应的订阅，并得到 <code>Consumer</code> 对象</li>
</ul>
<p>其中 <code>Topic</code> 和 <code>Consumer</code> 是 broker 端对 topic 和 consumer 的抽象，负责管理对应的资源。均位于 <code>org.apache.pulsar.broker.service</code> 包下。这里我们重点看 <code>PersistentTopic#subscribe</code>。</p>
<h3 id="PersistentTopic-subscribe"><a href="#PersistentTopic-subscribe" class="headerlink" title="PersistentTopic#subscribe"></a>PersistentTopic#subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Consumer&gt; <span class="title function_">subscribe</span><span class="params">(<span class="comment">/* ... */</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有 Failover 和 Exclusive 模式才支持读取 compacted topic</span></span><br><span class="line">    <span class="keyword">if</span> (readCompacted &amp;&amp; !(subType == SubType.Failover || subType == SubType.Exclusive)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FutureUtil.failedFuture(<span class="keyword">new</span> <span class="title class_">NotAllowedException</span>(</span><br><span class="line">                <span class="string">&quot;readCompacted only allowed on failover or exclusive subscriptions&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 NamespaceService 检查 topic owner 是否为当前 broker，若不是则该 future 会以 ServiceUnitNotReady 异常完成</span></span><br><span class="line">    <span class="keyword">return</span> brokerService.checkTopicNsOwnership(getName()).thenCompose(__ -&gt; &#123;</span><br><span class="line">        <span class="comment">/* 进行一系列检查... （这里略去具体代码，仅用注释说明） */</span></span><br><span class="line">        <span class="comment">// 1. 若 broker 未启用订阅复制，则仅仅是打印 warn 日志，防止 broker 禁止跨地域复制后 consumer 订阅失败</span></span><br><span class="line">        <span class="comment">// 2. 检查 broker 是否支持 Key_Shared 订阅模式</span></span><br><span class="line">        <span class="comment">// 3. 检查非 system topic（以 __change_events 结尾）的 topic 级别配置是否支持该订阅类型</span></span><br><span class="line">        <span class="comment">// 4. 检查订阅名是否为空</span></span><br><span class="line">        <span class="comment">// 5. 检查协议是否支持 batch 消息</span></span><br><span class="line">        <span class="comment">// 6. 禁止对前缀是跨地域复制的前缀（默认 pulsar.repl）或者 pulsar.dedup 创建订阅</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用连接地址作为 key，检查 consumer 对应的 RateLimiter 是否存在，限制重连次数，因为重连的连接地址是相同的</span></span><br><span class="line">        <span class="comment">// 参考 https://github.com/apache/pulsar/pull/2977</span></span><br><span class="line">        <span class="keyword">if</span> (cnx.clientAddress() != <span class="literal">null</span> &amp;&amp; cnx.clientAddress().toString().contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">            SubscribeRateLimiter.<span class="type">ConsumerIdentifier</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscribeRateLimiter</span>.ConsumerIdentifier(</span><br><span class="line">                    cnx.clientAddress().toString().split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], consumerName, consumerId);</span><br><span class="line">            <span class="keyword">if</span> (subscribeRateLimiter.isPresent() &amp;&amp; (!subscribeRateLimiter.get().subscribeAvailable(consumer)</span><br><span class="line">                    || !subscribeRateLimiter.get().tryAcquire(consumer))) &#123;</span><br><span class="line">                <span class="comment">/* warn 日志... */</span></span><br><span class="line">                <span class="keyword">return</span> FutureUtil.failedFuture(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">NotAllowedException</span>(<span class="string">&quot;Subscribe limited by subscribe rate limit per consumer.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当 topic 被删除或关闭，或者 producer 写消息失败时都会标记为 fence 状态，此时禁止订阅</span></span><br><span class="line">            <span class="keyword">if</span> (isFenced) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;[&#123;&#125;] Attempting to subscribe to a fenced topic&quot;</span>, topic);</span><br><span class="line">                <span class="keyword">return</span> FutureUtil.failedFuture(<span class="keyword">new</span> <span class="title class_">TopicFencedException</span>(<span class="string">&quot;Topic is temporarily unavailable&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际上是增加 usageCount（连接的 producer 和 consumer 总数），传参数是为了打印 debug 日志</span></span><br><span class="line">            handleConsumerAdded(subscriptionName, consumerName);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取（或创建）订阅</span></span><br><span class="line">        CompletableFuture&lt;? <span class="keyword">extends</span> <span class="title class_">Subscription</span>&gt; subscriptionFuture = isDurable ? <span class="comment">//</span></span><br><span class="line">                getDurableSubscription(subscriptionName, initialPosition, startMessageRollbackDurationSec,</span><br><span class="line">                        replicatedSubscriptionState)</span><br><span class="line">                : getNonDurableSubscription(subscriptionName, startMessageId, initialPosition,</span><br><span class="line">                startMessageRollbackDurationSec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于持久化订阅，可以获取最大的未确认的消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxUnackedMessages</span> <span class="operator">=</span> isDurable</span><br><span class="line">                ? getMaxUnackedMessagesOnConsumer()</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Consumer&gt; future = subscriptionFuture.thenCompose(subscription -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建 Consumer 对象并加入到对应的订阅中</span></span><br><span class="line">            <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">            <span class="keyword">return</span> addConsumerToSubscription(subscription, consumer).thenCompose(v -&gt; &#123;</span><br><span class="line">                checkBackloggedCursors();</span><br><span class="line">                <span class="keyword">if</span> (!cnx.isActive()) &#123;</span><br><span class="line">                    <span class="comment">// 连接已经断开，则需要关闭 consumer</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        consumer.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokerServiceException e) &#123;</span><br><span class="line">                        <span class="comment">/* ... */</span></span><br><span class="line">                        <span class="comment">// 减少 usageCount，对应 handleConsumerAdded</span></span><br><span class="line">                        decrementUsageCount(); </span><br><span class="line">                        <span class="keyword">return</span> FutureUtil.failedFuture(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    decrementUsageCount();</span><br><span class="line">                    <span class="keyword">return</span> FutureUtil.failedFuture(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">BrokerServiceException</span>(<span class="string">&quot;Connection was closed while the opening the cursor &quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 连接仍存活，则继续检查复制订阅的状态，至此完成整个订阅</span></span><br><span class="line">                    checkReplicatedSubscriptionControllerState();</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(consumer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.exceptionally(ex -&gt; &#123;</span><br><span class="line">            decrementUsageCount();</span><br><span class="line">            <span class="comment">/* 打印日志... */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心流程：</p>
<ol>
<li>获取 <code>Subscription</code>（broker 对订阅的抽象），若不存在则创建。</li>
<li>创建 <code>Consumer</code>（broker 对消费者的抽象）后加入订阅。</li>
</ol>
<p>这里不进一步阅读 <code>Subscription</code> 代码。简单说，在创建订阅时，对于持久化（durable）订阅（<code>PersistentSubscription</code>），创建时会打开一个 cursor，对应于 <code>PersistentTopic</code> 内部的 ledger，若 cursor 不存在则创建；对于非持久化（non-durable）订阅（<code>NonPersistentSubscription</code>），则是直接内存中维护消息 id（<code>MessageIdImpl</code>）。两者最大的区别是，持久化订阅在 cursor 已存在时，直接打开 cursor，而无视掉 CommandSubscribe 中的消息 id。</p>
<p>至于将 consumer 加入订阅，实际上是根据订阅类型创建对应的 dispatcher（<code>Dispatcher</code>），这里以默认的 Exclusive 订阅为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (consumer.subType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Exclusive:</span><br><span class="line">        <span class="keyword">if</span> (dispatcher == <span class="literal">null</span> || dispatcher.getType() != SubType.Exclusive) &#123;</span><br><span class="line">            previousDispatcher = dispatcher;</span><br><span class="line">            dispatcher = useStreamingDispatcher</span><br><span class="line">                    ? <span class="keyword">new</span> <span class="title class_">PersistentStreamingDispatcherSingleActiveConsumer</span>(</span><br><span class="line">                            cursor, SubType.Exclusive, <span class="number">0</span>, topic, <span class="built_in">this</span>)</span><br><span class="line">                    : <span class="keyword">new</span> <span class="title class_">PersistentDispatcherSingleActiveConsumer</span>(</span><br><span class="line">                            cursor, SubType.Exclusive, <span class="number">0</span>, topic, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<a target="_blank" rel="noopener" href="https://github.com/apache/pulsar/pull/9056">https://github.com/apache/pulsar/pull/9056</a> 引入了 streaming dispatcher。</p>
</blockquote>
<p>然后将 consumer 加入 dispatcher：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dispatcher.addConsumer(consumer);</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokerServiceException brokerServiceException) &#123;</span><br><span class="line">    <span class="keyword">return</span> FutureUtil.failedFuture(brokerServiceException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅里实际负责消息分发的就是 dispatcher。</p>
<h3 id="CommandFlow"><a href="#CommandFlow" class="headerlink" title="CommandFlow"></a>CommandFlow</h3><p>首先是 <code>ServerCnx</code> 第一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleFlow</span><span class="params">(CommandFlow flow)</span> &#123;</span><br><span class="line">    checkArgument(state == State.Connected); <span class="comment">// 必须是 Connected 状态</span></span><br><span class="line">    CompletableFuture&lt;Consumer&gt; consumerFuture = consumers.get(flow.getConsumerId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 consumer 已经创建成功，则直接交给 Consumer 处理</span></span><br><span class="line">    <span class="keyword">if</span> (consumerFuture != <span class="literal">null</span> &amp;&amp; consumerFuture.isDone() &amp;&amp; !consumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> consumerFuture.getNow(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (consumer != <span class="literal">null</span>) &#123;</span><br><span class="line">            consumer.flowPermits(flow.getMessagePermits());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后递交给 <code>Consumer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flowPermits</span><span class="params">(<span class="type">int</span> additionalNumberOfMessages)</span> &#123;</span><br><span class="line">    checkArgument(additionalNumberOfMessages &gt; <span class="number">0</span>); <span class="comment">// permits 必须大于 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 对于只支持 individual ack 的订阅类型，检查没有确认的（unacked）消息数量</span></span><br><span class="line">    <span class="keyword">if</span> (shouldBlockConsumerOnUnackMsgs() &amp;&amp; unackedMessages &gt;= maxUnackedMessages) &#123;</span><br><span class="line">        blockedConsumerOnUnackedMsgs = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oldPermits;</span><br><span class="line">    <span class="keyword">if</span> (!blockedConsumerOnUnackedMsgs) &#123;</span><br><span class="line">        <span class="comment">// 1.1 正常情况下，增加 messagePermits，然后交给 subscription 处理</span></span><br><span class="line">        oldPermits = MESSAGE_PERMITS_UPDATER.getAndAdd(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">        subscription.consumerFlow(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.2 如果 unacked 消息数量超过限制，则更新 permitsReceivedWhileConsumerBlocked 记录因此阻塞的 flow permits</span></span><br><span class="line">        oldPermits = PERMITS_RECEIVED_WHILE_CONSUMER_BLOCKED_UPDATER.getAndAdd(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可见，更新完 <code>Consumer</code> 内部的 <code>messagePermits</code> 后，交由对应的 <code>Subscription</code> 对象处理。这里仅看 <code>PersistentSubscription</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerFlow</span><span class="params">(Consumer consumer, <span class="type">int</span> additionalNumberOfMessages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastConsumedFlowTimestamp = System.currentTimeMillis();</span><br><span class="line">    dispatcher.consumerFlow(consumer, additionalNumberOfMessages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是传递给 dispatcher。因此实际的处理是由 dispatcher 完成的。至于 dispatcher 的实现就留给下一篇进行讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 client 和 broker 创建消费者订阅某个 topic 的流程。Client 端的实现包含了一些和生产者通用的部分，也就是建立连接的部分。连接成功后的回调，消费者会先发一个 subscribe 命令注册自己，注册成功后发送 flow 请求，携带 permits，其值为内部缓冲区大小的一半（对于无缓冲区的 zero queue consumer 例外）。</p>
<p>Broker 端处理相对复杂，但本质是对一些概念进行了抽象。消费者对应 <code>Consumer</code>，每个消费者则包含一个订阅 <code>Subscription</code>。而 topic 对应 <code>Topic</code>，消费者发送 subscribe 命令时会在 <code>Topic</code> 里创建 <code>Subscription</code>，因为每个 topic 可以对应多个订阅，创建完成后根据消费者的订阅类型创建对应的 <code>Dispatcher</code>。通常意义上一个订阅可以对应多个消费者，但实际上真正维护这组消费者的不是 <code>Subscription</code> 而是 <code>Dispatcher</code>，订阅本身更多的是维护 cursor（消费进度），比如持久化订阅（<code>PersistentSubscription</code>）就会创建一个 durable cursor。而 client 端的 Flow 请求，最终也是 <code>Dispatcher</code> 来处理的。</p>
<p>最后解答最初提出的问题，push 和 pull 的区别，以及为什么 Pulsar 是 push 消费模型。Kafka 的消费者是发送 FETCH 请求给 broker，然后 broker 对应的 FETCH 响应里包含读取的消息。而 Pulsar 的消费者发送的是 Flow 请求，它本身是没有对应的 FETCH 响应的。Client 会主动告知 broker 自己可以缓存多少条消息，broker 根据这个提示可以灵活定制 dispatcher，然后主动发消息给 client。因此 Pulsar 的这种 push 模型，实际上是由服务端（broker）来进行流量控制。两者本质区别就是流控到底是 client 还是 server 处理的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/21/Netty-and-NIO-buffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/08/21/Netty-and-NIO-buffer/" class="post-title-link" itemprop="url">Netty-and-NIO-buffer</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-08-21 00:19:40" itemprop="dateCreated datePublished" datetime="2021-08-21T00:19:40+08:00">2021-08-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>目的是比较 NIO buffer（<code>java.nio.ByteBuffer</code>）和 Netty buffer（<code>io.netty.buffer.ByteBuf</code>）设计上的区别。因为刚好需要用 Netty 的 <code>ByteBufAllocator</code> 去重写 Kafka 的基于 NIO buffer 的 <code>ByteBufferOutputStream</code>，所以借此机会学习下两者的区别。</p>
<h2 id="NIO-buffer"><a href="#NIO-buffer" class="headerlink" title="NIO buffer"></a>NIO buffer</h2><p>参考文档：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html</a></p>
<p>NIO buffer 的设计很简单，它是定长的，也就是必须在构造时指定容量，且不可扩容，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>); <span class="comment">// 分配 4 字节容量堆内内存</span></span><br></pre></td></tr></table></figure>

<p>每个 NIO buffer 有四个属性：</p>
<ul>
<li>mark：记录的位置</li>
<li>position：当前读写位置</li>
<li>limit：可读写字节的上界，初始值是 capacity</li>
<li>capacity：容量</li>
</ul>
<p>这里暂时忽略 mark 属性。那么上述代码中，<code>buffer</code> 构造完成后各下标为：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: <span class="number">0</span>, limit: <span class="number">4</span>, capacity: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>可以用以下方法打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMetadata</span><span class="params">(<span class="keyword">final</span> ByteBuffer buffer)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;position: &quot;</span> + buffer.position() + <span class="string">&quot;, limit: &quot;</span> + buffer.limit()</span><br><span class="line">            + <span class="string">&quot;, capacity: &quot;</span> + buffer.capacity());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 NIO buffer 是不可扩容的，所以理论上 <code>capacity</code> 不会改变。而 <code>position()</code> 和 <code>limit()</code> 方法都有另一个重载形式，可以接受一个 <code>int</code> 参数指定新的值。设置 <code>limit</code> 的场景大多是为了截断一个 buffer，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">buffer.putInt(<span class="number">0x11223344</span>); <span class="comment">// 0x11, 0x22, 0x33, 0x44</span></span><br><span class="line">printMetadata(buffer); <span class="comment">// position: 4, limit: 4, capacity: 4</span></span><br><span class="line">buffer.position(<span class="number">1</span>).limit(<span class="number">3</span>);</span><br><span class="line">printMetadata(buffer); <span class="comment">// position: 1, limit: 3, capacity: 4</span></span><br><span class="line">System.out.println(Integer.toHexString(buffer.getShort())); <span class="comment">// 2233</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：这里的设计没有采用 <code>setPosition()</code> 和 <code>setLimit()</code> 这样的命名方式，但是返回的都是 <code>ByteBuffer</code>，因此支持上述代码的链式调用方式。</p>
</blockquote>
<p>NIO buffer 提供 <code>put</code> 和 <code>get</code> 方法，两者都针对不同类型提供了多种类似方法，但大体分为两类，一类是不带 index 的，也就是直接从末尾写入或读取，一类是带 index 的，从 index 对应位置写入和读取。</p>
<p>limit 属性则是 <code>get</code> 读写的上界，如果即将读取的字节位置已经超过了 limit，那么会抛出 <code>BufferOverflowException</code>（因为打破了 <code>position &lt;= limit</code> 的约束），比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">0x11</span>);</span><br><span class="line">printMetadata(buffer); <span class="comment">// position: 1, limit: 2, capacity: 2</span></span><br><span class="line"><span class="comment">// 写入的位置是 position + short size = 1 + 2 = 3 &gt; limit，因此抛出异常</span></span><br><span class="line">buffer.putShort((<span class="type">short</span>) <span class="number">0x2233</span>); </span><br></pre></td></tr></table></figure>

<p>无论是 <code>get</code> 还是 <code>put</code>，都会改变 position，因为它们共用一个下标如果往末尾写入了新数据则会改变 limit。这里需要注意的是，读写共用一个下 position，这会导致一些反直觉的行为，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1</span>);</span><br><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">0x11</span>);</span><br><span class="line">System.out.println(buffer.get()); <span class="comment">// BufferUnderflowException</span></span><br></pre></td></tr></table></figure>

<p>直觉上第一次 <code>get()</code> 应该从 position 0 开始，但这里其实是从 position 1 开始，因为 <code>put</code> 改变了 position。如果要从 position 0 开始，只能在 <code>get()</code> 之前手动调用 <code>buffer.position(0)</code> 或者 <code>buffer.rewind()</code>。</p>
<p>这里提到 <code>rewind</code>，它和 <code>position(0)</code> 的唯一区别是它将 <code>ByteBuffer</code> 的 <code>mark</code> 字段设置为了 -1。</p>
<p>现在看看 mark，NIO buffer 永远满足约束： <code>mark &lt;= position &lt;= limit &lt;= capacity</code>。读&#x2F;写都会改变 position，写入可能改变 limit，而 capacity 无法改变。mark 属性仅在 <code>mark()</code> 方法中会设置为 -1 之外的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">mark</span><span class="params">()</span> &#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是记录当前的 position，主要用途是在 <code>put</code> 写入之前记下位置。<code>mark()</code> 方法要结合 <code>reset()</code> 方法使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>) <span class="comment">// 必须 mark() 设置过合法的 position，否则会抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidMarkException</span>();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以方便回滚到写之前的位置进行读取，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">buffer.mark();</span><br><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">0x11</span>);</span><br><span class="line">buffer.reset();</span><br><span class="line">System.out.println(Integer.toHexString(buffer.get())); <span class="comment">// 11</span></span><br><span class="line">buffer.mark();</span><br><span class="line">buffer.put((<span class="type">byte</span>) <span class="number">0x22</span>);</span><br><span class="line">buffer.reset();</span><br><span class="line">System.out.println(Integer.toHexString(buffer.get())); <span class="comment">// 22</span></span><br></pre></td></tr></table></figure>

<p>如果是单纯的先写后读的场景，可以在写结束后调用 <code>flip()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title function_">flip</span><span class="params">()</span> &#123;</span><br><span class="line">    limit = position; <span class="comment">// 禁止写入更多字节，除非重新设置 limit</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 读写重新从 position 0 开始</span></span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于读写都会改变 position，因此如果想要读写的同时不改变 position，可以调用 <code>duplicate()</code> 方法创建一个 buffer 共享数据，但是拥有独立的 position 以及其他属性，这些属性的初始值都是调用时原 buffer 的相应值。也可以用 <code>array()</code> 直接获取底层数组（下标 0 到 capacity）。</p>
<h2 id="Netty-buffer"><a href="#Netty-buffer" class="headerlink" title="Netty buffer"></a>Netty buffer</h2><p>参考文档：<a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html">https://netty.io/4.1/api/io/netty/buffer/ByteBuf.html</a></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>Netty buffer 支持使用 Netty 的 allocator 来分配内存，具体定制可参考 <a target="_blank" rel="noopener" href="https://netty.io/4.1/api/io/netty/buffer/ByteBufAllocator.html">Netty ByteBufAllocator</a>。也可以直接通过现有的 NIO buffer 或者字节数组构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> Unpooled.wrappedBuffer(ByteBuffer.allocate(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>其中，使用 <code>wrappedBuffer</code> 构造时，writer index 均为原来的 buffer&#x2F;数组的大小。</p>
<h3 id="读写位置分离"><a href="#读写位置分离" class="headerlink" title="读写位置分离"></a>读写位置分离</h3><p>NIO buffer 的设计很简单，但是由于读写共用一个 position，导致使用起来不是很符合直觉，比如写完之后要重新调用 <code>position()</code> 设置位置，或者结合 <code>mark()</code> 和 <code>reset()</code>，或者 <code>flip()</code> 等等。</p>
<p>而 Netty buffer 则将读写位置（这里称为 index 而非 position）分离了，见下图。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|<span class="string"> discardable bytes </span>|<span class="string">  readable bytes  </span>|<span class="string">  writable bytes  </span>|</span><br><span class="line">|<span class="string">                   </span>|<span class="string">     (CONTENT)    </span>|<span class="string">                  </span>|</span><br><span class="line">+-------------------+------------------+------------------+</span><br><span class="line">|<span class="string">                   </span>|<span class="string">                  </span>|<span class="string">                  </span>|</span><br><span class="line">0      <span class="variable">&lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Discardable bytes：已经读取的区域</li>
<li>Readable bytes：数据实际存储的位置</li>
<li>Writable bytes：待填满的区域</li>
</ul>
<p>Netty buffer 将读写分为了两套 API，read&#x2F;write 系列方法类似于 NIO buffer 的 get&#x2F;put，读写成功会更新对应的 index。同时还支持指定 index 的 get&#x2F;set 系列方法用于随机读写，不会更新 index。另外，无论是 readerIndex 还是 writerIndex，Netty buffer 也提供了相应的 mark&#x2F;reset 系列方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">2</span>);</span><br><span class="line">buf.writeByte(<span class="number">1</span>); <span class="comment">// readerIndex: 0, writerIndex: 1</span></span><br><span class="line">buf.writeByte(<span class="number">2</span>); <span class="comment">// readerIndex: 0, writerIndex: 2</span></span><br><span class="line">buf.readByte(); <span class="comment">// readerIndex: 1, writerIndex: 2</span></span><br><span class="line">buf.readByte(); <span class="comment">// readerIndex: 1, writerIndex: 2</span></span><br></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>NIO buffer 本质是对定长数组的包装，因此 capacity 是无法增长的，但是 Netty buffer 实现了自动扩容。这里可以先写个代码看看它的扩容策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">    buf.writeByte(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i + <span class="string">&quot; address: &quot;</span> + buf.memoryAddress() + <span class="string">&quot;, capacity: &quot;</span> + buf.capacity());</span><br><span class="line">&#125;</span><br><span class="line">buf.release();</span><br></pre></td></tr></table></figure>

<p>可以看到输出是：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0 address:</span> <span class="number">140495611232256</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">1 address:</span> <span class="number">140495611232256</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">16</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">16 address:</span> <span class="number">140495611240448</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">64</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">64 address:</span> <span class="number">140495611248640</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">128</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">128 address:</span> <span class="number">140495611256832</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">256</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">256 address:</span> <span class="number">140495611265024</span><span class="string">,</span> <span class="attr">capacity:</span> <span class="number">512</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>这里不深究具体扩容策略，姑且看到 capacity 到达 64 之后就开始两倍扩容。这里主要看到，每次扩容之后内存地址发生了改变，对于连续存储的数据结构而言，基本都是这个实现套路。</p>
<p>但是，注意这里我们是用 <code>ByteBufAllocator</code> 进行分配的，如果是字节数组或者 NIO buffer 的 wrapper，由于底层是定长数组，因此 Netty buffer 无法获取其分配器，自然地，也不知道扩容时用哪个分配器才能跟原来的分配方式一致，因此这种情况是不允许扩容的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(ByteBuffer.allocate(<span class="number">100</span>));</span><br><span class="line">buf.writerIndex(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buf.writeByte(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">buf.release();</span><br></pre></td></tr></table></figure>

<p>输出 <code>i = 100</code>，也就是容量到达 100 时就无法继续写入了。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>需要注意的是每个 Netty buffer 维护了一个引用计数，在调用 <code>retain()</code> 的时候自增，在 <code>release()</code> 的时候自减，使用 allocator 分配的时候初始为 1，只有引用计数降为 0 才会回收内存，否则会出现内存泄漏。由于在 Java 中，经常是将 buffer 传递给其它对象后就不再使用了，因此惯用法是最后一个使用 buffer 对象负责 release。</p>
<p>Netty 可以设置内存泄漏的检测器，详细用法参考 <a target="_blank" rel="noopener" href="https://netty.io/4.0/api/io/netty/util/ResourceLeakDetector.html">ResourceLeakDetector</a>，它可以设置检测等级，默认是 Disabled。这里给出一个示例检测全局资源泄漏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">leakDemo</span><span class="params">(<span class="keyword">final</span> ByteBufAllocator allocator)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> allocator.buffer(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    buf.writeByte(<span class="number">1</span>);</span><br><span class="line">    buf.readByte();</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> not released</span></span><br><span class="line">    <span class="comment">//buf.release();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 等价于加上 JVM 选项 -Dio.netty.leakDetectionLevel=paranoid</span></span><br><span class="line">    ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PooledByteBufAllocator</span>(<span class="literal">false</span> <span class="comment">/* preferDirect */</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">        leakDemo(allocator);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2021</span>-<span class="number">08</span>-<span class="number">20</span> <span class="number">23</span>:<span class="number">15</span>:<span class="number">55</span>:<span class="number">264</span><span class="meta"> [main] ERROR io.netty.util.ResourceLeakDetector - LEAK: ByteBuf.release() was not called before it&#x27;s garbage-collected. See https://netty.io/wiki/reference-counted-objects.html for more information.</span></span><br><span class="line"><span class="meta">Recent access records: </span></span><br><span class="line"><span class="meta">#1:</span></span><br><span class="line"><span class="meta">	io.netty.buffer.AdvancedLeakAwareByteBuf.readByte(AdvancedLeakAwareByteBuf.java:400)</span></span><br><span class="line"><span class="meta">...</span></span><br></pre></td></tr></table></figure>

<p>从而方便定位泄漏位置。</p>
<blockquote>
<p>需要注意的是 paranoid 时最高的检测等级，如果改成 simple 或 advanced，上述错误不会报出来。另外如果 preferDirect 改为 true 或者使用默认的 allocator，这里也检测不出来。原因可以参考回答：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/28822632/netty-4-5-does-not-actually-detect-resource-leak-of-bytebuf">https://stackoverflow.com/questions/28822632/netty-4-5-does-not-actually-detect-resource-leak-of-bytebuf</a></p>
<p>原因简单说就是 Netty 的资源泄漏检测机制依赖于 <code>ReferenceQueue</code> 和 <code>PhantomReference</code>，如果 VM 太早终止或者 GC 不够快，那么检测器无法判断是否泄漏</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从 NIO buffer 入手，学习了 Netty buffer 的一些改进，包括读写位置分离，自定义分配器，自动扩容。同时还要注意 Netty buffer 相比 NIO buffer 而言需要谨慎地管理内存，同时还可以用 Netty 提供的检测器检测资源泄漏。</p>
<p>个人认为 Netty 的最大优点在于它提供的池化分配器，可以安全地复用堆外内存，减少了 GC 的同时避免了从系统的堆内存到 JVM 堆的拷贝。因此 Pulsar 无论是 broker 还是 client 在分配内存保存消息时，都是使用的 Netty 的分配器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/05/09/%E5%86%8D%E6%8E%A2-CompletableFuture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/09/%E5%86%8D%E6%8E%A2-CompletableFuture/" class="post-title-link" itemprop="url">再探 CompletableFuture</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-09 00:58:55" itemprop="dateCreated datePublished" datetime="2021-05-09T00:58:55+08:00">2021-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上次在 Github 上面写博客都是大半年前了，这段时间一直相对较忙，没抽出时间来认真写博客，大多只是一些零散的笔记记录在个人的有道云笔记上，这次姑且尝试继续写博客。</p>
<p>在之前的博客 <a target="_blank" rel="noopener" href="https://bewaremypower.github.io/2020/10/07/Java-CompletableFuture-%E5%AD%A6%E4%B9%A0/">Java CompletableFuture 学习</a> 中，我们了解了 <code>CompletableFuture</code> 用于异步编程的基本套路：</p>
<ul>
<li>使用 <code>supplyAsync</code> 在 <code>ExecutorService</code> 中启动异步任务并返回 future</li>
<li>使用 <code>thenApply</code> &#x2F; <code>thenCompose</code> &#x2F; <code>exceptionally</code> 方法进行 future 之间的链式映射</li>
<li>使用 <code>whenComplete</code> 方法来指定异步任务完成时的回调</li>
</ul>
<p>然而在这段时间阅读 <a target="_blank" rel="noopener" href="https://github.com/apache/pulsar">Pulsar</a> 和 <a target="_blank" rel="noopener" href="https://github.com/streamnative/kop">KoP</a> 的源码过程中，发现其实对 <code>CompletableFuture</code> 的使用还是存在一些误区的，本文将个人的一些经验整合一下。</p>
<p>本文的示例从一个简单的例子开始（其中 <code>print</code> 方法会在后文中复用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">final</span> String msg)</span> &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; intFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        print(<span class="string">&quot;in supplyAsync()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    print(<span class="string">&quot;intFuture returns: &quot;</span> + intFuture.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool<span class="selector-class">.commonPool-worker-9</span> <span class="keyword">in</span> <span class="built_in">supplyAsync</span>()</span><br><span class="line"><span class="selector-tag">main</span> intFuture returns: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>可见 <code>supplyAsync</code> 默认用的是 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html"><code>ForkJoinPool</code></a> 这个 Java 线程池。由于本人是半路出家的 Javaer，这里先记下这个知识点，之后再系统学习下。</p>
<h2 id="thenApply-x2F-exceptionally-vs-whenComplete"><a href="#thenApply-x2F-exceptionally-vs-whenComplete" class="headerlink" title="thenApply&#x2F;exceptionally vs. whenComplete"></a>thenApply&#x2F;exceptionally vs. whenComplete</h2><h3 id="针对不会异常完成的-future"><a href="#针对不会异常完成的-future" class="headerlink" title="针对不会异常完成的 future"></a>针对不会异常完成的 future</h3><p>这个其实很多人都用错了使用场景，因为大多数时候，其实我们只是想给 future 加一个回调，并不想继续链式调用。其实这种简单场景下，<code>whenComplete</code> 才是应该用的。比如，我们想对奇数进行操作，偶数则抛出异常，可以是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; firstFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    print(<span class="string">&quot;in firstFuture, x = &quot;</span> + x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; secondFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">firstFuture.whenComplete((integer, throwable) -&gt; &#123;</span><br><span class="line">    <span class="keyword">assert</span> throwable != <span class="literal">null</span>;</span><br><span class="line">    print(<span class="string">&quot;in secondFuture, firstFuture returns &quot;</span> + integer);</span><br><span class="line">    <span class="keyword">if</span> (integer % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        secondFuture.complete(integer / <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        secondFuture.completeExceptionally(<span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;firstFuture returns an even number: &quot;</span> + integer));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;secondFuture returns: &quot;</span> + secondFuture.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    print(<span class="string">&quot;secondFuture failed: &quot;</span> + e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是两种典型输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> in firstFuture, x = -<span class="number">1634409183</span></span><br><span class="line"><span class="attribute">main</span> in secondFuture, firstFuture returns -<span class="number">1634409183</span></span><br><span class="line"><span class="attribute">main</span> secondFuture returns: -<span class="number">817204591</span></span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool<span class="selector-class">.commonPool-worker-9</span> <span class="keyword">in</span> firstFuture, x = <span class="number">1243845674</span></span><br><span class="line"><span class="selector-tag">main</span> <span class="keyword">in</span> secondFuture, firstFuture returns <span class="number">1243845674</span></span><br><span class="line"><span class="selector-tag">main</span> secondFuture failed: java<span class="selector-class">.lang</span><span class="selector-class">.Exception</span>: firstFuture returns an even number: <span class="number">1243845674</span></span><br></pre></td></tr></table></figure>

<p>这里我们可以先留意一下，<code>firstFuture</code> 的 <code>whenComplete</code> 方法是在主线程内执行的。</p>
<p>但实际上由于 <code>firstFuture</code> 永远不会异常结束，因此这个时候其实可以简化 <code>secondFuture</code> 的构造为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; secondFuture = firstFuture.thenApply(integer -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;in secondFuture, firstFuture returns &quot;</span> + integer);</span><br><span class="line">    <span class="keyword">if</span> (integer % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> integer / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 注意 thenApply 内部只能抛出 unchecked exception</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;firstFuture returns an even number: &quot;</span> + integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时两者本质上是一样的，但是 <code>thenApply</code> 更简洁。而且其实可以将上述代码简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(<span class="comment">/* ... */</span>).thenApply(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>

<h3 id="针对可能异常完成的-future"><a href="#针对可能异常完成的-future" class="headerlink" title="针对可能异常完成的 future"></a>针对可能异常完成的 future</h3><p>TL; DR 使用 <code>whenComplete</code> 就是最好的，不要链式使用 <code>thenApply</code> 和 <code>exceptionally</code>。 </p>
<p>假如 <code>firstFuture</code> 就在偶数的时候抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; firstFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    print(<span class="string">&quot;in firstFuture, x = &quot;</span> + x);</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;firstFuture returns an even number: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>那么基于 <code>whenComplete</code> 实现的 <code>secondFuture</code> 变成了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; secondFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">print(<span class="string">&quot;in secondFuture, firstFuture returns &quot;</span> + integer);</span><br><span class="line">firstFuture.whenComplete((integer, throwable) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">        secondFuture.completeExceptionally(throwable);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        secondFuture.complete(integer / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这个实现和上一节的是等价的。但此时，如果基于 <code>thenApply</code>，很多人会进一步用 <code>exceptionally</code> 进行两层链式调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; secondFuture = firstFuture.thenApply(integer -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;in secondFuture thenApply, x = &quot;</span> + integer);</span><br><span class="line">    <span class="keyword">return</span> integer;</span><br><span class="line">&#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;in secondFuture exception: &quot;</span> + e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，这其实是错误的实现，并且和基于 <code>whenComplete</code> 的实现不是等价的。原因在于 <code>exceptionally</code>，注意我们返回的是 <code>null</code>，因此 <code>secondFuture</code> 在 <code>firstFuture</code> 异常完成时，是返回 null 而非异常完成。</p>
<p>比如下面这组 <code>firstFuture</code> 异常完成时的输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool<span class="selector-class">.commonPool-worker-9</span> <span class="keyword">in</span> firstFuture, x = <span class="number">784152994</span></span><br><span class="line"><span class="selector-tag">main</span> <span class="keyword">in</span> secondFuture exception: java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletionException</span>: java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: firstFuture returns an even number: <span class="number">784152994</span></span><br><span class="line"><span class="selector-tag">main</span> secondFuture returns: null</span><br></pre></td></tr></table></figure>

<p>这里有两个重点：</p>
<ol>
<li><code>secondFuture</code> 是以 null 正常完成（而不是继续以 <code>firstFuture</code> 的异常正常完成）；</li>
<li><code>exceptionally</code> 的 <code>e</code> 的类型不是 <code>RuntimeException</code>，而是 <code>CompletionException</code>，它的 cause 才是 <code>RuntimeException</code>。</li>
</ol>
<p>第一点我们刚才提到了，是 <code>return null</code> 导致的，第二点则尤为致命。之前 Pulsar 这边有个问题是，大量的 HTTP 处理的错误码都是 500 internal error，而不是正确的错误码，原因就在于大量处理都是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Object&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">asyncDoSomething()</span><br><span class="line">    .thenApply(result -&gt; future.complete(result))</span><br><span class="line">    .exceptionally(e -&gt; &#123;</span><br><span class="line">        future.completeExceptionally(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>而在之后处理 <code>future</code> 的异常时，直接把 <code>e</code> 当成 <code>e.getCause()</code> 的类型来使用了。</p>
<h2 id="thenApply-的实现"><a href="#thenApply-的实现" class="headerlink" title="thenApply 的实现"></a>thenApply 的实现</h2><p>造成上一节里 <code>exceptionally</code> 的 <code>e</code> 不再是最初 future 的异常，而是包裹后的 <code>CompletionException</code> 的原因其实很简单，那就是某个 <code>CompletableFuture</code> 调用 <code>thenApply</code> 返回后的 <code>CompletableFuture</code>，已经不是它自己了。这里我们简单看下源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(</span></span><br><span class="line"><span class="params">        Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span> &#123;</span><br><span class="line">        <span class="comment">// 这里 fn 即我们传入的 lambda 表达式，接收 T 类型的参数，返回 U 类型</span></span><br><span class="line">        <span class="keyword">return</span> uniApplyStage(<span class="literal">null</span>, fn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>thenApply</code> 其实是将 <code>CompletableFuture&lt;T&gt;</code> 映射到 <code>CompletableFuture&lt;U&gt;</code> 的，因此很显然前后两个 future 类型不一样。那为什么不继续传播前一个 future 的异常呢？继续看下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="title function_">uniApplyStage</span><span class="params">(</span></span><br><span class="line"><span class="params">    Executor e, Function&lt;? <span class="built_in">super</span> T,? extends V&gt; f)</span> &#123;</span><br><span class="line">    <span class="comment">// f 即用户传入的 T -&gt; U 的 lambda 表达式，这里泛型参数是 V 而不是 U</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    CompletableFuture&lt;V&gt; d =  <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;V&gt;();</span><br><span class="line">    <span class="comment">// 注意这里的 e 是 Executor 对象，而不是异常，因为 f 并没有执行</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> || !d.uniApply(<span class="built_in">this</span>, f, <span class="literal">null</span>)) &#123;</span><br><span class="line">        UniApply&lt;T,V&gt; c = <span class="keyword">new</span> <span class="title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="built_in">this</span>, f);</span><br><span class="line">        push(c);</span><br><span class="line">        c.tryFire(SYNC); <span class="comment">// SYNC 是常量 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造了 <code>UniApply</code> 对象，然后调用了 <code>tryFire</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;V&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">    <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> ||</span><br><span class="line">        !d.uniApply(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    dep = <span class="literal">null</span>; src = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对返回的 future <code>d</code> 调用了 <code>uniApply</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="type">boolean</span> <span class="title function_">uniApply</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span><br><span class="line"><span class="params">                           Function&lt;? <span class="built_in">super</span> S,? extends T&gt; f,</span></span><br><span class="line"><span class="params">                           UniApply&lt;S,T&gt; c)</span> &#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    tryComplete: <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">S</span> <span class="variable">s</span> <span class="operator">=</span> (S) r;</span><br><span class="line">            <span class="comment">// 注意，在这里执行我们传入的 lambda 表达式 f</span></span><br><span class="line">            completeValue(f.apply(s));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="comment">// 如果抛出异常，则调用 `completeThrowable` 方法</span></span><br><span class="line">            completeThrowable(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于看到捕获异常的位置了，最后我们只需要看看 <code>completeThrowable</code> 做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AltResult <span class="title function_">encodeThrowable</span><span class="params">(Throwable x)</span> &#123;</span><br><span class="line">    <span class="comment">// 用 x 作为 cause 构造 CompletionException，这里还进行了类型判断避免 CompletionException 嵌套</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AltResult</span>((x <span class="keyword">instanceof</span> CompletionException) ? x :</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">CompletionException</span>(x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">completeThrowable</span><span class="params">(Throwable x)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 native CAS 方法将偏移量 RESULT 对应的字段（其实就是 result）设置为 encodeThrowable(x)，如果 result 之前是 null</span></span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, RESULT, <span class="literal">null</span>,</span><br><span class="line">                                       encodeThrowable(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们知道为什么 <code>thenApply</code> 返回的 future 若异常完成，其异常是 <code>CompletionException</code> 而非原来的 future 的异常了。这里多说一句，设置的 <code>result</code> 字段为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> Object result;       <span class="comment">// Either the result or boxed AltResult</span></span><br></pre></td></tr></table></figure>

<p>也就是 <code>get()</code> &#x2F; <code>getNow()</code> 等方法会尝试返回的字段。进一步的代码阅读就不继续了，总之，我们已经知道了，并且知道为什么，将 <code>thenApply</code> 和 <code>exceptionally</code> 结合起来并不是一种合适的取代 <code>whenComplete</code> 的方法。</p>
<p>虽然我们一般用 <code>thenApply</code> 的返回值比较多，但实际上 <code>exceptionally</code> 和 <code>whenComplete</code> 也有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;Throwable, ? extends T&gt; fn)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniExceptionallyStage(fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> uniWhenCompleteStage(<span class="literal">null</span>, action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初学者一个常见的使用错误或困惑是，在 <code>exceptionally</code> 末尾忘记去 <code>return null</code>，因为在 <code>whenComplete</code> 里不用 <code>return</code>。从方法签名就能看出来，原因是 <code>exceptionally</code> 接收的是 <code>(Throwable) -&gt; T</code> 的函数，而 <code>whenComplete</code> 接收的是 <code>(T, Throwable) -&gt; void</code> 的函数，没有返回值。而由于 <code>exceptionally</code> 接收的参数里没有 <code>T</code> 类型，因此只能返回一个常量，绝大多时候就是 null 了。</p>
<p>当然，它们返回的虽然和当前 future 对象是一个类型： <code>CompletableFuture&lt;T&gt;</code>，但实际上已经不是一个对象了。依然是举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt();</span><br><span class="line">    print(<span class="string">&quot;supplyAsync, x = &quot;</span> + x);</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;firstFuture returns an even number: &quot;</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((integer, throwable) -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;whenComplete integer=&quot;</span> + integer + <span class="string">&quot;, throwable=&quot;</span> + throwable);</span><br><span class="line">&#125;).get();</span><br></pre></td></tr></table></figure>

<p>两个示例输出：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool.commonPool-worker-9 supplyAsync, x = 1489321475</span><br><span class="line">main whenComplete <span class="attribute">integer</span>=1489321475, <span class="attribute">throwable</span>=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool<span class="selector-class">.commonPool-worker-9</span> supplyAsync, x = -<span class="number">1124011744</span></span><br><span class="line"><span class="selector-tag">main</span> whenComplete integer=null, throwable=java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.CompletionException</span>: java<span class="selector-class">.lang</span><span class="selector-class">.RuntimeException</span>: firstFuture returns an even number: -<span class="number">1124011744</span></span><br></pre></td></tr></table></figure>

<p>我们可以注意到由于 <code>get()</code> 方法是 <code>whenComplete</code> 返回的 future 而不是原来的 future 调用的，抛出异常时，也是 <code>CompletionException</code>，其中的 cause 才是真正的异常。这里就不去看源码了，其实可以猜到，处理和 <code>thenApply</code> 是类似的。</p>
<h2 id="getNow-vs-thenApply-x2F-whenComplete"><a href="#getNow-vs-thenApply-x2F-whenComplete" class="headerlink" title="getNow vs. thenApply&#x2F;whenComplete"></a>getNow vs. thenApply&#x2F;whenComplete</h2><p>有一些场景是，判断当前 future 是否已经完成，若完成则直接处理结果，否则加入队列等待。亦或者，是用 <code>CompletableFuture.all</code> 来等待多个 future 结束时再做处理，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(millis);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    print(<span class="string">&quot;future1 returns&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    sleep(<span class="number">1200</span>);</span><br><span class="line">    print(<span class="string">&quot;future2 returns&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// allOf 返回的是 CompletableFuture&lt;Void&gt;，而非 Scala 里 Future.sequence 那样返回一个 List 的 future</span></span><br><span class="line">CompletableFuture.allOf(future1, future2).get();</span><br><span class="line">print(future1.getNow(<span class="literal">null</span>) + <span class="string">&quot;, &quot;</span> + future2.getNow(<span class="literal">null</span>));</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> future1 returns</span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">2</span> future2 returns</span><br><span class="line"><span class="attribute">main</span> <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这里我们用的 <code>getNow</code>，实际上用 <code>get</code> 方法也一样，因为此时 future 已经完成了，<code>get</code> 会立刻返回。但由于 <code>get</code> 的方法签名中包含 checked exception，因此需要你捕获。</p>
<p>实际上 <code>getNow</code> 从表达上也不太好，因为 future 已经完成，这个默认值 null 其实是多余的。从语义表达的角度，在这里不对 <code>getNow(null)</code> 的返回值进行 null 检查的话，就得在注释中写明此时保证 future 已经完成。但实际上有可能前面 <code>allOf</code> 写错了，比如写漏了一个 future，导致其实有的 future 在这里是并没有完成的，那么排查问题就变得麻烦。</p>
<p>有时候在这里也会选择 <code>join</code> 方法，它和 <code>get</code> 的不同在于，future 异常完成时，它抛出的是 unchecked exception，这样就不需要捕获。</p>
<p>但实际上其实也可以用 <code>thenApply</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">future1.thenApply(result1 -&gt; &#123;</span><br><span class="line">    future2.thenApply(result2 -&gt; &#123;</span><br><span class="line">        print(result1 + <span class="string">&quot;, &quot;</span> + result2);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>虽然在这里略显麻烦，并且出现了 future 嵌套。但其实反而这种嵌套从表达上更好，因为这里我们的处理，result2 是依赖于 result1 的，这种嵌套表达了依赖关系。</p>
<p>另外，对于已经完成的 future，<code>thenApply</code> 的处理全部是在主线程进行的。同理，<code>whenComplete</code> 也是。因此假如我们在对一个已经完成的 future 进行处理时，可以直接用 <code>whenComplete</code>。</p>
<p>现在来看看另一个场景，那就是在 future 完成之前这么做会怎样？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">future1.thenApply(result1 -&gt; &#123;</span><br><span class="line">    print(<span class="string">&quot;result1: &quot;</span> + result1);</span><br><span class="line">    future2.thenApply(result2 -&gt; &#123;</span><br><span class="line">        print(result1 + <span class="string">&quot;, &quot;</span> + result2);</span><br><span class="line">        future.complete(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">future.get();</span><br></pre></td></tr></table></figure>

<p>示例输出：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> future1 returns</span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> result1: <span class="number">1</span></span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">2</span> future2 returns</span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">2</span> <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可见每个 future 的回调都是接着当前 future 所在线程的。然而，假如我们调整一下，让 future2 只 sleep 200 ms（也就是说 future2 在 future1 之前完成），输出变成了：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">2</span> future2 returns</span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> future1 returns</span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> result1: <span class="number">1</span></span><br><span class="line"><span class="attribute">ForkJoinPool</span>.commonPool-worker-<span class="number">9</span> <span class="number">1</span>, <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>一个显著变化是，future2 的回调不再是在 future2 所在线程执行，而是在 future1 所在线程执行。原因其实和刚才的一样，在 future1 回调中去给 future2 再注册新的回调时，future2 已经完成了，因此 future2 的回调直接在 <strong>当前线程</strong> 执行。其实这个原理在前面贴的代码中 <code>uniApply</code> 中实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;S&gt; <span class="type">boolean</span> <span class="title function_">uniApply</span><span class="params">(CompletableFuture&lt;S&gt; a,</span></span><br><span class="line"><span class="params">                           Function&lt;? <span class="built_in">super</span> S,? extends T&gt; f,</span></span><br><span class="line"><span class="params">                           UniApply&lt;S,T&gt; c)</span> &#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 如果当前 future 未完成，a.result 则为 null，此时 uniApply 会返回 false，f 被加入队列</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 如果 a.result != null，则后面会调用 completeValue 执行 f.apply，这里就不重复贴代码了</span></span><br></pre></td></tr></table></figure>

<p>至此可见使用 <code>thenApply</code> 注册回调，比起 <code>getNow</code> 等方法更灵活，而且在 future 已经完成的场景下，两者其实是等价的，前者并不会带来更多的开销。当然，从代码简洁性的角度，有时候用 <code>getNow(null)</code> 其实还是可以的，取决于个人。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要探讨了两个方面，一个是设置回调时结合 <code>thenApply</code> 和 <code>exceptionally</code> 和直接使用 <code>whenComplete</code> 的对比，另一个是对于 future 已经完成的场合，<code>thenApply</code> 的使用。此外，还附带着看了下 <code>thenApply</code> 的实现。总的来说，<code>CompletableFuture</code> 这个基础设施还是简单易用，但还是有一些细节需要注意才能写出更好的代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/08/Pulsar-Protocol-Handler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/Pulsar-Protocol-Handler/" class="post-title-link" itemprop="url">Pulsar Protocol Handler</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-08 23:49:23" itemprop="dateCreated datePublished" datetime="2020-10-08T23:49:23+08:00">2020-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文主要目的是阅读 <a target="_blank" rel="noopener" href="https://github.com/apache/pulsar">Pulsar</a> protocol handler（比如 KoP，AoP，MoP）在 broker 中如何运作的，protocol handler（下文简称 <strong>handler</strong>）对应的是包 <code>org.apache.pulsar.broker.protocol</code>（下文将<strong>略去包括 <code>broker</code>  之前的包前缀</strong>）的接口 <code>ProtocolHandler</code>，只要实现了该接口，并打包成 <code>*.nar</code> 后缀以供 broker 加载，即相当于实现了一个 handler。</p>
<h2 id="handler-初始化"><a href="#handler-初始化" class="headerlink" title="handler 初始化"></a>handler 初始化</h2><p><code>ProtocolHandler</code> 本身位于 <code>protocol</code> 包下，注意到初始化方法 <code>initialize</code>，找到它的使用，在 <code>ProtocolHandlerWithClassLoader</code> 类的同名方法被调用，简单看下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProtocolHandlerWithClassLoader</span> <span class="keyword">implements</span> <span class="title class_">ProtocolHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProtocolHandler handler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NarClassLoader classLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration conf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        handler.initialize(conf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 其他方法都是 override handler 的同名方法，比如 xxx()，都是直接调用 handler.xxx() */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        handler.close();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            classLoader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Failed to close the protocol handler class loader&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是在构造时多传入了一个 <code>NarClassLoader</code> 对象，并且在 override <code>close()</code> 方法时关闭这个对象，其他方法都是直接调用 handler 的同名方法。</p>
<p>继续查找 <code>initialize()</code> 方法的调用，又被 <code>ProtocolHandlers</code> 类的同名方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration conf)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (ProtocolHandler handler : handlers.values()) &#123;</span><br><span class="line">        handler.initialize(conf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ProtocolHandlerWithClassLoader&gt; handlers;</span><br><span class="line"></span><br><span class="line">ProtocolHandlers(Map&lt;String, ProtocolHandlerWithClassLoader&gt; handlers) &#123;</span><br><span class="line">    <span class="built_in">this</span>.handlers = handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 <code>ProtocolHandlers</code> 维护了一系列 <code>ProtocolHandlerWithClassLoader</code>，并在构造时传入。而它的构造则在静态方法 <code>load</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ProtocolHandlers <span class="title function_">load</span><span class="params">(ServiceConfiguration conf)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 在配置 protocolHandlerDirectory 对应的目录下查找所有的 handler definitions，并暂时解压到配置 narExtractionDirectory 目录下</span></span><br><span class="line">    <span class="type">ProtocolHandlerDefinitions</span> <span class="variable">definitions</span> <span class="operator">=</span></span><br><span class="line">        ProtocolHandlerUtils.searchForHandlers(conf.getProtocolHandlerDirectory(), conf.getNarExtractionDirectory());</span><br><span class="line"></span><br><span class="line">    ImmutableMap.Builder&lt;String, ProtocolHandlerWithClassLoader&gt; handlersBuilder = ImmutableMap.builder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 遍历配置 messagingProtocols 列表的每个 protocol</span></span><br><span class="line">    conf.getMessagingProtocols().forEach(protocol -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 取得 protocol 名字对应的 definition</span></span><br><span class="line">        <span class="type">ProtocolHandlerMetadata</span> <span class="variable">definition</span> <span class="operator">=</span> definitions.handlers().get(protocol);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == definition) &#123;</span><br><span class="line">            <span class="comment">/* 抛出异常表示 protocol handler is found */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ProtocolHandlerWithClassLoader handler;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 加载 definition 对应的 handler</span></span><br><span class="line">            handler = ProtocolHandlerUtils.load(definition, conf.getNarExtractionDirectory());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">/* 记录错误日志并抛出异常表示 Failed to load the protocol handler */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3 通过 handler 的 accept 方法判断 protocol 是否可接受</span></span><br><span class="line">        <span class="keyword">if</span> (!handler.accept(protocol)) &#123;</span><br><span class="line">            <span class="comment">/* 关闭 handler，记录错误日志并抛出异常表示 Malformed protocol handler found */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.4 将 protocol 和 handler 作为 key-value 加入 map</span></span><br><span class="line">        handlersBuilder.put(protocol, handler);</span><br><span class="line">        log.info(<span class="string">&quot;Successfully loaded protocol handler for protocol `&#123;&#125;`&quot;</span>, protocol);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProtocolHandlers</span>(handlersBuilder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码注释给出了初始化流程，比如修改配置（<code>conf/broker.conf</code> 或 <code>conf/standalone.conf</code>）：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认目录就是 ./protocols</span></span><br><span class="line"><span class="attr">protocolHandlerDirectory</span>=<span class="string">./protocols</span></span><br><span class="line"><span class="attr">messagingProtocols</span>=<span class="string">kafka</span></span><br></pre></td></tr></table></figure>

<p>就会在 <code>./protocols</code> 目录下面查找所有 handler definition，然后找到协议名 <code>kafka</code> 对应的 definition，期间会调用 handler 的 <code>initialize</code> 方法进行初始化。初始化完成后还要调用 handler 的 <code>accept</code> 方法判断是否被接受。最后和 <code>kafka</code> 组成键值对交由 <code>Protocols</code> 类管理。</p>
<p>这里回顾下 handler 的这两个接口（略去 javadoc 注释）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(String protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration conf)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>

<h2 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h2><p>在上一节，引入了 handler definition 的概念，这里看看其实现。首先是取得所有 definition 的 <code>searchForHandlers</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ProtocolHandlerDefinitions <span class="title function_">searchForHandlers</span><span class="params">(String handlersDirectory,</span></span><br><span class="line"><span class="params">                                                           String narExtractionDirectory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(handlersDirectory).toAbsolutePath();</span><br><span class="line">    log.info(<span class="string">&quot;Searching for protocol handlers in &#123;&#125;&quot;</span>, path);</span><br><span class="line"></span><br><span class="line">    <span class="type">ProtocolHandlerDefinitions</span> <span class="variable">handlers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolHandlerDefinitions</span>();</span><br><span class="line">    <span class="keyword">if</span> (!path.toFile().exists()) &#123;</span><br><span class="line">        <span class="comment">/* warn 日志提示目录不存在 */</span></span><br><span class="line">        <span class="keyword">return</span> handlers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(path, <span class="string">&quot;*.nar&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Path archive : stream) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 从 nar 包中取得 definition</span></span><br><span class="line">                <span class="type">ProtocolHandlerDefinition</span> <span class="variable">phDef</span> <span class="operator">=</span></span><br><span class="line">                    ProtocolHandlerUtils.getProtocolHandlerDefinition(archive.toString(), narExtractionDirectory);</span><br><span class="line">                log.info(<span class="string">&quot;Found protocol handler from &#123;&#125; : &#123;&#125;&quot;</span>, archive, phDef);</span><br><span class="line"></span><br><span class="line">                checkArgument(StringUtils.isNotBlank(phDef.getName()));</span><br><span class="line">                checkArgument(StringUtils.isNotBlank(phDef.getHandlerClass()));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 将 definition 和 nar 包路径组成 metadata</span></span><br><span class="line">                <span class="type">ProtocolHandlerMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolHandlerMetadata</span>();</span><br><span class="line">                metadata.setDefinition(phDef);</span><br><span class="line">                metadata.setArchivePath(archive);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 3. 将 definition name 作为 key 加入返回的 map</span></span><br><span class="line">                handlers.handlers().put(phDef.getName(), metadata);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="comment">/* warn 日志提示加载失败 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handlers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到会从 <code>protocolHandlerDirectory</code> 所在目录下面找到所有 <code>*.nar</code> 后缀的文件，然后取得 definition：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ProtocolHandlerDefinition <span class="title function_">getProtocolHandlerDefinition</span><span class="params">(String narPath, String narExtractionDirectory)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 解压 *.nar 包到 narExtractionDirectory，并从解压目录构造 NarClassLoader</span></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">NarClassLoader</span> <span class="variable">ncl</span> <span class="operator">=</span> NarClassLoader.getFromArchive(<span class="keyword">new</span> <span class="title class_">File</span>(narPath), Collections.emptySet(), narExtractionDirectory)) &#123;</span><br><span class="line">        <span class="comment">// 2. 从 NarClassLoader 中取得 definition</span></span><br><span class="line">        <span class="keyword">return</span> getProtocolHandlerDefinition(ncl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ProtocolHandlerDefinition <span class="title function_">getProtocolHandlerDefinition</span><span class="params">(NarClassLoader ncl)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 取得 META-INF/services/pulsar-protocol-handler.yml 的配置内容，以 KoP 为例：</span></span><br><span class="line">    <span class="comment">//   name: kafka</span></span><br><span class="line">    <span class="comment">//   description: Kafka Protocol Handler</span></span><br><span class="line">    <span class="comment">//   handlerClass: io.streamnative.pulsar.handlers.kop.KafkaProtocolHandler</span></span><br><span class="line">    <span class="comment">// 也就是 ProtocolHandlerDefinition 的 3 个字段</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">configStr</span> <span class="operator">=</span> ncl.getServiceDefinition(PULSAR_PROTOCOL_HANDLER_DEFINITION_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 YAML 配置，从中得到 definition 的 class，也就是将配置文件的三个字段填充进来</span></span><br><span class="line">    <span class="keyword">return</span> ObjectMapperFactory.getThreadLocalYaml().readValue(</span><br><span class="line">        configStr, ProtocolHandlerDefinition.class</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们知道了 definition 其实就是从 nar 包中解析 <code>pulsar-protocol-handler.yml</code> 得到对应的三个字段（都是 <code>String</code> 类型）：</p>
<ul>
<li><code>name</code>：协议名，比如 KoP 的协议名为 kafka</li>
<li><code>description</code>：handler 的描述信息</li>
<li><code>handlerClass</code>：handler 的主类</li>
</ul>
<p>回顾前一节的 <code>load()</code> 方法注释 2.3，definition 的协议名是返回的 definition map 的 key，因此可以通过用户配置的 <code>messagingProtocols</code> 来找到对应的 definition，从而找到对应的 handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 definition 变量其实是 definition + handler 解压目录的路径</span></span><br><span class="line"><span class="type">ProtocolHandlerMetadata</span> <span class="variable">definition</span> <span class="operator">=</span> definitions.handlers().get(protocol);</span><br></pre></td></tr></table></figure>

<h2 id="handler-的启动"><a href="#handler-的启动" class="headerlink" title="handler 的启动"></a>handler 的启动</h2><p>前文提到了 <code>ProtocolHandlers#load</code> 从配置文件中找到 nar 包解压后并加载得到 handlers，而 <code>load</code> 方法在 <code>PulsarService#start</code> 中被调用，并且对加载的 handlers 进行其他处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">protocolHandlers = ProtocolHandlers.load(config);</span><br><span class="line">protocolHandlers.initialize(config);</span><br><span class="line"><span class="comment">/* 其他初始化及启动流程（略） */</span></span><br><span class="line"><span class="built_in">this</span>.protocolHandlers.start(brokerService);</span><br><span class="line"><span class="comment">// 第一个 key 为协议名，第二个 key 为 handler 绑定的地址</span></span><br><span class="line">Map&lt;String, Map&lt;InetSocketAddress, ChannelInitializer&lt;SocketChannel&gt;&gt;&gt; protocolHandlerChannelInitializers =</span><br><span class="line">    <span class="built_in">this</span>.protocolHandlers.newChannelInitializers();</span><br><span class="line"><span class="built_in">this</span>.brokerService.startProtocolHandlers(protocolHandlerChannelInitializers);</span><br><span class="line"></span><br><span class="line">state = State.Started; <span class="comment">// 加载完 handlers 后 broker 的状态才改为 Started</span></span><br></pre></td></tr></table></figure>

<p>最后一步涉及到了 <code>BrokerService#startProtocolHandlers</code> 会启动 handler 创建的 <code>ChannelInitializer&lt;SocketChannel&gt;</code>，其实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startProtocolHandlers</span><span class="params">(</span></span><br><span class="line"><span class="params">    Map&lt;String, Map&lt;InetSocketAddress, ChannelInitializer&lt;SocketChannel&gt;&gt;&gt; protocolHandlers)</span> &#123;</span><br><span class="line"></span><br><span class="line">    protocolHandlers.forEach((protocol, initializers) -&gt; &#123;</span><br><span class="line">        initializers.forEach((address, initializer) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                startProtocolHandler(protocol, address, initializer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">/* 异常处理... */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startProtocolHandler</span><span class="params">(String protocol,</span></span><br><span class="line"><span class="params">                                  SocketAddress address,</span></span><br><span class="line"><span class="params">                                  ChannelInitializer&lt;SocketChannel&gt; initializer)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> defaultServerBootstrap.clone();</span><br><span class="line">    bootstrap.childHandler(initializer);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bootstrap.bind(address).sync(); <span class="comment">// handler 对应的服务绑定了相应的端口</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">/* 异常处理 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;Successfully bind protocol `&#123;&#125;` on &#123;&#125;&quot;</span>, protocol, address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，加载并启动 handlers 的流程就出来了：</p>
<ol>
<li><p>通过配置 <code>protocolHandlerDirectory</code> 找到目录下所有 nar 包并解压，通过解析 YAML 文件得到 handler 的名字和主类，通过 <code>NarClassLoader</code> 加载主类并转型为 <code>ProtocolHandler</code> 接口；</p>
</li>
<li><p>调用 handler 的 <code>accept</code> 方法判断协议是否被接受，加载所有接受的 handlers；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(String protocol)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传入 broker 的配置到 <code>initialize</code> 中初始化加载的 handlers；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ServiceConfiguration conf)</span> <span class="keyword">throws</span> Exception;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将 <code>BrokerService</code> 对象传入各 handler 的 <code>start</code> 方法启动</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">(BrokerService service)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 handler 对应的 channel initializers 交由 <code>BrokerService</code> 启动，也就是在这一步，handler 被单独作为一个服务启动，比如 KoP 在这里就会默认绑定 9092 端口提供服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;InetSocketAddress, ChannelInitializer&lt;SocketChannel&gt;&gt; <span class="title function_">newChannelInitializers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这几步完成后，broker 就不会干预 handler 了，除非 broker 本身关闭。而 handler 作为一个相对独立的服务，和 broker 的交互全部借由 <code>start()</code> 方法中得到的 <code>BrokerService</code> 对象来进行。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/07/Java-CompletableFuture-%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/Java-CompletableFuture-%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java CompletableFuture 学习</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-07 21:35:08" itemprop="dateCreated datePublished" datetime="2020-10-07T21:35:08+08:00">2020-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了一段时间 Pulsar 代码，令人印象最深的就是整个异步处理都是基于 Java 8 引入的 <code>CompletableFuture</code>。作为 C++er 相对而言更为熟悉普通的 Future 和 Promise。Future 表示一个异步任务，即在 <strong>未来（future）</strong> 某个时间点完成的任务，而 Promise 则表示这个 <code>Future</code> 的完成状态（是否完成，以及完成结果正常的还是异常的）。因此 Promise 是绑定于某个 Future 的，一般而言，即可以等待 Future 自然完成，也可以提前操作 Promise 使得 Future 提前完成。</p>
<p>Java 1.5 引入了 <code>Future</code>  接口，但过于简单。Java 8 提供<code>CompletableFuture</code>（下文简称 future）用起来则更像 Future 和 Promise 的结合，本文将通过简单的例子来稍微系统地学习下 <code>CompletableFuture</code>。</p>
<h2 id="状态的访问和设置"><a href="#状态的访问和设置" class="headerlink" title="状态的访问和设置"></a>状态的访问和设置</h2><p>首先给出一个主线程使用 <code>CompletableFuture</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个 future，其返回结果是 Integer</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">System.out.println(future.getNow(-<span class="number">1</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="comment">// 2. 使这个 future 完成</span></span><br><span class="line">future.complete(<span class="number">10</span>);</span><br><span class="line">System.out.println(future.getNow(-<span class="number">1</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>涉及到的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getNow</span><span class="params">(T valueIfAbsent)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">complete</span><span class="params">(T value)</span>;</span><br></pre></td></tr></table></figure>

<p>其中，<code>getNow()</code> 方法表示取得 Future 完成结果（如果未完成则返回 <code>valueIfAbsent</code>），默认创建的 future 是未完成的，因此第一次打印结果是 -1，第二次打印时由于调用了 <code>complete()</code> 方法使 future 完成了，因此 <code>getNow()</code> 取得了 <code>value</code> 并返回。</p>
<p>对比一般的 <code>Future</code>，<code>CompletableFuture</code> 实现了完成状态的访问和设置，而 <code>Future</code> 只能通过 <code>get</code> 方法被动等待 future 完成（可以无限等待也可以设置超时），无法设置状态，要取得瞬时状态只能调用 <code>isDone()</code> 来判断是否完成，若完成，则可以安心调用 <code>get()</code> 避免阻塞。</p>
<p>另外，除了设置返回结果（正常状态）外，还可以抛出异常（异常状态）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 主动设置 future 为异常完成状态</span></span><br><span class="line">future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;failed&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(future.getNow(-<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caused by &quot;</span> + e.getCause());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">completeExceptionally</span><span class="params">(Throwable ex)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="在多线程的使用"><a href="#在多线程的使用" class="headerlink" title="在多线程的使用"></a>在多线程的使用</h2><p>一般的异步任务都会借助多线程来实现，避免主线程阻塞。类似于 <code>ExecutorService</code> 的  <code>execute()</code> 和 <code>submit()</code> 方法，<code>CompletableFuture</code> 也提供两种方法来分别执行无返回值和有返回值的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncRunStage(asyncPool, runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> asyncSupplyStage(asyncPool, supplier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中  <code>Supplier</code> 和 <code>Callable</code> 类似，都是实现了 <code>T get()</code> 的接口，区别在于前者没有异常声明。</p>
<p>注意到这里都用到了 <code>asyncPool</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">useCommonPool</span> <span class="operator">=</span></span><br><span class="line">    (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Default executor -- ForkJoinPool.commonPool() unless it cannot</span></span><br><span class="line"><span class="comment"> * support parallelism.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">asyncPool</span> <span class="operator">=</span> useCommonPool ?</span><br><span class="line">    ForkJoinPool.commonPool() : <span class="keyword">new</span> <span class="title class_">ThreadPerTaskExecutor</span>();</span><br></pre></td></tr></table></figure>

<p>在合适的时候会使用 <code>ForkJoinPool</code> 框架去调度 future 对应的异步任务，也就是 future 和 thread 不一定是一对一的关系，从而支持了大量异步任务的调度。</p>
<p>PS： <code>ForkJoinPool</code> 并不是本文的重点，之后再去学习。</p>
<p>而 <code>runAsync</code> 和 <code>supplyAsync</code> 也都支持自定义 executor 的形式，即根据合适的场景提供自定义的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable,</span></span><br><span class="line"><span class="params">                                               Executor executor)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier,</span></span><br><span class="line"><span class="params">                                                   Executor executor)</span>;</span><br></pre></td></tr></table></figure>

<p>给出示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;future1 done&quot;</span>));</span><br><span class="line">CompletableFuture&lt;Void&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;future2 done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>这里特地给出 <code>supplyAsync</code> 创建 <code>CompletableFuture&lt;Void&gt;</code> 的情况，由于 <code>Supplier</code> 接口的方法具有返回类型 <code>T</code>，因此必须显式返回 <code>null</code>。这也是我从 Scala 转向 Java 时一个比较不适应的地方，因为 Scala 不需要 <code>return</code> 语句就能返回结果（即最后一个表达式的返回值），而 Java 由于语法限制，这里必须显式返回。当然，直接创建 <code>Completable&lt;Void&gt;</code> 的时候用 <code>runAsync</code> 就好了，但是对于多个 future 的链式调用，有时候必须传入 <code>Supplier</code>，因此了解这点也很重要。</p>
<p>另一个常见用法是兼容旧接口，比如原来的 API 是通过回调来表示任务完成的，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncTask</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Consumer&lt;String&gt; callback)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> compute();</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">null</span>) &#123;</span><br><span class="line">            callback.accept(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 耗时操作... */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，我们只要在 <code>Runnable</code> 中设置 future 状态即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">CompletableFuture&lt;String&gt; future = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">executor.execute(() -&gt; <span class="keyword">new</span> <span class="title class_">AsyncTask</span>().run(future::complete));</span><br></pre></td></tr></table></figure>

<h2 id="多任务链式调用"><a href="#多任务链式调用" class="headerlink" title="多任务链式调用"></a>多任务链式调用</h2><h3 id="thenApply"><a href="#thenApply" class="headerlink" title="thenApply"></a>thenApply</h3><p>相比直接创建线程并结合 <code>join()</code>&#x2F;<code>detach()</code> 这种方法来执行异步任务，future 最为灵活的一点就是支持多个任务的组合，比如现在有个任务：</p>
<ol>
<li>进行服务发现；</li>
<li>连接刚才发现的服务。</li>
</ol>
<p>第二步依赖于第一步的成功返回，执行同步任务时直接顺序写下来就行，但执行异步任务时，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; serviceDiscoveryFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">/* 进行服务发现... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;http://localhost:8080&quot;</span>; <span class="comment">// 返回发现的 URL</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们不能在这里直接等待 <code>serviceDiscoveryFuture</code> 完成，因为这样相当于异步操作就变成同步操作了，可能阻塞当前线程。</p>
<p><code>CompletableFuture</code> 提供了一系列方法来进行链式调用，比如上面的任务可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; connectServiceFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="comment">/* 1. 服务发现... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;http://localhost:8080&quot;</span>;</span><br><span class="line">&#125;).thenApply((serverUrl) -&gt; &#123;</span><br><span class="line">    <span class="comment">/* 2. 连接服务... */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Connected to &quot;</span> + serverUrl);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，只有第一个异步任务成功返回时才会将返回结果作为输入参数应用于第二个任务。</p>
<p>看看 <code>thenApply</code> 的方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenApply</span><span class="params">(Function&lt;? <span class="built_in">super</span> T,? extends U&gt; fn)</span>;</span><br></pre></td></tr></table></figure>

<p>传入的是 <code>Function</code> 对象，也就是输入参数类型可以是 <code>T</code>（当前 future 的返回类型）的派生类，而返回类型则是 <code>U</code> 的派生类，通过 lambda 表达式中 <code>return</code> 的结果进行推导。</p>
<h3 id="thenCompose"><a href="#thenCompose" class="headerlink" title="thenCompose"></a>thenCompose</h3><p>在一些异步任务已经被封装成返回 future 的方法时，<code>thenApply</code> 无法复用这些方法。</p>
<p>在前一节的连接服务为例的基础上，用一个整型状态码表示连接的服务（返回 0 代表成功）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;String&gt; <span class="title function_">discoverServiceAsync</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* 服务发现... */</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;http://localhost:8080&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Integer&gt; <span class="title function_">connectServiceAsync</span><span class="params">(String serviceUrl)</span> &#123;</span><br><span class="line">    <span class="comment">/* 连接服务... */</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Connected to &quot;</span> + serviceUrl);</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：这里用了静态方法 <code>completedFuture</code> 来得到已完成的 future（默认构造的 future 是未完成的）。</p>
<p>如果我们要添加第三步：对状态码进行处理，由于现有的方法都是返回 <code>CompletableFuture&lt;T&gt;</code> 而非 <code>T</code>，因此 <code>thenApply</code> 此时无能为力：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = discoverServiceAsync().thenAccept(serviceUrl -&gt; &#123;</span><br><span class="line">    CompletableFuture&lt;Integer&gt; statusFuture = connectServiceAsync(serviceUrl);</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 无法处理 statusFuture</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时 <code>thenCompose</code> 就有用武之地了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = discoverServiceAsync().thenCompose((serviceUrl) -&gt; &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">return</span> connectServiceAsync(serviceUrl);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>再看看其方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">thenCompose</span><span class="params">(</span></span><br><span class="line"><span class="params">    Function&lt;? <span class="built_in">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span><br></pre></td></tr></table></figure>

<p><code>CompletionStage</code> 接口表示异步处理的一个 <strong>阶段（stage）</strong>，而 <code>CompletableFuture</code> 实现了该接口（另一个实现的接口是 <code>Future</code>），因此该 <code>Function</code> 可以传入返回 <code>CompletableFuture</code> 的 lambda 表达式。</p>
<p>也就是说 <code>thenCompose</code> 可以将返回的 stage 作为当前 future 的新 stage。上面得到的 <code>future</code> 会等到 <code>connectServiceAsync</code> 返回的 <code>CompletableFuture</code> 完成时才算完成。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>前两节都是讨论 future 正常完成时的链式调用，虽然异常完成时在 future 调用 <code>get()</code> 时会抛出异常，但是有时候会对异常进行处理，比如：</p>
<ol>
<li>进行服务发现；</li>
<li>若发现成功，连接服务；</li>
<li>否则使用本地 HTTP 服务 <code>http://localhost:8080</code>。</li>
</ol>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (args.length &gt; <span class="number">0</span>) ? args[<span class="number">0</span>] : <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;pulsar&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;pulsar://localhost:6650&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown server name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">        System.out.println(e.getCause() + <span class="string">&quot;, use HTTP service&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://localhost:8080&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(future.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是看看方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span> </span><br></pre></td></tr></table></figure>

<p>输入参数是抛出的异常，而返回类型则仍然是 future 泛型 <code>T</code> 的派生类。</p>
<p>如果并不想对异常进行一些挽救的处理，只想打印下日志，那么可以返回 <code>null</code>，因为任何类型都可以被赋值为 <code>null</code>，此时推断的类型仍为 <code>T</code>。但对于这种情况，除了结合 <code>thenApply</code> 和 <code>exceptionally</code>，也可以使用 <code>whenComplete</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">&quot;pulsar&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pulsar://localhost:6650&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown server name: &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).whenComplete((serviceUrl, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Connected to &quot;</span> + serviceUrl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Failed to connect to &quot;</span> + name + <span class="string">&quot;: &quot;</span> + e.getCause());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>看看方法签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title function_">whenComplete</span><span class="params">(</span></span><br><span class="line"><span class="params">    BiConsumer&lt;? <span class="built_in">super</span> T, ? <span class="built_in">super</span> Throwable&gt; action)</span></span><br></pre></td></tr></table></figure>

<p>传入的是接受返回结果和异常的 <code>BiConsumer</code>，缺点是无法针对异常进行挽救，future 调用 <code>get()</code> 方法仍然会抛出异常，而在 <code>exceptionally</code> 中对异常进行处理并返回 <code>null</code> 的话，之后 future 调用 <code>get()</code> 不会抛出异常，而只是返回 <code>null</code>。</p>
<h2 id="合并并行异步任务的结果"><a href="#合并并行异步任务的结果" class="headerlink" title="合并并行异步任务的结果"></a>合并并行异步任务的结果</h2><p>链式调用解决的是串行异步任务，也就是一个异步任务的启动要依赖另一个异步任务的结果，但有时候会遇到并行的异步任务，比如对数组分块求和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] indexes = &#123;<span class="number">0</span>, array.length / <span class="number">2</span>, array.length&#125;;</span><br><span class="line">List&lt;CompletableFuture&lt;Integer&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indexes.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> indexes[i];</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> indexes[i + <span class="number">1</span>];</span><br><span class="line">    futures.add(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt; end; j++) &#123;</span><br><span class="line">            sum += array[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在要等待多个 <code>future</code> 完成，如果我们设置了超时时间比如 1 秒，那么要得到的结果实际上是 <code>List&lt;Integer&gt;</code>，此时可以用 <code>allOf</code> 方法将 future 列表转换成结果列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture.allOf(futures.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[<span class="number">0</span>])).get();</span><br><span class="line">List&lt;Integer&gt; results =</span><br><span class="line">    futures.stream().map(future -&gt; future.getNow(-<span class="number">1</span>)).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// results: [6, 15]</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>allOf</code> 返回的是 <code>CompletableFuture&lt;Void&gt;</code>，因此只能用来等待所有 future 完成或者其中一个失败。将结果重新组合成 <code>List</code> 还是得另外执行，看起来 Java 没有 Scala 的 <code>Future#sequence</code> 这样方便的方法。</p>
<p>类似地，<code>anyOf</code> 则是等待任意一个 future 完成，这里就不给例子了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单学习了 Java 中 <code>CompletableFuture</code> 常用的使用场景，由于语法本身的限制，比起 Scala 的 <code>Future</code> 还是略显麻烦，但至少 <code>CompletableFuture</code> 的出现使得异步编程变得更加容易。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/03/Linux-C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-SIGKILL-%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/Linux-C-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-SIGKILL-%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Linux C++ 内存分配 SIGKILL 问题</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-03 16:43:26" itemprop="dateCreated datePublished" datetime="2020-09-03T16:43:26+08:00">2020-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在代码里看到发现某对象有个 buffer 每次会分配较大内存（定义一个大的 <code>vector</code>），担心如果对象太多会导致 <code>vector</code> 内存分配失败，于是自己写了个简单测试看能不能捕获 <code>bad_alloc</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;  <span class="comment">// 1 MiB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; INT_MAX - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed at &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;th allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较遗憾的是，运行直接显示 Killed 崩溃，在 Linux 上也就是收到了 <code>SIGKILL</code> 信号。这让我想起来当初压测某 C++ 客户端时，对于 500 个分区的 topic，在限制内存为 1 GB 的容器中运行 C++ 客户端，很多都会直接 Killed，日志里也没异常信息。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>C 标准库的内存分配是使用 <code>malloc</code>（以及 <code>calloc</code>&#x2F;<code>realloc</code>，这三者类似，这里不讲区别），它的使用很简单，分配失败就返回 <code>NULL</code>，见 man page：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The malloc() <span class="keyword">function</span> allocates size bytes <span class="keyword">and</span> <span class="keyword">returns</span> a pointer <span class="keyword">to</span></span><br><span class="line">the allocated memory.  The memory <span class="keyword">is</span> <span class="keyword">not</span> initialized.  <span class="keyword">If</span> size <span class="keyword">is</span> <span class="number">0</span>,</span><br><span class="line"><span class="keyword">then</span> malloc() <span class="keyword">returns</span> either <span class="keyword">NULL</span>, <span class="keyword">or</span> a <span class="keyword">unique</span> pointer <span class="keyword">value</span> that can</span><br><span class="line">later be successfully passed <span class="keyword">to</span> free().</span><br></pre></td></tr></table></figure>

<p>C++ 的 <code>new</code> 则是分为两步，首先是调用 <code>operator new</code> 分配内存，然后就地构造（placement new），对于基本类型就是内存拷贝，对于类而言调用构造函数。</p>
<p>一般而言分配内存是前一步，大概是直接包的 <code>malloc</code>，相比而言，C++ 可以重写 <code>operator new</code> 来执行自定义内存分配策略，虽然 C 替代 <code>malloc</code> 也可以，但不一定通用。C++ <code>new</code> 失败不会返回空指针，而是会抛出 <code>std::bad_alloc</code> 异常。</p>
<p>STL 内存分配则又是一回事，为了能让用户能更精确掌控内存分配（而不是受到 <code>new</code> 的制约），它提供了一个 <code>std::allocator&lt;T&gt;</code> 类模板进行默认的内存分配，而用户可以自行实现接口作为自己的内存分配策略。当然，是不是包的 <code>operator new</code> 我也没去细看。</p>
<p>怀疑是 STL allocator 的问题，于是这里用 <code>new</code> 来替代 STL allocator 看看，由于 <code>vector</code> 一般实现是 3 个指针，所以这里也模拟了实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> size = <span class="number">1024</span> * <span class="number">1024</span>;  <span class="comment">// 1 MiB</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VectorInt</span> &#123;</span><br><span class="line">  <span class="type">int</span>* start;</span><br><span class="line">  <span class="type">int</span>* finish;</span><br><span class="line">  <span class="type">int</span>* end;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; i++) &#123;</span><br><span class="line">      <span class="keyword">auto</span> p = <span class="keyword">new</span> VectorInt;</span><br><span class="line">      p-&gt;start = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed at &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;th allocate&quot;</span> &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果还是收到 <code>SIGKILL</code> 了。把 <code>new</code> 改成 <code>malloc</code> 并检查返回值是否为空，结果也是一样。</p>
<h2 id="malloc-真的会返回-NULL-吗？"><a href="#malloc-真的会返回-NULL-吗？" class="headerlink" title="malloc 真的会返回 NULL 吗？"></a>malloc 真的会返回 NULL 吗？</h2><p>虽然答案显然是会，毕竟如果不会，那肯定不会是我第一个发现。所以我简单试了下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%d] malloc failed: %s\n&quot;</span>, i, <span class="built_in">strerror</span>(errno));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还是收到 <code>SIGKILL</code> 了。这里我想起了之前看《STL 源码剖析》时，SGI STL 内存分配器对于小内存分配会进行优化，我想 <code>malloc</code> 应该也会，可能是我单次分配的内存（<code>sizeof(int)</code>，4 字节）太小了，于是我开始尝试增加单次分配的字节数来观察现象。</p>
<ul>
<li><p>4 B：Killed</p>
</li>
<li><p>4 KiB：Killed</p>
</li>
<li><p>4 MiB：Killed</p>
</li>
<li><p>20 MiB：Killed</p>
</li>
<li><p>80 MiB：Killed</p>
</li>
<li><p>1 GiB：没有被 Killed，运行多次的结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[131070]</span> malloc failed: Cannot allocate memory</span><br><span class="line"><span class="string">[131071]</span> malloc failed: Cannot allocate memory</span><br><span class="line"><span class="string">[131070]</span> malloc failed: Cannot allocate memory</span><br><span class="line"><span class="string">[131071]</span> malloc failed: Cannot allocate memory</span><br><span class="line"><span class="string">[131071]</span> malloc failed: Cannot allocate memory</span><br></pre></td></tr></table></figure></li>
</ul>
<p>用 <code>strace</code> 重新运行查看系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brk(<span class="number">0x27a60149a000</span>)                     = <span class="number">0x27a5c149a000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073876992</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOMEM (Cannot allocate memory)</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">134217728</span>, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x3fe58dc4e000</span></span><br><span class="line">munmap(<span class="number">0x3fe58dc4e000</span>, <span class="number">37429248</span>)        = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x3fe594000000</span>, <span class="number">29679616</span>)        = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x3fe590000000</span>, <span class="number">135168</span>, PROT_READ|PROT_WRITE) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOMEM (Cannot allocate memory)</span><br><span class="line">fstat(<span class="number">1</span>, &#123;st_mode=S_IFCHR|<span class="number">0620</span>, st_rdev=makedev(<span class="number">136</span>, <span class="number">3</span>), ...&#125;) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fe5a6a28000</span></span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;[106135] malloc failed: Cannot a&quot;</span>..., <span class="number">47</span>) = <span class="number">47</span></span><br></pre></td></tr></table></figure>

<p>在此之前是大量的 <code>brk</code>，也就是说每次运行 <code>malloc</code> 其实都是调用 <code>brk</code>。而导致 <code>malloc</code> 出错的是 <code>mmap</code>，它设置了错误码 <code>ENOMEM</code>，也就是 <code>malloc</code> 的 man page 里提到的错误码，表示内存不足。</p>
<p>将单词内存分配大小改回 128 MiB 试试（512 MiB 仍然能正常终止），最后几次系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brk(<span class="number">0x181922339000</span>)                     = <span class="number">0x181922339000</span></span><br><span class="line">brk(<span class="number">0x18192a339000</span> &lt;ptrace(SYSCALL):No such process&gt;</span><br><span class="line">+++ killed by SIGKILL +++</span><br></pre></td></tr></table></figure>

<p>发现并没有调用 <code>mmap</code>，而是持续调用 <code>brk</code>，直到收到 <code>SIGKILL</code>。</p>
<h2 id="brk-和-mmap-系统调用"><a href="#brk-和-mmap-系统调用" class="headerlink" title="brk 和 mmap 系统调用"></a>brk 和 mmap 系统调用</h2><p>从前一节可知，这里出问题的并不是 STL allocator，而是 <code>malloc</code> 本身。而之前一直在调用 <code>brk</code>。还是参考 man page，这里首先得弄清楚 program break 的概念，首先看下进程虚拟地址空间分布（最简单的模型）：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">high address +--------------------+</span><br><span class="line">             |<span class="string">                    </span>|</span><br><span class="line">             |<span class="string">                    </span>|</span><br><span class="line">             +--------------------+</span><br><span class="line">             |<span class="string">       stack        </span>|</span><br><span class="line">             +---------+----------+</span><br><span class="line">             |<span class="string">         </span>|<span class="string">          </span>|</span><br><span class="line">             |<span class="string">         </span>|<span class="string">          </span>|</span><br><span class="line">             |<span class="string">         v          </span>|</span><br><span class="line">             |<span class="string">                    </span>|</span><br><span class="line">             |<span class="string">                    </span>|</span><br><span class="line">             |<span class="string">                    </span>|</span><br><span class="line">             |<span class="string">         ^          </span>|</span><br><span class="line">             |<span class="string">         </span>|<span class="string">          </span>|</span><br><span class="line">             |<span class="string">         </span>|<span class="string">          </span>|</span><br><span class="line">             +---------+----------+</span><br><span class="line">             |<span class="string">        heap        </span>|</span><br><span class="line">             +--------------------+</span><br><span class="line">             |<span class="string"> uninitialized data </span>|</span><br><span class="line">             |<span class="string">       (bss)        </span>|</span><br><span class="line">             +--------------------+</span><br><span class="line">             |<span class="string">  initialized data  </span>|</span><br><span class="line">             +--------------------+</span><br><span class="line">             |<span class="string">       text         </span>|</span><br><span class="line"> low address +--------------------+</span><br></pre></td></tr></table></figure>

<p>program break 就是 bss 段上面的第一个地址。<code>brk</code> 的函数签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">brk</span><span class="params">(<span class="type">void</span> *addr)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> increment)</span>;</span><br></pre></td></tr></table></figure>

<p><code>brk</code> 的作用是改变 program break 的位置为 <code>addr</code>。增加 <code>addr</code> 相当于申请空间。至于 <code>sbrk</code> 则是增加而非设置。</p>
<p>这里以一个最简单的内存申请为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure>

<p>对应系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0x2112000</span></span><br><span class="line">brk(<span class="number">0x2144000</span>)                          = <span class="number">0x2144000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fb6338d2000</span></span><br></pre></td></tr></table></figure>

<p>第一次调用是 <code>brk(0)</code>，返回的不是 0 而是 0x2112000，也就是最初状态下 bss 段上面的第一个地址。后面移动到了新位置，增加了 program break，0x2144000 - 0x2112000 &#x3D; 0x0032000，也就是 204800 字节，即 197 KiB，显然是不足 10 MiB。</p>
<p>然而接下来的 <code>mmap</code> 第二个参数，10489856 刚好是 10 MiB。<code>brk</code> 只是调整 program break，这只是虚拟地址空间的一个标记，如果要使用这块内存，需要用 <code>mmap</code> 进行映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>addr</code>：为 <code>NULL</code> 则由内核选择首地址（满足页对齐），即使不为 <code>NULL</code>，也只是内核根据这个值作为提示信息来选择。</li>
<li><code>length</code>：映射的字节数，实际上会被提升至分页大小（<code>sysconf(_SC_PAGE_SIZE)</code>）的整数倍。</li>
<li><code>prot</code>：保护等级，为 <code>PROT_NONE</code>（无法访问）或者 <code>PROT_READ</code>（可读）&#x2F;<code>PROT_WRITE</code>（可写）&#x2F;<code>PROT_EXEC</code>（可执行）的组合。如果对这部分内存映射违反了保护等级，会产生 <code>SIGSEGV</code> 信号，也就是常见的段错误（segmentation fault）。</li>
<li><code>flags</code>：<code>MAP_PRIVATE</code>（私有映射）或者 <code>MAP_SHARED</code>（共享映射），前者是对其他进程不可见，后者是可见的，也就是共享内存。</li>
</ul>
<p>最终内存会映射到从文件描述符 <code>fd</code> 对应的文件的偏移量 <code>offset</code> 处开始，注意 <code>offset</code> 也必须是分页大小的倍数。如果 <code>fd</code> 为 -1，则不映射到文件。</p>
<p>回顾之前的调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">10489856</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fb6338d2000</span></span><br></pre></td></tr></table></figure>

<p>也就是将物理内存的 10 MiB 给映射到堆的虚拟内存空间。</p>
<p>至于 <code>munmap</code> 即删除映射，<code>addr</code> 为对应 <code>mmap</code> 的返回值。</p>
<h2 id="malloc-小内存为何不返回-NULL？"><a href="#malloc-小内存为何不返回-NULL？" class="headerlink" title="malloc 小内存为何不返回 NULL？"></a>malloc 小内存为何不返回 NULL？</h2><p>刚才了解了 <code>brk</code> 和 <code>mmap</code> 结合前文内容，我们可知只有 <code>mmap</code> 进行内存映射失败（比如物理内存不够）<code>malloc</code> 才会返回 <code>NULL</code> 并将 <code>errno</code> 置为 <code>ENOMEM</code>。但是对于频繁申请小内存的情况，则是无限调用 <code>brk</code> 导致内存崩溃，并没有出现 <code>mmap</code>。回到第一节的代码（无限创建 1 MiB 的 <code>vector</code>），用 <code>strace</code> 观察的结果是无限调用 <code>mmap</code> 导致内存崩溃：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4198400</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f3fdead1000</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">4198400</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7f3e9ddcf000</span></span><br><span class="line">+++ killed by SIGKILL +++</span><br></pre></td></tr></table></figure>

<p>可见每次 <code>mmap</code> 长度上限也就 4198400（差不多 4 MiB）。</p>
<p>而假如 <code>vector</code> 大小改成 256 MiB，那么对应 <code>strace</code> 信息为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">brk(<span class="number">0</span>)                                  = <span class="number">0xcbb000</span></span><br><span class="line">brk(<span class="number">0xced000</span>)                           = <span class="number">0xced000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdda8485000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdd68484000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdd28483000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdce8482000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdca8481000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOMEM (Cannot allocate memory)</span><br><span class="line">brk(<span class="number">0x40ced000</span>)                         = <span class="number">0xced000</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073876992</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOMEM (Cannot allocate memory)</span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">134217728</span>, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">0x7fdca0481000</span></span><br><span class="line">munmap(<span class="number">0x7fdca0481000</span>, <span class="number">62386176</span>)        = <span class="number">0</span></span><br><span class="line">munmap(<span class="number">0x7fdca8000000</span>, <span class="number">4722688</span>)         = <span class="number">0</span></span><br><span class="line">mprotect(<span class="number">0x7fdca4000000</span>, <span class="number">135168</span>, PROT_READ|PROT_WRITE) = <span class="number">0</span></span><br><span class="line">mmap(<span class="literal">NULL</span>, <span class="number">1073745920</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>) = <span class="number">-1</span> ENOMEM (Cannot allocate memory)</span><br></pre></td></tr></table></figure>

<p>每次 <code>mmap</code> 长度是 1073745920，差不多 1 GiB。这么看，其实根本原因在于 <code>malloc</code> 实现（调用 <code>brk</code> 和 <code>mmap</code>），因为 <code>malloc</code> 允许较为高效的小内存分配（比如它不会因为 N 次 <code>int</code> 的分配就调用 N 次 <code>brk</code>）。</p>
<p>其实在 <code>malloc</code> 的 man page 上面就可以看到原因，以下内容摘自 NOTE 部分。</p>
<blockquote>
<p>默认情况下，Linux 遵循乐观的内存分配策略，也就是 <code>malloc</code> 返回非 <code>NULL</code> 时，无法保证内存确实可用，如果系统 OOM 了，进程会被 OOM killer 干掉，也就是 OOM killer 发送 <code>SIGKILL</code> 信号。</p>
<p>通常 <code>malloc()</code> 从堆上分配内存，并使用 <code>sbrk()</code> 调整堆的大小。当分配的内存块字节数大于 <code>MMAP_THRESHOLD</code> 时，glibc 的 <code>malloc()</code> 实现使用 <code>mmap()</code> 进行私有匿名映射来分配内存。MMAP_THRESHOLD 默认 128 kB，但是可以通过 <code>mallopt()</code> 进行调整。</p>
</blockquote>
<p>这也说明了，为啥分配大容量 <code>vector</code> 时是一直调用 <code>mmap</code>，而分配 <code>int</code> 时则是一直调用 <code>brk</code>。</p>
<p><code>mmap</code> 的大小也有区别，每次映射 4198400 字节时，最后引向的是 <code>SIGKILL</code>，而每次映射 1073745920 字节时，最后得到的是错误码 <code>ENOMEM</code>。从上述文档可知，前者应该是触发 OOM killer 了，也就是映射了较小的内存，但不一定保证可用就返回了。也就是所谓的 <strong>乐观内存分配策略</strong> 导致的。</p>
<p>在 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/11779042/sigkill-while-allocating-memory-in-c">sigkill while allocating memory in c</a> 这个讨论帖有讲，简单说就是：</p>
<ul>
<li><code>new</code> 或 <code>malloc</code> 可能从内核拿到了一个不合法的地址，即使没有足够的内存，因为：<ol>
<li>内核直到第一次访问时才分配地址</li>
<li>如果所有的 overcommited 内存都被使用，操作系统只能杀死其中的一个进程（也就是 OOM killer）。</li>
</ol>
</li>
</ul>
<p>OOM killer 可参考： <a target="_blank" rel="noopener" href="https://linux-mm.org/OOM_Killer">https://linux-mm.org/OOM_Killer</a></p>
<p>简单说就是牺牲一个或多个进程，以便在其他进程故障时为系统释放进程。</p>
<p>那 overcommited 内存呢？它是一个内存分配策略，其值记录在 <code> /proc/sys/vm/overcommit_memory</code> 文件。所谓 overcommit，就是过度提交，其实也就是刚才说的，内核直到第一次访问时才分配地址，否则即使请求的内存超过限制，只要不去访问，内核仍然当作可用。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/39721013/how-to-check-if-malloc-overcommits-memory">how to check if malloc overcommits memory</a> 给出了几种解决方法，方法 2 我是开启了 <code>--oom-kill-disable</code> 选项启动 docker，但还是一样。可能是哪里操作不对。方法 3（在 <code>malloc</code> 后进行写入）可能会花很长时间来分配较大内存，但是仍然可能被 kill。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux 上，在某些情况下 <code>malloc</code> 即使返回非 <code>NULL</code> 值，由于内核的 overcommit 内存分配策略，也有可能导致这片内存不是可用的，这种内存泄漏累积的结果就是导致进程被 OOM killer 干掉（发送 <code>SIGKILL</code> 信号，无法被捕获）。</p>
<p>单次 <code>malloc</code> 申请较大的内存可以规避这点，因为即使有 overcommit 策略，也不可能超过可用太多。</p>
<p>总之，如果是在限制内存（比如 docker）的环境下运行 C++ 程序，内存分配失败不一定会以 <code>std::bad_alloc</code> 结束，此时会拿不到异常栈信息。虽然用 <code>dmesg</code> 能够找到 OOM 记录，但对调试的帮助仍然有限。这种时候，根本性的解决方案还是自定义内存分配器。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XYZ, aka BewareMyPower</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYZ, aka BewareMyPower</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
