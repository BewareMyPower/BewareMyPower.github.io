<!DOCTYPE html>
<html lang="Chinese">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="[toc] 前言之前对 Pulsar 消费端的逻辑不太熟悉，但是一直有印象就是刚接触 Pulsar 时，不记得在哪看到 Pulsar 的消费模型是 push 的，而这点和 Kafka 的 pull 消费模型是完全不同的。之前对于 Kafka 的消费模型已经比较熟悉了，客户端发送 FETCH 请求，其中对于需要拉取（pull）数据的每个 partition，请求中会有一个 partition_max">
<meta property="og:type" content="article">
<meta property="og:title" content="Pulsar 源码阅读 - 消费者的订阅">
<meta property="og:url" content="http://yoursite.com/2021/09/02/Pulsar-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%AE%A2%E9%98%85/index.html">
<meta property="og:site_name" content="BewareMyPower的博客">
<meta property="og:description" content="[toc] 前言之前对 Pulsar 消费端的逻辑不太熟悉，但是一直有印象就是刚接触 Pulsar 时，不记得在哪看到 Pulsar 的消费模型是 push 的，而这点和 Kafka 的 pull 消费模型是完全不同的。之前对于 Kafka 的消费模型已经比较熟悉了，客户端发送 FETCH 请求，其中对于需要拉取（pull）数据的每个 partition，请求中会有一个 partition_max">
<meta property="og:locale">
<meta property="og:image" content="http://pulsar.apache.org/docs/assets/binary-protocol-consumer.png">
<meta property="article:published_time" content="2021-09-02T12:58:55.000Z">
<meta property="article:modified_time" content="2022-02-26T17:27:10.227Z">
<meta property="article:author" content="XYZ, aka BewareMyPower">
<meta property="article:tag" content="Pulsar">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://pulsar.apache.org/docs/assets/binary-protocol-consumer.png">

<link rel="canonical" href="http://yoursite.com/2021/09/02/Pulsar-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%AE%A2%E9%98%85/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Pulsar 源码阅读 - 消费者的订阅 | BewareMyPower的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BewareMyPower的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="Chinese">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/09/02/Pulsar-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E8%AE%A2%E9%98%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XYZ, aka BewareMyPower">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BewareMyPower的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Pulsar 源码阅读 - 消费者的订阅
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-02 20:58:55" itemprop="dateCreated datePublished" datetime="2021-09-02T20:58:55+08:00">2021-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-27 01:27:10" itemprop="dateModified" datetime="2022-02-27T01:27:10+08:00">2022-02-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前对 Pulsar 消费端的逻辑不太熟悉，但是一直有印象就是刚接触 Pulsar 时，不记得在哪看到 Pulsar 的消费模型是 push 的，而这点和 Kafka 的 pull 消费模型是完全不同的。之前对于 Kafka 的消费模型已经比较熟悉了，客户端发送 FETCH 请求，其中对于需要拉取（pull）数据的每个 partition，请求中会有一个 <code>partition_max_bytes</code> 字段限制该分区获取的最大字节数。而从 FETCH v3 开始，还有个总的 <code>max_bytes</code> 字段限制总的最大字节数来针对分区太多的场合。具体协议参见 <a target="_blank" rel="noopener" href="https://kafka.apache.org/protocol#The_Messages_Fetch">Kafka Message Fetch</a>。</p>
<p>那么，Pulsar 采用的 push 消费模型是怎样的呢？为什么要采用 push 消费模型呢？带着这些问题，开始阅读源码，本文采用 Pulsar 2.8.0 的源码（实际是 master 分支），因此和之前的 release 版本可能有些许出入。</p>
<blockquote>
<p>本文在阅读源码时，会略去一些相对不核心的代码，必须合法性检查&#x2F;异常处理&#x2F;错误日志，此时会用 &#x2F;* … *&#x2F; 的风格来略去这一部分，而代码分析则统一使用 &#x2F;&#x2F; 注释风格。</p>
</blockquote>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>参见 Pulsar 官网文档 <a target="_blank" rel="noopener" href="http://pulsar.apache.org/docs/en/develop-binary-protocol/#consumer">Binary Protocol: Consumer</a>：</p>
<p><img src="http://pulsar.apache.org/docs/assets/binary-protocol-consumer.png" alt="consumer"></p>
<p>重点是客户端发送 Flow 请求，然后broker 回复消息。重点是流控的处理。这里先看看 <code>PulsarApi.proto</code> 中的定义（位于 <code>org.apache.pulsar.common.api.proto</code> 包）：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">CommandFlow</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint64</span> consumer_id       = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Max number of messages to prefetch, in addition</span></span><br><span class="line">    <span class="comment">// of any number previously specified</span></span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint32</span> messagePermits     = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了消费者 id 外，它只需要一个 permits 参数，表示 prefetch（提前获取）的最大消息数量。</p>
<p>再来看看文档的介绍。典型的消费者实现会在应用程序准备消费之前使用队列积累这些消息，在应用程序队列已经入队了半数以上消息时，消费者发送 permits 给 broker 来请求更多的消息（其数量等于队列大小的一半）。</p>
<h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><p>首先给出一份最简单的客户端消费的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">PulsarClient</span> <span class="variable">client</span> <span class="operator">=</span> PulsarClient.builder()</span><br><span class="line">        .serviceUrl(<span class="string">&quot;pulsar://localhost:6650&quot;</span>)</span><br><span class="line">        .build()) &#123;</span><br><span class="line">    Consumer&lt;<span class="type">byte</span>[]&gt; consumer = client.newConsumer()</span><br><span class="line">            .topic(<span class="string">&quot;my-topic&quot;</span>)</span><br><span class="line">            .subscriptionName(<span class="string">&quot;my-sub&quot;</span>)</span><br><span class="line">            .subscribe();</span><br><span class="line">    Message&lt;<span class="type">byte</span>[]&gt; message = consumer.receive();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> handle the message</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (PulsarClientException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>设置目标主题和订阅名后，调用 <code>subscribe()</code> 方法订阅该主题，创建 <code>Consumer</code>;</li>
<li>consumer 调用 <code>receive()</code> 方法接收消息。</li>
</ol>
<blockquote>
<p>这里先简单介绍一下，客户端的实现代码位于 <code>pulsar-client</code> 模块，而接口定义则位于 <code>pulsar-client-api</code> 模块，一些（broker 和客户端等）公用的类位于 <code>pulsar-common</code> 模块。而各模块均位于同名目录下。</p>
<p>另外 Pulsar 所有的同步调用 API 都只是简单等待异步调用 API（方法名后缀是 Async）返回的 CompletableFuture<T> 对象完成，其返回值为 T。</T></p>
</blockquote>
<h3 id="消费者的创建"><a href="#消费者的创建" class="headerlink" title="消费者的创建"></a>消费者的创建</h3><p>创建 <code>PulsarClient</code> 时实际上是创建了 <code>PulsarClientImpl</code> 对象，其中 <code>newConsumer</code> 方法是创建一个 builder 用于链式调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConsumerBuilder&lt;<span class="type">byte</span>[]&gt; newConsumer() &#123;</span><br><span class="line">    <span class="comment">// 另外从这里也可以看到默认的 consumer 是使用 bytes schema</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsumerBuilderImpl</span>&lt;&gt;(<span class="built_in">this</span>, Schema.BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 builder 的方法就不仔细阅读了，主要是对参数进行必要的验证后设置相应字段，比如必要的是主题名和订阅名，都保存在 <code>conf</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerBuilderImpl&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> ConsumerConfigurationData&lt;T&gt; conf;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsumerConfigurationData&lt;T&gt;</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; topicNames = Sets.newTreeSet();</span><br><span class="line"><span class="keyword">private</span> String subscriptionName;</span><br></pre></td></tr></table></figure>

<p><code>ConsumerBuilderImpl#subscribeAsync</code> 本身只是对 <code>conf</code> 的一些参数进行合法性校验，对于只设置主题名和订阅名的情况只是验证这两项配置是否存在，最后实际上是调用 <code>PulsarClientImpl#subscribeAsync</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">return</span> <span class="variable">interceptorList</span> <span class="operator">=</span>= <span class="literal">null</span> || interceptorList.size() == <span class="number">0</span> ?</span><br><span class="line">        client.subscribeAsync(conf, schema, <span class="literal">null</span>) : <span class="comment">// 默认 intercepto 为 null</span></span><br><span class="line">        client.subscribeAsync(conf, schema, <span class="keyword">new</span> <span class="title class_">ConsumerInterceptors</span>&lt;&gt;(interceptorList));</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PulsarClientImpl&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">subscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行一些合法性检查（这里略去代码），包括：</span></span><br><span class="line">    <span class="comment">// 1. client 状态为 Open</span></span><br><span class="line">    <span class="comment">// 2. conf != null</span></span><br><span class="line">    <span class="comment">// 3. conf.topicNames 的每个主题名的格式必须合法</span></span><br><span class="line">    <span class="comment">// 4. 对于 compacted topic，主题必须为 persistent，订阅模式必须为 Exclusive 或者 Failover</span></span><br><span class="line">    <span class="comment">// 5. 对于 ConsumerEventListener，订阅模式必须为 Failover</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conf.getTopicsPattern() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 正则订阅，此时禁止设置具体的主题名字（topicNames）</span></span><br><span class="line">        <span class="keyword">if</span> (!conf.getTopicNames().isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                .failedFuture(<span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Topic names list must be null when use topicsPattern&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> patternTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conf.getTopicNames().size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 单主题订阅</span></span><br><span class="line">        <span class="keyword">return</span> singleTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 多主题订阅</span></span><br><span class="line">        <span class="keyword">return</span> multiTopicSubscribeAsync(conf, schema, interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为求简单，还是只看单主题订阅的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">singleTopicSubscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> preProcessSchemaBeforeSubscribe(<span class="built_in">this</span>, schema, conf.getSingleTopic())</span><br><span class="line">        .thenCompose(schemaClone -&gt; doSingleTopicSubscribeAsync(conf, schemaClone, interceptors));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的先后顺序是：</p>
<ol>
<li>调用 <code>preProcessSchemaBeforeSubscribe</code>，此时会对 schema 进行预处理，必须注册 schema。</li>
<li>对前一步得到的 schemaClone 传入 <code>doSingleTopicSubscribeAsync</code>。</li>
</ol>
<p>这里关注第二步：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; CompletableFuture&lt;Consumer&lt;T&gt;&gt; <span class="title function_">doSingleTopicSubscribeAsync</span><span class="params">(ConsumerConfigurationData&lt;T&gt; conf, Schema&lt;T&gt; schema, ConsumerInterceptors&lt;T&gt; interceptors)</span> &#123;</span><br><span class="line">    CompletableFuture&lt;Consumer&lt;T&gt;&gt; consumerSubscribedFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">topic</span> <span class="operator">=</span> conf.getSingleTopic();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先取得 topic 的 metadata（目前仅包含 partitions 字段表示分区数量）</span></span><br><span class="line">    getPartitionedTopicMetadata(topic).thenAccept(metadata -&gt; &#123;</span><br><span class="line">        <span class="comment">/* debug 日志 ... */</span></span><br><span class="line">        ConsumerBase&lt;T&gt; consumer;</span><br><span class="line">        <span class="comment">// 从 executor provider（包含一组 executors）中分配一个 executor</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">listenerThread</span> <span class="operator">=</span> externalExecutorProvider.getExecutor();</span><br><span class="line">        <span class="keyword">if</span> (metadata.partitions &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 多分区订阅，创建的是 MultiTopicsConsumerImpl</span></span><br><span class="line">            consumer = MultiTopicsConsumerImpl.createPartitionedConsumer(PulsarClientImpl.<span class="built_in">this</span>, conf,</span><br><span class="line">                listenerThread, consumerSubscribedFuture, metadata.partitions, schema, interceptors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 单分区订阅，创建的是 ConsumerImpl</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> TopicName.getPartitionIndex(topic);</span><br><span class="line">            consumer = ConsumerImpl.newConsumerImpl(PulsarClientImpl.<span class="built_in">this</span>, topic, conf, listenerThread, partitionIndex, <span class="literal">false</span>,</span><br><span class="line">                    consumerSubscribedFuture,<span class="literal">null</span>, schema, interceptors,</span><br><span class="line">                    <span class="literal">true</span> <span class="comment">/* createTopicIfDoesNotExist */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumers.add(consumer); <span class="comment">// 将创建的 consumer 加入到 client 内部的 consumers 中</span></span><br><span class="line">    &#125;).exceptionally(<span class="comment">/* 异常处理... */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consumerSubscribedFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多分区订阅和多主题订阅本质上是一样的，都是使用 <code>MultiTopicsConsumerImpl</code> 管理多个主题（因为 Pulsar 中分区只不过是一个包含后缀 <code>-partition-&lt;n&gt;</code> 的主题）。</p>
</blockquote>
<p>这里还是关注单分区订阅，<code>ConsumerImpl.newConsumerImpl(...)</code> 只是将参数原封不动传给其构造方法，构造方法包括了 consumer 内部一些字段的初始化，因此比较长，我们还是只关注重点，那就是最简洁的订阅会和 broker 有什么交互。实际上这部分逻辑在构造方法最后，调用 <code>grabCnx</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">grabCnx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.connectionHandler.grabCnx();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接的建立"><a href="#连接的建立" class="headerlink" title="连接的建立"></a>连接的建立</h3><p><code>connectionHandler</code>（下文简称 connection）的构造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.connectionHandler = <span class="keyword">new</span> <span class="title class_">ConnectionHandler</span>(<span class="built_in">this</span>,</span><br><span class="line">		        <span class="keyword">new</span> <span class="title class_">BackoffBuilder</span>()</span><br><span class="line">                        <span class="comment">// 设置 BackOff 所需要的参数，参数对应 client 的配置为：</span></span><br><span class="line">                        <span class="comment">// initialTime: 默认 100 ms，ClientBuilder#startingBackoffInternal</span></span><br><span class="line">                        <span class="comment">// max: 默认 60 s，ClientBuilder#maxBackoffInterval</span></span><br><span class="line">                        <span class="comment">// mandatoryStop：固定为 0 ms</span></span><br><span class="line">                        <span class="comment">/* ... */</span></span><br><span class="line">                        .create(),</span><br><span class="line">        <span class="built_in">this</span>); <span class="comment">// 将 ConsumerImpl 对象自身传入 ConnectionHandler 的构造方法</span></span><br></pre></td></tr></table></figure>

<p>这里简单说下 <code>BackOff</code> 对象。查看 backoff 在 <code>ConnectionHandler</code> 中的使用，可以看到主要是在重连活着关闭连接时用 <code>next()</code> 方法来得到建立连接时对应的 timeout，因为连接对应的是 client，所以这里用的都是 client 的配置。</p>
<p>回到正题，继续看 <code>ConnectionHandler#grabCnx</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">grabCnx</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (CLIENT_CNX_UPDATER.get(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经连接成功了，无视这次调用</span></span><br><span class="line">        <span class="comment">/* warn 日志... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidStateForReconnection()) &#123;</span><br><span class="line">        <span class="comment">// 若 connection 状态不可用于重连（比如为 Closed），则无视这次调用</span></span><br><span class="line">        <span class="comment">/* info 日志... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 取得主题对应的连接</span></span><br><span class="line">        state.client.getConnection(state.topic) <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 2.1 若连接成功，则调用 connectionOpened</span></span><br><span class="line">                .thenAccept(cnx -&gt; connection.connectionOpened(cnx)) <span class="comment">//</span></span><br><span class="line">                <span class="comment">// 2.2 若连接失败，则调用 handleConnectionError，会进行重连操作</span></span><br><span class="line">                .exceptionally(<span class="built_in">this</span>::handleConnectionError);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">/* warn 日志... */</span></span><br><span class="line">        reconnectLater(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还是看看连接成功的处理。注意到 <code>ConsumerImpl</code> 是实现了 <code>Connection</code> 接口的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerImpl</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">ConsumerBase</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">ConnectionHandler</span>.Connection &#123;</span><br></pre></td></tr></table></figure>

<p>然后注意到构造 connection 时用的 <code>Connection</code> 接口就是 <code>ConsumerImpl</code> 对象自己，因此调用的是 <code>ConsumerImpl#connectionOpened</code>。</p>
<p>实际上这一小节的内容同样也适用于生产者以及多主题消费者，它们对应的类都实现了 <code>Connection</code> 接口，只需要实现各自的回调即可。</p>
<h3 id="连接成功的回调"><a href="#连接成功的回调" class="headerlink" title="连接成功的回调"></a>连接成功的回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connectionOpened</span><span class="params">(<span class="keyword">final</span> ClientCnx cnx)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getState() == State.Closing || getState() == State.Closed) &#123;</span><br><span class="line">        <span class="comment">/* 执行一些清理工作... */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 client 到 connection，前面 grabCnx() 检查的 CLIENT_CNX_UPDATER 也会在这里设置</span></span><br><span class="line">    setClientCnx(cnx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* info 日志表示准备订阅对应主题... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">requestId</span> <span class="operator">=</span> client.newRequestId();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> currentSize;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// incomingMessages 为客户端缓存收到消息的队列（接收队列），这里先取得其大小</span></span><br><span class="line">        currentSize = incomingMessages.size();</span><br><span class="line">        <span class="comment">// 清空接收队列，取得第一条消息的 id（也就是消费者第一条没有传给应用程序的消息的 id）</span></span><br><span class="line">        startMessageId = clearReceiverQueue();</span><br><span class="line">        <span class="comment">// 清空 DLQ</span></span><br><span class="line">        <span class="keyword">if</span> (possibleSendToDeadLetterTopicMessages != <span class="literal">null</span>) &#123;</span><br><span class="line">            possibleSendToDeadLetterTopicMessages.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isDurable</span> <span class="operator">=</span> subscriptionMode == SubscriptionMode.Durable;</span><br><span class="line">    <span class="type">MessageIdData</span> <span class="variable">startMessageIdData</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isDurable) &#123;</span><br><span class="line">        <span class="comment">// 对持久化订阅，那么将 startMessageIdData 置为 null，因为 broker 负责告诉客户端重新开始消费的消息 id</span></span><br><span class="line">        startMessageIdData = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (startMessageId != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 对非持久化订阅（常用于 Reader API），则要用我们之前取得的第一条消息的 id</span></span><br><span class="line">        MessageIdData.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> MessageIdData.newBuilder();</span><br><span class="line">        builder.setLedgerId(startMessageId.getLedgerId());</span><br><span class="line">        builder.setEntryId(startMessageId.getEntryId());</span><br><span class="line">        <span class="keyword">if</span> (startMessageId <span class="keyword">instanceof</span> BatchMessageIdImpl) &#123;</span><br><span class="line">            builder.setBatchIndex(startMessageId.getBatchIndex());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startMessageIdData = builder.build();</span><br><span class="line">        builder.recycle();</span><br><span class="line">    &#125; <span class="comment">// else: 非持久化订阅，但是缓存队列里没有消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得 schema</span></span><br><span class="line">    <span class="type">SchemaInfo</span> <span class="variable">si</span> <span class="operator">=</span> schema.getSchemaInfo();</span><br><span class="line">    <span class="keyword">if</span> (si != <span class="literal">null</span> &amp;&amp; (SchemaType.BYTES == si.getType() || SchemaType.NONE == si.getType())) &#123;</span><br><span class="line">        <span class="comment">// don&#x27;t set schema for Schema.BYTES</span></span><br><span class="line">        si = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 CommandSubscribe 并发送，具体字段就不贴出来了</span></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">request</span> <span class="operator">=</span> Commands.newSubscribe(<span class="comment">/* ... */</span>);</span><br><span class="line">    cnx.sendRequestWithId(request, requestId).thenRun(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// case 1 发送成功</span></span><br><span class="line">        <span class="keyword">synchronized</span> (ConsumerImpl.<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 State 是 Uninitialized，Connecting，RegisteringSchema，则将其改为 Ready</span></span><br><span class="line">            <span class="keyword">if</span> (changeToReadyState()) &#123;</span><br><span class="line">                <span class="comment">// 将 availablePermits 置为 0</span></span><br><span class="line">                consumerIsReconnectedToBroker(cnx, currentSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其它 state 比如 Failed 则代表异常状态，此时将 state 置为 Closed</span></span><br><span class="line">                setState(State.Closed);</span><br><span class="line">                deregisterFromClientCnx(); <span class="comment">// 将 consumer 和 connection 解绑</span></span><br><span class="line">                client.cleanupConsumer(<span class="built_in">this</span>); <span class="comment">// 将 consumer 从 client 中移除</span></span><br><span class="line">                cnx.channel().close(); <span class="comment">// 关闭连接</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重制 BackOff，因为之前可能重连过导致 BackOff 内部状态发生变化，</span></span><br><span class="line">        resetBackoff();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 subscribeFuture 可能多次 complete，因此这里判断是否为第一次 complete</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstTimeConnect</span> <span class="operator">=</span> subscribeFuture.complete(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 如果 receiverQueueSize（内部接收队列的大小）大于 0，则代表 consumer 有缓冲区可以接收消息。</span></span><br><span class="line">        <span class="comment">// 此时，会将接收队列大小的一半作为 permits 发送 Flow 请求</span></span><br><span class="line">        <span class="comment">// 但还有一种情况也不会发送，也就是满足以下三个条件：</span></span><br><span class="line">        <span class="comment">// 1. 第一次连接完成</span></span><br><span class="line">        <span class="comment">// 2. 当前 consumer 是一个子 consumer</span></span><br><span class="line">        <span class="comment">// 3. 订阅类型是持久化（NOTE：这个条件可能是早期错误，见 https://github.com/apache/pulsar/pull/3960）</span></span><br><span class="line">        <span class="comment">// 因为当 consumer 是子 consumer 的时候，它归属于 MultiTopicsConsumerImpl，也就是多分区/主题的 consumer</span></span><br><span class="line">        <span class="comment">// MultiTopicsConsumerImpl 会在所有子 consumer 连接完成后再调用 startReceivingMessages</span></span><br><span class="line">        <span class="comment">// 从而对每个子 consumer 调用 increaseAvailablePermits</span></span><br><span class="line">        <span class="keyword">if</span> (!(firstTimeConnect &amp;&amp; hasParentConsumer &amp;&amp; isDurable) &amp;&amp; conf.getReceiverQueueSize() != <span class="number">0</span>) &#123;</span><br><span class="line">            increaseAvailablePermits(cnx, conf.getReceiverQueueSize());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).exceptionally((e) -&gt; &#123;<span class="comment">/* 异常处理... */</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到连接成功后，主要是发送 CommandSubscribe（订阅命令），broker 处理成功后，consumer 就处于 Ready 状态，并且会发送 Flow 请求携带 permits 为接收队列大小的一半。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">increaseAvailablePermits</span><span class="params">(ClientCnx currentCnx, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="comment">// availablePermits 增加 delta，代表可用的接收队列的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> AVAILABLE_PERMITS_UPDATER.addAndGet(<span class="built_in">this</span>, delta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果超过了阈值（默认一半接收队列大小）且没有调用 pause，则将其清零，并将清零前的值构造 Flow 命令发送</span></span><br><span class="line">    <span class="keyword">while</span> (available &gt;= receiverQueueRefillThreshold &amp;&amp; !paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (AVAILABLE_PERMITS_UPDATER.compareAndSet(<span class="built_in">this</span>, available, <span class="number">0</span>)) &#123;</span><br><span class="line">            sendFlowPermitsToBroker(currentCnx, available);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            available = AVAILABLE_PERMITS_UPDATER.get(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 Flow 命令的定义和发送：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">CommandFlow</span> &#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint64</span> consumer_id       = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预先拉取的消息数量，也称为 permits</span></span><br><span class="line">    <span class="keyword">required</span> <span class="type">uint32</span> messagePermits     = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sendFlowPermitsToBroker</span><span class="params">(ClientCnx cnx, <span class="type">int</span> numMessages)</span> &#123;</span><br><span class="line">    <span class="comment">// 仅当连接未断开且消息数大于 0 才会发送 Flow 请求，因为 broker 收到 permits 为 0 的请求会直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (cnx != <span class="literal">null</span> &amp;&amp; numMessages &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="comment">/* ... */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnx.ctx().writeAndFlush(Commands.newFlow(consumerId, numMessages), cnx.ctx().voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Broker-处理"><a href="#Broker-处理" class="headerlink" title="Broker 处理"></a>Broker 处理</h2><h3 id="CommandSubscribe-处理"><a href="#CommandSubscribe-处理" class="headerlink" title="CommandSubscribe 处理"></a>CommandSubscribe 处理</h3><p>broker 对 TCP 协议的处理位于 <code>org.apache.pulsar.broker.service</code> 包的 <code>ServerCnx</code> 类。对于 consumer 而言，比较独有的就是 <code>CommandSubscribe</code> 和 <code>CommandFlow</code>。</p>
<p>因为代码比较长，所以日志相关代码均略过，不特意用 <code>/* xxx... */</code> 说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleSubscribe</span><span class="params">(<span class="keyword">final</span> CommandSubscribe subscribe)</span> &#123;</span><br><span class="line">    <span class="comment">/* 略去相关字段的解析... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否具有 CONSUME 权限</span></span><br><span class="line">    CompletableFuture&lt;Boolean&gt; isAuthorizedFuture = isTopicOperationAllowed(</span><br><span class="line">            topicName,</span><br><span class="line">            subscriptionName,</span><br><span class="line">            TopicOperation.CONSUME</span><br><span class="line">    );</span><br><span class="line">    isAuthorizedFuture.thenApply(isAuthorized -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (isAuthorized) &#123;</span><br><span class="line">            <span class="comment">/* 验证 metadata 字段...*/</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 这里的 Consumer 是 broker consumer，对应每个 client consumer</span></span><br><span class="line">            CompletableFuture&lt;Consumer&gt; consumerFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">            CompletableFuture&lt;Consumer&gt; existingConsumerFuture = consumers.putIfAbsent(consumerId,</span><br><span class="line">                    consumerFuture);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (existingConsumerFuture != <span class="literal">null</span>) &#123; <span class="comment">// 已经创建过 broker consumer</span></span><br><span class="line">                <span class="keyword">if</span> (existingConsumerFuture.isDone() &amp;&amp; !existingConsumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">                    <span class="comment">// 创建完成则直接发送成功的响应</span></span><br><span class="line">                    commandSender.sendSuccessResponse(requestId);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 之前已经有相同 consumerId 的 subscribe 请求，这是因为 client timeout 小于 broker timeout，</span></span><br><span class="line">                    <span class="comment">// 因此 client 发生重试，此时需要等待之前的 consumer future 完成</span></span><br><span class="line">                    <span class="type">ServerError</span> <span class="variable">error</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!existingConsumerFuture.isDone()) &#123;</span><br><span class="line">                        <span class="comment">// 前一个 subscribe 请求还未完成，直接返回 ServiceNotReady</span></span><br><span class="line">                        error = ServerError.ServiceNotReady;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 前一个 subscribe 请求异常完成，则返回同样的错误码并将其移除 cache 避免下次重新进入此分支</span></span><br><span class="line">                        error = getErrorCode(existingConsumerFuture);</span><br><span class="line">                        consumers.remove(consumerId, existingConsumerFuture);</span><br><span class="line">                    &#125;</span><br><span class="line">                    commandSender.sendErrorResponse(requestId, error,</span><br><span class="line">                            <span class="string">&quot;Consumer is already present on the connection&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否自动创建 topic，forceTopicCreation 为 client 填充的字段（NOTE：实际上永远为 true）</span></span><br><span class="line">            <span class="comment">// service 对象则是通过配置或者 system topic 的配置来判断是否允许自动创建 topic</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">createTopicIfDoesNotExist</span> <span class="operator">=</span> forceTopicCreation</span><br><span class="line">                    &amp;&amp; service.isAllowAutoTopicCreation(topicName.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前 broker 获取或创建 Topic 对象</span></span><br><span class="line">            service.getTopic(topicName.toString(), createTopicIfDoesNotExist)</span><br><span class="line">                    .thenCompose(optTopic -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!optTopic.isPresent()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                                    .failedFuture(<span class="keyword">new</span> <span class="title class_">TopicNotFoundException</span>(</span><br><span class="line">                                            <span class="string">&quot;Topic &quot;</span> + topicName + <span class="string">&quot; does not exist&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="type">Topic</span> <span class="variable">topic</span> <span class="operator">=</span> optTopic.get();</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 对于 durable cursor 而言，如果该订阅不存在且不允许订阅自动创建，subscribe 会失败</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">rejectSubscriptionIfDoesNotExist</span> <span class="operator">=</span> isDurable</span><br><span class="line">                            &amp;&amp; !service.isAllowAutoSubscriptionCreation(topicName.toString())</span><br><span class="line">                            &amp;&amp; !topic.getSubscriptions().containsKey(subscriptionName);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (rejectSubscriptionIfDoesNotExist) &#123;</span><br><span class="line">                            <span class="keyword">return</span> FutureUtil</span><br><span class="line">                                    .failedFuture(</span><br><span class="line">                                            <span class="keyword">new</span> <span class="title class_">SubscriptionNotFoundException</span>(</span><br><span class="line">                                                    <span class="string">&quot;Subscription does not exist&quot;</span>));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 若带有 schema 则先检查 schema 兼容性，最后都会调用 Topic#subscribe</span></span><br><span class="line">                        <span class="keyword">if</span> (schema != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">return</span> topic.addSchemaIfIdleOrCheckCompatible(schema)</span><br><span class="line">                                    .thenCompose(v -&gt; topic.subscribe(<span class="comment">/* ... */</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> topic.subscribe(<span class="comment">/* ... */</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .thenAccept(consumer -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (consumerFuture.complete(consumer)) &#123;</span><br><span class="line">                            commandSender.sendSuccessResponse(requestId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果 consumerFuture 已经完成，则当前 consumer 是 client timeout 重新创建的 consumer</span></span><br><span class="line">                            <span class="comment">// 此时需要关闭 consumer 并移除这个 future</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                consumer.close();</span><br><span class="line">                                log.info(<span class="string">&quot;[&#123;&#125;] Cleared consumer created after timeout on client side &#123;&#125;&quot;</span>,</span><br><span class="line">                                        remoteAddress, consumer);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (BrokerServiceException e) &#123;</span><br><span class="line">                                log.warn(</span><br><span class="line">                                        <span class="string">&quot;[&#123;&#125;] Error closing consumer created&quot;</span></span><br><span class="line">                                                + <span class="string">&quot; after timeout on client side &#123;&#125;: &#123;&#125;&quot;</span>,</span><br><span class="line">                                        remoteAddress, consumer, e.getMessage());</span><br><span class="line">                            &#125;</span><br><span class="line">                            consumers.remove(consumerId, consumerFuture);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;)</span><br><span class="line">                    .exceptionally(exception -&gt; &#123;</span><br><span class="line">                        <span class="comment">/* 根据异常严重性打印对应等级的日志... */</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 返回错误码移除订阅失败过程中添加的 consumer</span></span><br><span class="line">                        <span class="keyword">if</span> (consumerFuture.completeExceptionally(exception)) &#123;</span><br><span class="line">                            commandSender.sendErrorResponse(requestId,</span><br><span class="line">                                    BrokerServiceException.getClientErrorCode(exception),</span><br><span class="line">                                    exception.getCause().getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">                        consumers.remove(consumerId, consumerFuture);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 鉴权失败</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;Client is not authorized to subscribe&quot;</span>;</span><br><span class="line">            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;).exceptionally(ex -&gt; &#123; <span class="comment">// 鉴权抛出异常</span></span><br><span class="line">        commandSender.sendErrorResponse(requestId, ServerError.AuthorizationError, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结下来，处理 subscribe 请求核心调用是：</p>
<ul>
<li><code>BrokerService#getTopic</code>：获取当前 broker 所拥有（own）的 <code>Topic</code> 对象</li>
<li><code>Topic#subscribe</code>：在 <code>Topic</code> 对象中创建对应的订阅，并得到 <code>Consumer</code> 对象</li>
</ul>
<p>其中 <code>Topic</code> 和 <code>Consumer</code> 是 broker 端对 topic 和 consumer 的抽象，负责管理对应的资源。均位于 <code>org.apache.pulsar.broker.service</code> 包下。这里我们重点看 <code>PersistentTopic#subscribe</code>。</p>
<h3 id="PersistentTopic-subscribe"><a href="#PersistentTopic-subscribe" class="headerlink" title="PersistentTopic#subscribe"></a>PersistentTopic#subscribe</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CompletableFuture&lt;Consumer&gt; <span class="title function_">subscribe</span><span class="params">(<span class="comment">/* ... */</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 只有 Failover 和 Exclusive 模式才支持读取 compacted topic</span></span><br><span class="line">    <span class="keyword">if</span> (readCompacted &amp;&amp; !(subType == SubType.Failover || subType == SubType.Exclusive)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FutureUtil.failedFuture(<span class="keyword">new</span> <span class="title class_">NotAllowedException</span>(</span><br><span class="line">                <span class="string">&quot;readCompacted only allowed on failover or exclusive subscriptions&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 NamespaceService 检查 topic owner 是否为当前 broker，若不是则该 future 会以 ServiceUnitNotReady 异常完成</span></span><br><span class="line">    <span class="keyword">return</span> brokerService.checkTopicNsOwnership(getName()).thenCompose(__ -&gt; &#123;</span><br><span class="line">        <span class="comment">/* 进行一系列检查... （这里略去具体代码，仅用注释说明） */</span></span><br><span class="line">        <span class="comment">// 1. 若 broker 未启用订阅复制，则仅仅是打印 warn 日志，防止 broker 禁止跨地域复制后 consumer 订阅失败</span></span><br><span class="line">        <span class="comment">// 2. 检查 broker 是否支持 Key_Shared 订阅模式</span></span><br><span class="line">        <span class="comment">// 3. 检查非 system topic（以 __change_events 结尾）的 topic 级别配置是否支持该订阅类型</span></span><br><span class="line">        <span class="comment">// 4. 检查订阅名是否为空</span></span><br><span class="line">        <span class="comment">// 5. 检查协议是否支持 batch 消息</span></span><br><span class="line">        <span class="comment">// 6. 禁止对前缀是跨地域复制的前缀（默认 pulsar.repl）或者 pulsar.dedup 创建订阅</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用连接地址作为 key，检查 consumer 对应的 RateLimiter 是否存在，限制重连次数，因为重连的连接地址是相同的</span></span><br><span class="line">        <span class="comment">// 参考 https://github.com/apache/pulsar/pull/2977</span></span><br><span class="line">        <span class="keyword">if</span> (cnx.clientAddress() != <span class="literal">null</span> &amp;&amp; cnx.clientAddress().toString().contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">            SubscribeRateLimiter.<span class="type">ConsumerIdentifier</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubscribeRateLimiter</span>.ConsumerIdentifier(</span><br><span class="line">                    cnx.clientAddress().toString().split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>], consumerName, consumerId);</span><br><span class="line">            <span class="keyword">if</span> (subscribeRateLimiter.isPresent() &amp;&amp; (!subscribeRateLimiter.get().subscribeAvailable(consumer)</span><br><span class="line">                    || !subscribeRateLimiter.get().tryAcquire(consumer))) &#123;</span><br><span class="line">                <span class="comment">/* warn 日志... */</span></span><br><span class="line">                <span class="keyword">return</span> FutureUtil.failedFuture(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">NotAllowedException</span>(<span class="string">&quot;Subscribe limited by subscribe rate limit per consumer.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当 topic 被删除或关闭，或者 producer 写消息失败时都会标记为 fence 状态，此时禁止订阅</span></span><br><span class="line">            <span class="keyword">if</span> (isFenced) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;[&#123;&#125;] Attempting to subscribe to a fenced topic&quot;</span>, topic);</span><br><span class="line">                <span class="keyword">return</span> FutureUtil.failedFuture(<span class="keyword">new</span> <span class="title class_">TopicFencedException</span>(<span class="string">&quot;Topic is temporarily unavailable&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 实际上是增加 usageCount（连接的 producer 和 consumer 总数），传参数是为了打印 debug 日志</span></span><br><span class="line">            handleConsumerAdded(subscriptionName, consumerName);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取（或创建）订阅</span></span><br><span class="line">        CompletableFuture&lt;? <span class="keyword">extends</span> <span class="title class_">Subscription</span>&gt; subscriptionFuture = isDurable ? <span class="comment">//</span></span><br><span class="line">                getDurableSubscription(subscriptionName, initialPosition, startMessageRollbackDurationSec,</span><br><span class="line">                        replicatedSubscriptionState)</span><br><span class="line">                : getNonDurableSubscription(subscriptionName, startMessageId, initialPosition,</span><br><span class="line">                startMessageRollbackDurationSec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于持久化订阅，可以获取最大的未确认的消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxUnackedMessages</span> <span class="operator">=</span> isDurable</span><br><span class="line">                ? getMaxUnackedMessagesOnConsumer()</span><br><span class="line">                : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Consumer&gt; future = subscriptionFuture.thenCompose(subscription -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建 Consumer 对象并加入到对应的订阅中</span></span><br><span class="line">            <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(<span class="comment">/* ... */</span>);</span><br><span class="line">            <span class="keyword">return</span> addConsumerToSubscription(subscription, consumer).thenCompose(v -&gt; &#123;</span><br><span class="line">                checkBackloggedCursors();</span><br><span class="line">                <span class="keyword">if</span> (!cnx.isActive()) &#123;</span><br><span class="line">                    <span class="comment">// 连接已经断开，则需要关闭 consumer</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        consumer.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokerServiceException e) &#123;</span><br><span class="line">                        <span class="comment">/* ... */</span></span><br><span class="line">                        <span class="comment">// 减少 usageCount，对应 handleConsumerAdded</span></span><br><span class="line">                        decrementUsageCount(); </span><br><span class="line">                        <span class="keyword">return</span> FutureUtil.failedFuture(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    decrementUsageCount();</span><br><span class="line">                    <span class="keyword">return</span> FutureUtil.failedFuture(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">BrokerServiceException</span>(<span class="string">&quot;Connection was closed while the opening the cursor &quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 连接仍存活，则继续检查复制订阅的状态，至此完成整个订阅</span></span><br><span class="line">                    checkReplicatedSubscriptionControllerState();</span><br><span class="line">                    <span class="keyword">return</span> CompletableFuture.completedFuture(consumer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        future.exceptionally(ex -&gt; &#123;</span><br><span class="line">            decrementUsageCount();</span><br><span class="line">            <span class="comment">/* 打印日志... */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心流程：</p>
<ol>
<li>获取 <code>Subscription</code>（broker 对订阅的抽象），若不存在则创建。</li>
<li>创建 <code>Consumer</code>（broker 对消费者的抽象）后加入订阅。</li>
</ol>
<p>这里不进一步阅读 <code>Subscription</code> 代码。简单说，在创建订阅时，对于持久化（durable）订阅（<code>PersistentSubscription</code>），创建时会打开一个 cursor，对应于 <code>PersistentTopic</code> 内部的 ledger，若 cursor 不存在则创建；对于非持久化（non-durable）订阅（<code>NonPersistentSubscription</code>），则是直接内存中维护消息 id（<code>MessageIdImpl</code>）。两者最大的区别是，持久化订阅在 cursor 已存在时，直接打开 cursor，而无视掉 CommandSubscribe 中的消息 id。</p>
<p>至于将 consumer 加入订阅，实际上是根据订阅类型创建对应的 dispatcher（<code>Dispatcher</code>），这里以默认的 Exclusive 订阅为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (consumer.subType()) &#123;</span><br><span class="line">    <span class="keyword">case</span> Exclusive:</span><br><span class="line">        <span class="keyword">if</span> (dispatcher == <span class="literal">null</span> || dispatcher.getType() != SubType.Exclusive) &#123;</span><br><span class="line">            previousDispatcher = dispatcher;</span><br><span class="line">            dispatcher = useStreamingDispatcher</span><br><span class="line">                    ? <span class="keyword">new</span> <span class="title class_">PersistentStreamingDispatcherSingleActiveConsumer</span>(</span><br><span class="line">                            cursor, SubType.Exclusive, <span class="number">0</span>, topic, <span class="built_in">this</span>)</span><br><span class="line">                    : <span class="keyword">new</span> <span class="title class_">PersistentDispatcherSingleActiveConsumer</span>(</span><br><span class="line">                            cursor, SubType.Exclusive, <span class="number">0</span>, topic, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：<a target="_blank" rel="noopener" href="https://github.com/apache/pulsar/pull/9056">https://github.com/apache/pulsar/pull/9056</a> 引入了 streaming dispatcher。</p>
</blockquote>
<p>然后将 consumer 加入 dispatcher：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dispatcher.addConsumer(consumer);</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BrokerServiceException brokerServiceException) &#123;</span><br><span class="line">    <span class="keyword">return</span> FutureUtil.failedFuture(brokerServiceException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>订阅里实际负责消息分发的就是 dispatcher。</p>
<h3 id="CommandFlow"><a href="#CommandFlow" class="headerlink" title="CommandFlow"></a>CommandFlow</h3><p>首先是 <code>ServerCnx</code> 第一步处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleFlow</span><span class="params">(CommandFlow flow)</span> &#123;</span><br><span class="line">    checkArgument(state == State.Connected); <span class="comment">// 必须是 Connected 状态</span></span><br><span class="line">    CompletableFuture&lt;Consumer&gt; consumerFuture = consumers.get(flow.getConsumerId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 consumer 已经创建成功，则直接交给 Consumer 处理</span></span><br><span class="line">    <span class="keyword">if</span> (consumerFuture != <span class="literal">null</span> &amp;&amp; consumerFuture.isDone() &amp;&amp; !consumerFuture.isCompletedExceptionally()) &#123;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> consumerFuture.getNow(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (consumer != <span class="literal">null</span>) &#123;</span><br><span class="line">            consumer.flowPermits(flow.getMessagePermits());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后递交给 <code>Consumer</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flowPermits</span><span class="params">(<span class="type">int</span> additionalNumberOfMessages)</span> &#123;</span><br><span class="line">    checkArgument(additionalNumberOfMessages &gt; <span class="number">0</span>); <span class="comment">// permits 必须大于 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 对于只支持 individual ack 的订阅类型，检查没有确认的（unacked）消息数量</span></span><br><span class="line">    <span class="keyword">if</span> (shouldBlockConsumerOnUnackMsgs() &amp;&amp; unackedMessages &gt;= maxUnackedMessages) &#123;</span><br><span class="line">        blockedConsumerOnUnackedMsgs = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> oldPermits;</span><br><span class="line">    <span class="keyword">if</span> (!blockedConsumerOnUnackedMsgs) &#123;</span><br><span class="line">        <span class="comment">// 1.1 正常情况下，增加 messagePermits，然后交给 subscription 处理</span></span><br><span class="line">        oldPermits = MESSAGE_PERMITS_UPDATER.getAndAdd(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">        subscription.consumerFlow(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1.2 如果 unacked 消息数量超过限制，则更新 permitsReceivedWhileConsumerBlocked 记录因此阻塞的 flow permits</span></span><br><span class="line">        oldPermits = PERMITS_RECEIVED_WHILE_CONSUMER_BLOCKED_UPDATER.getAndAdd(<span class="built_in">this</span>, additionalNumberOfMessages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可见，更新完 <code>Consumer</code> 内部的 <code>messagePermits</code> 后，交由对应的 <code>Subscription</code> 对象处理。这里仅看 <code>PersistentSubscription</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consumerFlow</span><span class="params">(Consumer consumer, <span class="type">int</span> additionalNumberOfMessages)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lastConsumedFlowTimestamp = System.currentTimeMillis();</span><br><span class="line">    dispatcher.consumerFlow(consumer, additionalNumberOfMessages);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅仅是传递给 dispatcher。因此实际的处理是由 dispatcher 完成的。至于 dispatcher 的实现就留给下一篇进行讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文梳理了 client 和 broker 创建消费者订阅某个 topic 的流程。Client 端的实现包含了一些和生产者通用的部分，也就是建立连接的部分。连接成功后的回调，消费者会先发一个 subscribe 命令注册自己，注册成功后发送 flow 请求，携带 permits，其值为内部缓冲区大小的一半（对于无缓冲区的 zero queue consumer 例外）。</p>
<p>Broker 端处理相对复杂，但本质是对一些概念进行了抽象。消费者对应 <code>Consumer</code>，每个消费者则包含一个订阅 <code>Subscription</code>。而 topic 对应 <code>Topic</code>，消费者发送 subscribe 命令时会在 <code>Topic</code> 里创建 <code>Subscription</code>，因为每个 topic 可以对应多个订阅，创建完成后根据消费者的订阅类型创建对应的 <code>Dispatcher</code>。通常意义上一个订阅可以对应多个消费者，但实际上真正维护这组消费者的不是 <code>Subscription</code> 而是 <code>Dispatcher</code>，订阅本身更多的是维护 cursor（消费进度），比如持久化订阅（<code>PersistentSubscription</code>）就会创建一个 durable cursor。而 client 端的 Flow 请求，最终也是 <code>Dispatcher</code> 来处理的。</p>
<p>最后解答最初提出的问题，push 和 pull 的区别，以及为什么 Pulsar 是 push 消费模型。Kafka 的消费者是发送 FETCH 请求给 broker，然后 broker 对应的 FETCH 响应里包含读取的消息。而 Pulsar 的消费者发送的是 Flow 请求，它本身是没有对应的 FETCH 响应的。Client 会主动告知 broker 自己可以缓存多少条消息，broker 根据这个提示可以灵活定制 dispatcher，然后主动发消息给 client。因此 Pulsar 的这种 push 模型，实际上是由服务端（broker）来进行流量控制。两者本质区别就是流控到底是 client 还是 server 处理的。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Pulsar/" rel="tag"># Pulsar</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/08/21/Netty-and-NIO-buffer/" rel="prev" title="Netty-and-NIO-buffer">
      <i class="fa fa-chevron-left"></i> Netty-and-NIO-buffer
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/10/03/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Golang/" rel="next" title="重新学习 Golang">
      重新学习 Golang <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client"><span class="nav-number">3.</span> <span class="nav-text">Client</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.1.</span> <span class="nav-text">消费者的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">3.2.</span> <span class="nav-text">连接的建立</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="nav-number">3.3.</span> <span class="nav-text">连接成功的回调</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Broker-%E5%A4%84%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">Broker 处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CommandSubscribe-%E5%A4%84%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">CommandSubscribe 处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PersistentTopic-subscribe"><span class="nav-number">4.2.</span> <span class="nav-text">PersistentTopic#subscribe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CommandFlow"><span class="nav-number">4.3.</span> <span class="nav-text">CommandFlow</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XYZ, aka BewareMyPower</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XYZ, aka BewareMyPower</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v6.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
